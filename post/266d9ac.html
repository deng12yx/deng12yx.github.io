<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>leetcode100题_2 - BeautyFlower</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Icaurs - Hexo Theme"><meta name="msapplication-TileImage" content="icons/touch-icon-iphone.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Icaurs - Hexo Theme"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="icons/touch-icon-iphone.png"><link rel="apple-touch-icon" sizes="152x152" href="icons/touch-icon-ipad.png"><link rel="apple-touch-icon" sizes="72x72" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="96x96" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="128x128" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="256x256" href="icon/logo.ico"><meta name="description" content="leetcode必做100题第二部分"><meta property="og:type" content="blog"><meta property="og:title" content="leetcode100题_2"><meta property="og:url" content="http://example.com/post/266d9ac.html"><meta property="og:site_name" content="BeautyFlower"><meta property="og:description" content="leetcode必做100题第二部分"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/article/19.png"><meta property="article:published_time" content="2023-08-07T04:27:24.000Z"><meta property="article:modified_time" content="2024-10-08T10:56:16.493Z"><meta property="article:author" content="yyyyyyxnp"><meta property="article:tag" content="c"><meta property="article:tag" content="c++"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/article/19.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/post/266d9ac.html"},"headline":"leetcode100题_2","image":["http://example.com/img/article/19.png"],"datePublished":"2023-08-07T04:27:24.000Z","dateModified":"2024-10-08T10:56:16.493Z","author":{"@type":"Person","name":"yyyyyyxnp"},"publisher":{"@type":"Organization","name":"BeautyFlower","logo":{"@type":"ImageObject","url":{"text":"BeautyFlower"}}},"description":"leetcode必做100题第二部分"}</script><link rel="canonical" href="http://example.com/post/266d9ac.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="BeautyFlower" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">BeautyFlower</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/deng12yx"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/article/19.png" alt="leetcode100题_2"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item copyright article-title type-2">原创</span><span class="level-item">Posted&nbsp;<time dateTime="2023-08-07T04:27:24.000Z" title="2023/8/7 12:27:24">2023-08-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-08T10:56:16.493Z" title="2024/10/8 18:56:16">2024-10-08</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="level-item">33 minutes read (About 4959 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile"> leetcode100题_2</h1><div class="copyright article-block type-2"><p>版权申明：本文为原创文章，转载请注明原文出处</p><p>原文链接：<a href="http://example.com/post/266d9ac.html" target="_blank">http://example.com/post/266d9ac.html</a></p></div><h1 class="title is-3 is-size-4-mobile">leetcode100题_2</h1><div class="content"><p>leetcode必做100题第二部分</p>
<span id="more"></span>
<h2 id="多数元素简单">多数元素（简单）</h2>
<h3 id="题目描述">题目描述</h3>
<p>给定一个大小为 <code>n</code> 的数组 <code>nums</code>
，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong>
<code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h3 id="知识点">知识点</h3>
<ol type="1">
<li><p>找到哈希的最大键值及索引</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义比较的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_value</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; left,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> left.second &lt; right.second;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; test;</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	test.<span class="built_in">emplace</span>(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">	test.<span class="built_in">emplace</span>(<span class="number">3</span>, <span class="number">17</span>);</span><br><span class="line">	test.<span class="built_in">emplace</span>(<span class="number">19</span>, <span class="number">20</span>);</span><br><span class="line">	test.<span class="built_in">emplace</span>(<span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">	<span class="comment">//输出按序排列的key值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : test)</span><br><span class="line">		cout &lt;&lt; it.first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//i是迭代器  返回值为19-20</span></span><br><span class="line">	<span class="keyword">auto</span> i= <span class="built_in">max_element</span>(test.<span class="built_in">begin</span>(),test.<span class="built_in">end</span>(),cmp_value);</span><br><span class="line">	cout &lt;&lt; i-&gt;first &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路两个思路">思路（两个思路）</h3>
<h4 id="思路一">思路一</h4>
<p>用哈希，键是元素，值是元素在数组中的次数，也就是遍历一次数组，时间空间复杂度均为n</p>
<h4 id="代码一">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            hash[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">max_element</span>(hash.<span class="built_in">begin</span>(), hash.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; p1, <span class="type">const</span> <span class="keyword">auto</span>&amp; p2)&#123;</span><br><span class="line">       <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">   &#125;);</span><br><span class="line">        <span class="keyword">return</span> i-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二boyer-moore-投票算法">思路二：Boyer-Moore 投票算法</h4>
<p>我在这里对这个算法有一个另外的解释，比如在一个数组中，7是这个数组中的众数，现在我们随机删除两个不同的数，最后留下来的肯定就都是众数，考虑两种极端情况，只删除不是众数的值，很显然符合，如果都删除是众数的值，但是众数的值已经超过了一半，而且我们考虑的是删除两个不同的值，所以就算其他值删完了，众数还存在</p>
<p>代码删除值的方式为记录一个值出现的次数，遇到相同的次数加一，遇到不同的减一，最后变为0就相当于删除了和它同等数量的不同的值，再进行新一轮，记录新的值出现的次数，最后剩下的肯定是众数</p>
<h4 id="代码二">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> number:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candidate==number)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    candidate=number;</span><br><span class="line">                    count=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="轮转数组中等">轮转数组（中等）</h2>
<h3 id="题目描述-1">题目描述</h3>
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转
<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<h3 id="思路">思路</h3>
<h4 id="思路一-1">思路一</h4>
<p>最简单的思路，将数组复制，再移动</p>
<p>时间复杂度为O(n)，空间复杂度为O(n)</p>
<h4 id="代码一-1">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numcopy</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            nums[(i+k)%length]=numcopy[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二">思路二</h4>
<p>绞尽脑汁想出来的哈哈哈</p>
<p>大概思路是选一个点进行移动，移动到最后肯定会返回值到最初的那个点，然后记录下移动过的数离自己最近的点，下次移动就移动这一个区间就可以了，移动的思路就是tempo2记录i位置的值，tempo1记录i+k位置的值，i+k换成tempo2，tempo2更新为tempo1，直到最后要更新的位置是起始点</p>
<p>时间复杂度为O(n)，空间复杂度为O(1)</p>
<h4 id="代码二-1">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>||length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tempo1;</span><br><span class="line">        <span class="type">int</span> tempo2;</span><br><span class="line">        <span class="type">int</span> add=k;</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;add;i++)&#123;</span><br><span class="line">            start=i;</span><br><span class="line">            tempo2=nums[i];</span><br><span class="line">            <span class="keyword">while</span>((start+k)%length!=i)&#123;</span><br><span class="line">                add=<span class="built_in">min</span>(add,(start+k)%length);</span><br><span class="line">                tempo1=nums[(start+k)%length];</span><br><span class="line">                nums[(start+k)%length]=tempo2;</span><br><span class="line">                tempo2=tempo1;</span><br><span class="line">                start+=k;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i]=tempo2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="除自身以外数组的乘积中等">除自身以外数组的乘积（中等）</h2>
<h3 id="题目描述-2">题目描述</h3>
<p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code>
，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除
<code>nums[i]</code> 之外其余各元素的乘积</em> 。</p>
<p>题目数据 <strong>保证</strong> 数组
<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32
位</strong> 整数范围内。</p>
<p>请<strong>不要使用除法，</strong>且在 <code>O(*n*)</code>
时间复杂度内完成此题。</p>
<h3 id="思路-1">思路</h3>
<p>由于规定了时间复杂度，所以我们得知只能遍历能计算数量次数的数组</p>
<p>先说说lz最开始的思路：用两个数组，用遍历一次分别存储前i位和后i位的乘积，再遍历到最后算某个数的时候，就用前后相乘就可以了，总共两次遍历，大概如下方代码所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans.<span class="built_in">push_back</span>(begin[i<span class="number">-1</span>]*end[length<span class="number">-2</span>-i]);</span><br></pre></td></tr></table></figure>
<p>但是这样时间和内存只打败了不到百分之十的人，于是lz再次思考，两次循环肯定不能省，因为对于某一个元素的前面的乘积和后面的乘积没办法一次算完，应该从内存上下手，可以看到我定义了三个数组，结果ans数组可以不管，begin和end应该是可以省掉的，在计算begin的时候，我是通过从前往后遍历数组，然后算前面的累计乘积，这个顺序和最后算ans的顺序是一样的，所以可以把begin的计算过程放在后面，也就是遍历得到ans的时候，顺便算begin，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin*=nums[i<span class="number">-1</span>];<span class="comment">//begin累计乘</span></span><br><span class="line">ans.<span class="built_in">push_back</span>(begin*end[length<span class="number">-2</span>-i]);</span><br></pre></td></tr></table></figure>
<p>这样的时间复杂度确实下降了，但是不够理想，再次思考能不能把end去了，既然begin可以用累计的方式计算，不用存每一次计算的结果，计算之后就直接用，那end应该也可以！我们知道end是从后往前遍历的，那就让我们的ans再从后往前遍历，乘上end，让end每次都有用，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">end*=nums[i+<span class="number">1</span>];</span><br><span class="line">ans[i]*=end;</span><br></pre></td></tr></table></figure>
<p>最后的时间和空间效果都比较理想</p>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> end=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(length,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                ans[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                begin*=nums[i<span class="number">-1</span>];</span><br><span class="line">                ans[i]=begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=length<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            end*=nums[i+<span class="number">1</span>];</span><br><span class="line">            ans[i]*=end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="缺失的第一个正数困难">缺失的第一个正数（困难）</h2>
<h3 id="题目描述-3">题目描述</h3>
<p>给你一个未排序的整数数组 <code>nums</code>
，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code>
并且只使用常数级别额外空间的解决方案。</p>
<h3 id="思路两种思路">思路（两种思路）</h3>
<h4 id="思路一-2">思路一</h4>
<p>by myself</p>
<ol type="1">
<li>排序</li>
<li>去重</li>
<li>找缺失值</li>
</ol>
<p><strong>这种方法时间复杂度不合要求</strong></p>
<h4 id="代码一-2">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> first=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(first==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]!=<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    first=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]!=<span class="number">1</span>&amp;&amp;nums[i]!=nums[i<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[length<span class="number">-1</span>]+<span class="number">1</span>&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[length<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二-1">思路二</h4>
<p>将原数组进行排序，我们可以根据题目得到，最后要得到的那个数前面的数一定都是排序好了的，所以，可以在原数组上进行排序，但是为了不缺失数据，排序的方式是：将下标作为排序的排名，当然肯定会有些值无法找到对应地点，这种值也不用管，我们只能确认我们要求的那个值前面的值一定都是排序好了的，找到第一个不能正确排序的位置就行了，大概步骤如下：</p>
<ol type="1">
<li>遍历数组，将数组中的值和应该存放的地方进行交换，比如0存的是3，2存的是4，3存的是1（我们是为了找到正数，所以排序就让0存1，1存2）</li>
<li>首先0存的值不是1，把3和下标为3-1=2的位置的值进行交换，0存的就变成4，也不规范，就和4-1=3的下标的值进行交换，最后0存的就变成1了，以此类推</li>
</ol>
<h4 id="代码二-2">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(nums[i]&gt;<span class="number">0</span>&amp;&amp;nums[i]!=i+<span class="number">1</span>&amp;&amp;nums[i]&lt;length&amp;&amp;nums[i]!=nums[nums[i]<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[i],nums[nums[i]<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[length<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树展开为链表中等">二叉树展开为链表(中等)</h2>
<h3 id="题目描述-4">题目描述</h3>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中
<code>right</code> 子指针指向链表中下一个结点，而左子指针始终为
<code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin"><strong>先序遍历</strong></a>
顺序相同。</li>
</ul>
<h3 id="思路两种思路-1">思路（两种思路）</h3>
<h4 id="思路一-3">思路一</h4>
<p>规规矩矩前序遍历，由于要求在原链表上本地操作，前序遍历是先遍历左边，再遍历右边，所以我先把存的值放在左边，最后再统一移到右边</p>
<h4 id="代码一-3">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(); <span class="comment">// 使用括号调用构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans-&gt;left=root;</span><br><span class="line">        ans=ans-&gt;left;</span><br><span class="line">        <span class="built_in">pre</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">pre</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pre</span>(root);</span><br><span class="line">        ans=root;</span><br><span class="line">        <span class="keyword">while</span>(ans)&#123;</span><br><span class="line">            ans-&gt;right=ans-&gt;left;</span><br><span class="line">            ans-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">            ans=ans-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二-2">思路二</h4>
<p>反前序遍历，和前面前序遍历相反，先遍历右边，再遍历左边，记录上次遍历的节点</p>
<h4 id="代码二-3">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* preNode;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = preNode;</span><br><span class="line">        preNode = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最小覆盖字串困难">最小覆盖字串（困难）</h2>
<h3 id="题目描述-5">题目描述</h3>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回
<code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果
<code>s</code> 中不存在涵盖 <code>t</code>
所有字符的子串，则返回空字符串 <code>""</code> 。</p>
<h3 id="思路-2">思路</h3>
<ol type="1">
<li>定义收缩指针i，扩张指针j</li>
<li>首先j往后扩，直到i和j之内的字符串包含了t中所有字符</li>
<li>i往后缩，获得最小的符合标准的字符串</li>
<li>记录长度</li>
<li>i再往后缩一格，重复步骤一，将得到的长度和前面得到的长度进行对比，取最小值</li>
</ol>
<p>重点在于如何判断i和j之内的字符串包含了t中所有字符：我采取的是设置一个哈希表，键是字符，值是字符在t中出现的次数，也就是需要的次数，同时设置needcnt表示还需要几个字符，j每往后移一格，哈希表对应字符就减1，如果增加的字符刚好的需要的字符，needcnt就减一，直到needcnt等于0即代表该段字符串包含所有需要字符，i每往后移一格，哈希表对应字符就加一，同时保证所以字符都不需要，就是都小于0，不等于0是因为保证出现一次，但是尽量不重复</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        ans[<span class="number">1</span>]=INT_MAX;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;hashmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:t)&#123;</span><br><span class="line">            hashmap[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> needcnt=t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>() &amp;&amp; j&lt;s.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>()&amp;&amp;needcnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hashmap[s[j]]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    needcnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                hashmap[s[j]]--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>()&amp;&amp;hashmap[s[i]]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                hashmap[s[i]]++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(needcnt==<span class="number">0</span>&amp;&amp;j-i&lt;ans[<span class="number">1</span>]-ans[<span class="number">0</span>])&#123;</span><br><span class="line">                ans[<span class="number">1</span>]=j;</span><br><span class="line">                ans[<span class="number">0</span>]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[s[i]]++;</span><br><span class="line">            needcnt++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">1</span>]-ans[<span class="number">0</span>]==INT_MAX?<span class="string">&quot;&quot;</span>:s.<span class="built_in">substr</span>(ans[<span class="number">0</span>],ans[<span class="number">1</span>]-ans[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口最大值困难">滑动窗口最大值（困难）</h2>
<h3 id="题目描述-6">题目描述</h3>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code>
的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的
<code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<h3 id="知识点-1">知识点</h3>
<ol type="1">
<li><p>优先队列：</p>
<ul>
<li>升序队列，小根堆：<code>priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; p;</code></li>
<li>降序队列，大根堆：<code>priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;</code></li>
<li>对于基础数据类型，默认是大顶堆：<code>priority_queue&lt;int&gt; r;</code>
//等同于
<code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; r;</code></li>
</ul></li>
<li><p>pair：</p>
<ul>
<li>pair将两个数据（经常为不同数据类型）组合成一组数据。</li>
<li>pair的实现是一个结构体，主要的两个成员变量是first、second。</li>
</ul></li>
<li><p>优先队列+pair：</p>
<ul>
<li><code>priority_queue&lt;pair&lt;int, int&gt; &gt; a;</code>：</li>
<li>pair的比较规则：先比较第一个元素，第一个相等比较第二个。 6 1 1 5 1
2</li>
</ul></li>
<li><p>vector访问最后一个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路三种思路">思路（三种思路）</h3>
<h4 id="思路一暴力求解">思路一：暴力求解</h4>
<p>——会超时</p>
<ol type="1">
<li>每一轮就更新一次最大值下标的位置</li>
<li>在新加入的元素比原最大值下标大的情况直接将最大值下标设为新加入元素位置</li>
</ol>
<h4 id="代码一-4">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length&lt;=k)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>())&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxindex;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length-k+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+k<span class="number">-1</span>&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||(nums[i+k<span class="number">-1</span>]&lt;nums[maxindex]&amp;&amp;maxindex&lt;i))&#123;</span><br><span class="line">                maxindex=i+<span class="built_in">distance</span>(nums.<span class="built_in">begin</span>()+i,<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>()+i,nums.<span class="built_in">begin</span>()+i+k));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i+k<span class="number">-1</span>]&gt;=nums[maxindex])&#123;</span><br><span class="line">                    maxindex=i+k<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i]=nums[maxindex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二优先队列pair">思路二：优先队列+pair</h4>
<p>队列里存数据对，正如前面所言，会根据pair的第一个元素排列，接着是第二个，再每次进入新元素的时候，先将新元素插入，然后取队列的最大值，但是这里要先比较队列的最大值的索引是否已经小于了滑动窗口的最小索引，小于了就去除顶元素，用while</p>
<h4 id="代码二-4">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length-k+<span class="number">1</span>)</span></span>;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;maxindex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            maxindex.<span class="built_in">emplace</span>(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>]=maxindex.<span class="built_in">top</span>().first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;length;i++)&#123;</span><br><span class="line">            maxindex.<span class="built_in">emplace</span>(nums[i],i);</span><br><span class="line">            <span class="keyword">while</span>(!maxindex.<span class="built_in">empty</span>()&amp;&amp;maxindex.<span class="built_in">top</span>().second&lt;=i-k)&#123;</span><br><span class="line">                maxindex.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i-k+<span class="number">1</span>]=maxindex.<span class="built_in">top</span>().first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路三思路二的进阶">思路三：思路二的进阶</h4>
<p>在插入元素的时候比较一下，如果插入的元素比原队列的某些元素大，原队列的某些元素可以永久剔除掉，那些元素没被删时，插入的元素肯定也没被删，但是如果取最大的元素也不可能是那些比插入元素小的数，这里如果只比较对头则效果不好，因为如果都比队头大了那肯定就是最大的了，队列都可以删了，这种情况很少见，所以要比较队尾，这里就要用双端队列，<strong>这里只存下标</strong></p>
<p>这种情况下相当于插在队尾，将队尾比自己小的都删了，这样也相当于手工进行排列，(感觉也可以用vector：经实验不行，vector相当于动态数组，不能很好的删除第一个元素，浪费时间和空间)</p>
<h4 id="代码三">代码三</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; maxindex;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(length-k+<span class="number">1</span>);</span><br><span class="line">        maxindex.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!maxindex.<span class="built_in">empty</span>()&amp;&amp;nums[i]&gt;=nums[maxindex.<span class="built_in">back</span>()])&#123;</span><br><span class="line">                maxindex.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            maxindex.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>]=nums[maxindex.<span class="built_in">front</span>()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!maxindex.<span class="built_in">empty</span>()&amp;&amp;nums[i]&gt;=nums[maxindex.<span class="built_in">back</span>()])&#123;</span><br><span class="line">                maxindex.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            maxindex.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(maxindex.<span class="built_in">front</span>()&lt;=i-k)&#123;</span><br><span class="line">                maxindex.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i-k+<span class="number">1</span>]=nums[maxindex.<span class="built_in">front</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最小栈中等">最小栈（中等）</h2>
<h3 id="题目描述-7">题目描述</h3>
<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code>
操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素val推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<h3 id="知识点-2">知识点</h3>
<ol type="1">
<li><p>栈的定义及基本使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">s.<span class="built_in">empty</span>()               如果栈为空返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line">s.<span class="built_in">size</span>()                返回栈中元素的个数</span><br><span class="line">s.<span class="built_in">pop</span>()                 删除栈顶元素但不返回其值</span><br><span class="line">s.<span class="built_in">top</span>()                 返回栈顶的元素，但不删除该元素</span><br><span class="line">s.<span class="built_in">push</span>()                在栈顶压入新元素</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路两种思路-2">思路(两种思路)</h3>
<h4 id="思路一栈队列">思路一：栈+队列</h4>
<p>用队列来存储当前的最小值，大概思路如下：先加入第一个元素，接着对每个加进来的元素进行判断，如果加进来的元素比队列第一个元素大，那么最小值就不可能返回这个值，就不将其加在队列中，如果比第一个元素小就加在队列中，这样队列的第一个元素一定是最小值，接着如果要对栈顶部元素进行删除，如果栈顶部元素为队列第一个元素，则队列也删除第一个元素就行了，返回最小值永远是队列的第一个元素</p>
<h4 id="代码一-5">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; minnum;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        num.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(minnum.<span class="built_in">empty</span>()||val&lt;=minnum.<span class="built_in">front</span>())minnum.<span class="built_in">push_front</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> topnum=num.<span class="built_in">top</span>();</span><br><span class="line">        num.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(topnum==minnum.<span class="built_in">front</span>())minnum.<span class="built_in">pop_front</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minnum.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二栈">思路二：栈</h4>
<p>栈里面既存元素又存加入该元素后的最小值，只需要在加入元素的时候比较一下，如果加入的元素比上一个元素最小值小就更新</p>
<h4 id="代码二-5">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(&#123;x, x&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(&#123;x, <span class="built_in">min</span>(x, st.<span class="built_in">top</span>().second)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>().first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最大子数组和中等">最大子数组和（中等）</h2>
<h3 id="题目描述-8">题目描述</h3>
<p>给你一个整数数组 <code>nums</code>
，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<h3 id="思路-3">思路</h3>
<p>动态规划：遍历数组，记录到该值时右侧的最大连续数和，就是到前一个数最大连续数和加上该值，如果比该值更大，就记录该和是到该值的最大连续数和，用一个值存所有连续数和的最大值</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxbypreindex=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxnum=maxbypreindex;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            maxbypreindex=<span class="built_in">max</span>(maxbypreindex+nums[i],nums[i]);</span><br><span class="line">            maxnum=<span class="built_in">max</span>(maxbypreindex,maxnum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="下一个排列中等">下一个排列（中等）</h2>
<h3 id="题目描述-9">题目描述</h3>
<p>整数数组的一个 <strong>排列</strong>
就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作
<code>arr</code>
的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code>
。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong>
是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的
<strong>下一个排列</strong>
就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code>
。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是
<code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code>
，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code>
的下一个排列。</p>
<p>必须<strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/原地算法">原地</a></strong>修改，只允许使用额外常数空间。</p>
<h3 id="知识点-3">知识点</h3>
<ol type="1">
<li><p>反转数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reverseArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-4">思路</h3>
<ol type="1">
<li>用两个下标i,j，i从length-1开始往前，j从i前一个开始往前</li>
<li>记录nums[i]&gt;nums[j]最大的j和i</li>
<li>交换两者数字，对后面数字进行排列，即得到结果</li>
<li>由于i就是从最大到最小不用管，找最大的j即可</li>
<li><img src="/post/266d9ac/8c19582d7184ff38afbe6f0a5d06843.jpg" alt="8c19582d7184ff38afbe6f0a5d06843" style="zoom:50%;"></li>
</ol>
<h3 id="代码-3">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;ans[<span class="number">0</span>]||nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;ans[<span class="number">0</span>])&#123;</span><br><span class="line">                        ans[<span class="number">0</span>]=j;</span><br><span class="line">                        ans[<span class="number">1</span>]=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans[<span class="number">0</span>]==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[ans[<span class="number">0</span>]],nums[ans[<span class="number">1</span>]]);</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>()+ans[<span class="number">0</span>]+<span class="number">1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字符串解码中等">字符串解码(中等)</h2>
<h3 id="题目描述-10">题目描述</h3>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的
<code>encoded_string</code> 正好重复 <code>k</code> 次。注意
<code>k</code> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数
<code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code>
的输入。</p>
<h3 id="知识点-4">知识点</h3>
<ol type="1">
<li><p>字符串拼接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;alan&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;xiho&quot;</span>;</span><br><span class="line">string s3 = s1 + s2;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串复制:
假设str1和str2是两个字符串对象，len是子字符串的长度。我们要将字符串str1复制到字符串对象str2中，则语法应类似于:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1.<span class="built_in">copy</span>(str2,len);</span><br><span class="line">str1.<span class="built_in">copy</span>(str2,len,pos);</span><br></pre></td></tr></table></figure>
<p>str2: str2是保留复制的字符串的目标字符串对象。 len:
定义子字符串的长度。 pos: 确定要包含的第一个字符的位置。</p></li>
</ol>
<h3 id="思路-5">思路</h3>
<p>整体还是比较简单，不知道为什么第一次没做出来哈哈哈，过了几天反而又做出来了~</p>
<p>用递归的思路，可以发现对字符串解码过程其实就是一个不断重复地过程，因为对一个字符串解码和对其子字符串解码的步骤都是一样的，用递归就很好的避免了重复步骤</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="type">int</span> length=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        string tempans;</span><br><span class="line">        <span class="type">int</span> judge=<span class="number">0</span>;</span><br><span class="line">        string numStr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;length&amp;&amp;((<span class="built_in">int</span>(s[i])<span class="number">-48</span>&gt;<span class="number">9</span>)||(<span class="built_in">int</span>(s[i])<span class="number">-48</span>&lt;<span class="number">0</span>)))ans.<span class="built_in">push_back</span>(s[i++]);</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">int</span>(s[i])<span class="number">-48</span>&lt;=<span class="number">9</span>)&amp;&amp;(<span class="built_in">int</span>(s[i])<span class="number">-48</span>&gt;=<span class="number">0</span>))&#123;</span><br><span class="line">                numStr.<span class="built_in">clear</span>();</span><br><span class="line">                numStr.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">                <span class="keyword">while</span>((<span class="built_in">int</span>(s[i+<span class="number">1</span>])<span class="number">-48</span>&lt;=<span class="number">9</span>)&amp;&amp;(<span class="built_in">int</span>(s[i+<span class="number">1</span>])<span class="number">-48</span>&gt;=<span class="number">0</span>))numStr.<span class="built_in">push_back</span>(s[++i]);</span><br><span class="line">                n=<span class="built_in">stoi</span>(numStr);</span><br><span class="line">                judge=<span class="number">1</span>;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">                tempans.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">while</span>(i&lt;length&amp;&amp;judge!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)judge++;</span><br><span class="line">                    <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)judge--;</span><br><span class="line">                    <span class="keyword">if</span>(judge!=<span class="number">0</span>)&#123;</span><br><span class="line">                        tempans.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tempans=<span class="built_in">decodeString</span>(tempans);</span><br><span class="line">                <span class="keyword">while</span>(n--)ans+=tempans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最长公共子序列中等">最长公共子序列（中等）</h2>
<h3 id="题目描述-11">题目描述</h3>
<p>给定两个字符串 <code>text1</code> 和
<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong>
的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code>
。</p>
<p>一个字符串的 <strong>子序列</strong>
是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但
<code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong>
是这两个字符串所共同拥有的子序列。</p>
<h3 id="知识点-5">知识点</h3>
<ol type="1">
<li><p>二维vector初始化空间(r行c列)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">newOne</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-6">思路</h3>
<p>二位动态规划，<code>dp[i][j]</code>代表text1前i个和text2前j个的最长公共子序列，首先确认前0个和另一个字符串最长公共子序列都是零，状态转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> text1[i]==text2[j]:</span><br><span class="line">	dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j]+<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="代码-5">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length1=text1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length2=text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxAns=<span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(length1+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(length2+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i]==text2[j])&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                maxAns=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j+<span class="number">1</span>],maxAns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="盛最多水的容器中等">盛最多水的容器(中等)</h2>
<h3 id="题目描述-12">题目描述</h3>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有
<code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是
<code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code>
轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<h3 id="思路-7">思路</h3>
<p>不知道大家对有一道leetcode题还有没有印象，也是盛水，不过是算所有缝隙的水，感觉有异曲同工之妙</p>
<p>思路很简单，就是双指针，如果left指向的高度小于right，left就往这边移，这才可能会遇到会有最大面积的容器，因为事实上我们将left往右移，只是<strong>遗弃了原left和原left+1这一块的体积</strong>，但是本来left指向的高度就小于right，left和left+1组成块的面积肯定小于或者等于left和right</p>
<h3 id="代码-6">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left!=right)&#123;</span><br><span class="line">            maxArea=<span class="built_in">max</span>(maxArea,(right-left)*<span class="built_in">min</span>(height[right],height[left]));</span><br><span class="line">            <span class="keyword">if</span>(height[left]&gt;height[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="实现trie前缀树中等">实现Trie（前缀树）（中等）</h2>
<h3 id="题目描述-13">题目描述</h3>
<p><strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/字典树/9825209?fr=aladdin">Trie</a></strong>（发音类似
"try"）或者说 <strong>前缀树</strong>
是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串
<code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串
<code>word</code> 在前缀树中，返回
<code>true</code>（即，在检索之前已经插入）；否则，返回
<code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code>
如果之前已经插入的字符串 <code>word</code> 的前缀之一为
<code>prefix</code> ，返回 <code>true</code> ；否则，返回
<code>false</code> 。</li>
</ul>
<h3 id="思路-8">思路</h3>
<p>使用链表+哈希，因为哈希查找元素的复杂度为1，以单词前缀作为哈希索引,ifis代表该节点是否真实有值</p>
<h3 id="代码-7">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">char</span> val;</span><br><span class="line">        <span class="type">int</span> ifIS;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="keyword">struct</span> ListNode*&gt;next;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode*head=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        ListNode*copy=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ww:word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(copy-&gt;next.<span class="built_in">find</span>(ww)!=copy-&gt;next.<span class="built_in">end</span>())&#123;</span><br><span class="line">                copy=copy-&gt;next[ww];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode*newnode=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">                newnode-&gt;val=ww;</span><br><span class="line">                newnode-&gt;ifIS=<span class="number">0</span>;</span><br><span class="line">                copy-&gt;next[ww]=newnode;</span><br><span class="line">                copy=newnode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        copy-&gt;ifIS=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        ListNode*copy=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ww:word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(copy-&gt;next.<span class="built_in">find</span>(ww)!=copy-&gt;next.<span class="built_in">end</span>())&#123;</span><br><span class="line">                copy=copy-&gt;next[ww];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(copy-&gt;ifIS==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return true;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        ListNode*copy=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ww:prefix)&#123;</span><br><span class="line">            <span class="keyword">if</span>(copy-&gt;next.<span class="built_in">find</span>(ww)!=copy-&gt;next.<span class="built_in">end</span>())&#123;</span><br><span class="line">                copy=copy-&gt;next[ww];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="杨辉三角简单">杨辉三角（简单）</h2>
<h3 id="题目描述-14">题目描述</h3>
<p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前
<em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<h3 id="思路-9">思路</h3>
<p>用ans1算下一行</p>
<h3 id="代码-8">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans1;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            ans1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;ans.<span class="built_in">back</span>().<span class="built_in">size</span>()<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                ans1.<span class="built_in">push_back</span>(ans.<span class="built_in">back</span>()[j]+ans.<span class="built_in">back</span>()[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(ans1);</span><br><span class="line">            ans1.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="打家劫舍中等">打家劫舍（中等）</h2>
<h3 id="题目描述-15">题目描述</h3>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你
<strong>不触动警报装置的情况下</strong>
，一夜之内能够偷窃到的最高金额。</p>
<h3 id="思路-10">思路</h3>
<p>很简单的动态规划，dp[i]=dp[i]+max[dp[i-2],dp[i-3]……]</p>
<h3 id="代码-9">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxmoney=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                nums[i]+=*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+i<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            maxmoney=<span class="built_in">max</span>(nums[i],maxmoney);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxmoney;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="旋转图像中等">旋转图像(中等)</h2>
<h3 id="题目描述-16">题目描述</h3>
<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code>
表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在<strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/原地算法">原地</a></strong>
旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>
使用另一个矩阵来旋转图像。</p>
<h3 id="思路-11">思路</h3>
<p>找到旋转的规律，其实坐标总体变化是固定的</p>
<h3 id="代码-10">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> temp1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;length-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                temp1=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[length<span class="number">-1</span>-j][i];</span><br><span class="line">                matrix[length<span class="number">-1</span>-j][i]=matrix[length<span class="number">-1</span>-i][length<span class="number">-1</span>-j];</span><br><span class="line">                matrix[length<span class="number">-1</span>-i][length<span class="number">-1</span>-j]=matrix[j][length<span class="number">-1</span>-i];</span><br><span class="line">                matrix[j][length<span class="number">-1</span>-i]=temp1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="和为k的子数组中等">和为k的子数组（中等）</h2>
<h3 id="题目描述-17">题目描述</h3>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>
，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em>
。</p>
<h3 id="思路-12">思路</h3>
<p>暴力解法会超时，只介绍前缀加哈希</p>
<p>首先考虑用一个二维数组保存前i+1个数的和，比如sum[1]表示下标0和下标1的和，sum[100]表示下标0-100的和，接下来遍历数组，比如我们要找下标结尾为j的连续子数组和为k，我们知道sum[j]是多少，只需要找到一个i使得sum[j]-sum[i]为k即可，即sum[i]=sum[j]-k。</p>
<p>优化：哈希找key的复杂度为1，所以考虑用哈希，哈希的键是前缀和，也就是sum，值是前缀和出现的次数，也就是可能前i个数和前j个数的和都是一样的值，这种算连续数组的时候也要算两次，所以需要记录。我们遍历数组的时候是以遍历的下标作为结尾，只考虑该坐标和该坐标前的sum，那么就暂时不需要考虑后面的sum，所以sum的计算和遍历可以同时进行</p>
<h3 id="代码-11">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;preSumMap;</span><br><span class="line">        preSumMap[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> number:nums)&#123;</span><br><span class="line">            pre+=number;</span><br><span class="line">            <span class="keyword">auto</span> it=preSumMap.<span class="built_in">find</span>(pre-k);</span><br><span class="line">            <span class="keyword">if</span>(it!=preSumMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                count+=it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">            preSumMap[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树中第k小的元素中等">二叉搜索树中第K小的元素(中等)</h2>
<h3 id="题目描述-18">题目描述</h3>
<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数
<code>k</code> ，请你设计一个算法查找其中第 <code>k</code>
个最小元素（从 1 开始计数）。</p>
<h3 id="思路-13">思路</h3>
<h4 id="思路一优先队列暴力求解">思路一：优先队列暴力求解</h4>
<p>用dfs遍历二叉树，存在优先队列中，再取第k个最小的数</p>
<h4 id="代码一-6">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; p;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.<span class="built_in">emplace</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(--k)&#123;</span><br><span class="line">            p.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二利用二叉搜索树的性质">思路二：利用二叉搜索树的性质</h4>
<p>二叉搜索树中序遍历即升序排列，利用该性质可方便求解</p>
<h4 id="代码二-6">代码二：</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> km;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>||km==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(--km==<span class="number">0</span>)&#123;</span><br><span class="line">            ans=root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        km=k;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="搜索插入位置简单">搜索插入位置（简单）</h2>
<h3 id="题目描述-19">题目描述</h3>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<h3 id="思路-14">思路</h3>
<p>很明显使用二分查找</p>
<h3 id="代码-12">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            mid=(right+left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]&lt;target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="划分字母区间中等待做">划分字母区间（中等）(待做)</h2>
<h3 id="题目描述-20">题目描述</h3>
<p>给你一个字符串 <code>s</code>
。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是
<code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </span><br></pre></td></tr></table></figure>
<h3 id="知识点-6">知识点</h3>
<ol type="1">
<li><p>哈希倒序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = hashMap.<span class="built_in">rbegin</span>(); it != hashMap.<span class="built_in">rend</span>(); ++it) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>leetcode100题_2</p><p><a href="http://example.com/post/266d9ac.html">http://example.com/post/266d9ac.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>yyyyyyxnp</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2023-08-07</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-10-08</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/c/">c</a><a class="link-muted mr-2" rel="tag" href="/tags/c/">c++</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>Afdian.net</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/7561e93a.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">leetcode100题_3</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/b4fd5249.html"><span class="level-item">菜鸟的ctf之旅(ctfhub技能树)</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Yyyyyyxnp"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yyyyyyxnp</p><p class="is-size-6 is-block">Student Yang</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Fudan University</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">48</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/deng12yx" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/deng12yx"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#多数元素简单"><span class="level-left"><span class="level-item">1</span><span class="level-item">多数元素（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路两个思路"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">思路（两个思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">思路一</span></span></a></li><li><a class="level is-mobile" href="#代码一"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二boyer-moore-投票算法"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">思路二：Boyer-Moore 投票算法</span></span></a></li><li><a class="level is-mobile" href="#代码二"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#轮转数组中等"><span class="level-left"><span class="level-item">2</span><span class="level-item">轮转数组（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">思路</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一-1"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">思路一</span></span></a></li><li><a class="level is-mobile" href="#代码一-1"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">思路二</span></span></a></li><li><a class="level is-mobile" href="#代码二-1"><span class="level-left"><span class="level-item">2.2.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#除自身以外数组的乘积中等"><span class="level-left"><span class="level-item">3</span><span class="level-item">除自身以外数组的乘积（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-2"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-1"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#缺失的第一个正数困难"><span class="level-left"><span class="level-item">4</span><span class="level-item">缺失的第一个正数（困难）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-3"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">思路（两种思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一-2"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">思路一</span></span></a></li><li><a class="level is-mobile" href="#代码一-2"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二-1"><span class="level-left"><span class="level-item">4.2.3</span><span class="level-item">思路二</span></span></a></li><li><a class="level is-mobile" href="#代码二-2"><span class="level-left"><span class="level-item">4.2.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#二叉树展开为链表中等"><span class="level-left"><span class="level-item">5</span><span class="level-item">二叉树展开为链表(中等)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-4"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路-1"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">思路（两种思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一-3"><span class="level-left"><span class="level-item">5.2.1</span><span class="level-item">思路一</span></span></a></li><li><a class="level is-mobile" href="#代码一-3"><span class="level-left"><span class="level-item">5.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二-2"><span class="level-left"><span class="level-item">5.2.3</span><span class="level-item">思路二</span></span></a></li><li><a class="level is-mobile" href="#代码二-3"><span class="level-left"><span class="level-item">5.2.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#最小覆盖字串困难"><span class="level-left"><span class="level-item">6</span><span class="level-item">最小覆盖字串（困难）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-5"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-2"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-1"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#滑动窗口最大值困难"><span class="level-left"><span class="level-item">7</span><span class="level-item">滑动窗口最大值（困难）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-6"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-1"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路三种思路"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">思路（三种思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一暴力求解"><span class="level-left"><span class="level-item">7.3.1</span><span class="level-item">思路一：暴力求解</span></span></a></li><li><a class="level is-mobile" href="#代码一-4"><span class="level-left"><span class="level-item">7.3.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二优先队列pair"><span class="level-left"><span class="level-item">7.3.3</span><span class="level-item">思路二：优先队列+pair</span></span></a></li><li><a class="level is-mobile" href="#代码二-4"><span class="level-left"><span class="level-item">7.3.4</span><span class="level-item">代码二</span></span></a></li><li><a class="level is-mobile" href="#思路三思路二的进阶"><span class="level-left"><span class="level-item">7.3.5</span><span class="level-item">思路三：思路二的进阶</span></span></a></li><li><a class="level is-mobile" href="#代码三"><span class="level-left"><span class="level-item">7.3.6</span><span class="level-item">代码三</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#最小栈中等"><span class="level-left"><span class="level-item">8</span><span class="level-item">最小栈（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-7"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-2"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路-2"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">思路(两种思路)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一栈队列"><span class="level-left"><span class="level-item">8.3.1</span><span class="level-item">思路一：栈+队列</span></span></a></li><li><a class="level is-mobile" href="#代码一-5"><span class="level-left"><span class="level-item">8.3.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二栈"><span class="level-left"><span class="level-item">8.3.3</span><span class="level-item">思路二：栈</span></span></a></li><li><a class="level is-mobile" href="#代码二-5"><span class="level-left"><span class="level-item">8.3.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#最大子数组和中等"><span class="level-left"><span class="level-item">9</span><span class="level-item">最大子数组和（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-8"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-3"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-2"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#下一个排列中等"><span class="level-left"><span class="level-item">10</span><span class="level-item">下一个排列（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-9"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-3"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-4"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-3"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#字符串解码中等"><span class="level-left"><span class="level-item">11</span><span class="level-item">字符串解码(中等)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-10"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-4"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-5"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-4"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#最长公共子序列中等"><span class="level-left"><span class="level-item">12</span><span class="level-item">最长公共子序列（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-11"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-5"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-6"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-5"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#盛最多水的容器中等"><span class="level-left"><span class="level-item">13</span><span class="level-item">盛最多水的容器(中等)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-12"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-7"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-6"><span class="level-left"><span class="level-item">13.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#实现trie前缀树中等"><span class="level-left"><span class="level-item">14</span><span class="level-item">实现Trie（前缀树）（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-13"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-8"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-7"><span class="level-left"><span class="level-item">14.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#杨辉三角简单"><span class="level-left"><span class="level-item">15</span><span class="level-item">杨辉三角（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-14"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-9"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-8"><span class="level-left"><span class="level-item">15.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#打家劫舍中等"><span class="level-left"><span class="level-item">16</span><span class="level-item">打家劫舍（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-15"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-10"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-9"><span class="level-left"><span class="level-item">16.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#旋转图像中等"><span class="level-left"><span class="level-item">17</span><span class="level-item">旋转图像(中等)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-16"><span class="level-left"><span class="level-item">17.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-11"><span class="level-left"><span class="level-item">17.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-10"><span class="level-left"><span class="level-item">17.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#和为k的子数组中等"><span class="level-left"><span class="level-item">18</span><span class="level-item">和为k的子数组（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-17"><span class="level-left"><span class="level-item">18.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-12"><span class="level-left"><span class="level-item">18.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-11"><span class="level-left"><span class="level-item">18.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二叉搜索树中第k小的元素中等"><span class="level-left"><span class="level-item">19</span><span class="level-item">二叉搜索树中第K小的元素(中等)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-18"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-13"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">思路</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一优先队列暴力求解"><span class="level-left"><span class="level-item">19.2.1</span><span class="level-item">思路一：优先队列暴力求解</span></span></a></li><li><a class="level is-mobile" href="#代码一-6"><span class="level-left"><span class="level-item">19.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二利用二叉搜索树的性质"><span class="level-left"><span class="level-item">19.2.3</span><span class="level-item">思路二：利用二叉搜索树的性质</span></span></a></li><li><a class="level is-mobile" href="#代码二-6"><span class="level-left"><span class="level-item">19.2.4</span><span class="level-item">代码二：</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#搜索插入位置简单"><span class="level-left"><span class="level-item">20</span><span class="level-item">搜索插入位置（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-19"><span class="level-left"><span class="level-item">20.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-14"><span class="level-left"><span class="level-item">20.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-12"><span class="level-left"><span class="level-item">20.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#划分字母区间中等待做"><span class="level-left"><span class="level-item">21</span><span class="level-item">划分字母区间（中等）(待做)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-20"><span class="level-left"><span class="level-item">21.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-6"><span class="level-left"><span class="level-item">21.2</span><span class="level-item">知识点</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-01T13:27:46.000Z">2025-09-01</time></p><p class="title"><a href="/post/faa1c95e.html">ctfshow初学</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/b64de532.html"><img src="/img/article/23.png" alt="ai_tools"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-25T05:34:16.000Z">2024-12-25</time></p><p class="title"><a href="/post/b64de532.html">ai_tools</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/d75064c8.html"><img src="/img/article/18.png" alt="基础知识学习"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-10-09T11:54:53.000Z">2024-10-09</time></p><p class="title"><a href="/post/d75064c8.html">基础知识学习</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/9c1a1a1.html"><img src="/img/article/17.png" alt="luogu_1"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-10-08T10:50:27.000Z">2024-10-08</time></p><p class="title"><a href="/post/9c1a1a1.html">luogu_1</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/7684f23b.html"><img src="/img/article/15.png" alt="T2I"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-23T06:17:27.000Z">2024-09-23</time></p><p class="title"><a href="/post/7684f23b.html">T2I</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">BeautyFlower</a><p class="is-size-7"><span>&copy; 2025 yyyyyyxnp</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/deng12yx"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'folded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>