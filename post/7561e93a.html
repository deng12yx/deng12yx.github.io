<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>leetcode100题_3 - BeautyFlower</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Icaurs - Hexo Theme"><meta name="msapplication-TileImage" content="icons/touch-icon-iphone.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Icaurs - Hexo Theme"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="icons/touch-icon-iphone.png"><link rel="apple-touch-icon" sizes="152x152" href="icons/touch-icon-ipad.png"><link rel="apple-touch-icon" sizes="72x72" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="96x96" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="128x128" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="256x256" href="icon/logo.ico"><meta name="description" content="2023.08.28：原来才刷六十道，假期一百道leetcode宣告失败！"><meta property="og:type" content="blog"><meta property="og:title" content="leetcode100题_3"><meta property="og:url" content="http://example.com/post/7561e93a.html"><meta property="og:site_name" content="BeautyFlower"><meta property="og:description" content="2023.08.28：原来才刷六十道，假期一百道leetcode宣告失败！"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/article/20.png"><meta property="article:published_time" content="2023-08-18T08:04:05.000Z"><meta property="article:modified_time" content="2024-10-08T10:56:27.250Z"><meta property="article:author" content="yyyyyyxnp"><meta property="article:tag" content="c"><meta property="article:tag" content="c++"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/article/20.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/post/7561e93a.html"},"headline":"leetcode100题_3","image":["http://example.com/img/article/20.png"],"datePublished":"2023-08-18T08:04:05.000Z","dateModified":"2024-10-08T10:56:27.250Z","author":{"@type":"Person","name":"yyyyyyxnp"},"publisher":{"@type":"Organization","name":"BeautyFlower","logo":{"@type":"ImageObject","url":{"text":"BeautyFlower"}}},"description":"2023.08.28：原来才刷六十道，假期一百道leetcode宣告失败！"}</script><link rel="canonical" href="http://example.com/post/7561e93a.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="BeautyFlower" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">BeautyFlower</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/deng12yx"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/article/20.png" alt="leetcode100题_3"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-18T08:04:05.000Z" title="2023/8/18 16:04:05">2023-08-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-08T10:56:27.250Z" title="2024/10/8 18:56:27">2024-10-08</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="level-item">40 minutes read (About 6052 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">leetcode100题_3</h1><div class="content"><p>2023.08.28：原来才刷六十道，假期一百道leetcode宣告失败！</p>
<span id="more"></span>
<h2 id="复制带随机指针的链表中等">复制带随机指针的链表（中等）</h2>
<h3 id="题目描述">题目描述</h3>
<p>给你一个长度为 <code>n</code>
的链表，每个节点包含一个额外增加的随机指针 <code>random</code>
，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin">深拷贝</a></strong>。
深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong>
节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的
<code>next</code> 指针和 <code>random</code>
指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong>
。</p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中
<code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点
<code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code>
。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 <code>n</code>
个节点组成的链表来表示输入/输出中的链表。每个节点用一个
<code>[val, random_index]</code> 表示：</p>
<ul>
<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>
<li><code>random_index</code>：随机指针指向的节点索引（范围从
<code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为
<code>null</code> 。</li>
</ul>
<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code>
作为传入参数。</p>
<h3 id="思路两种思路">思路（两种思路）</h3>
<h4 id="思路一根据next新建节点">思路一：根据next新建节点</h4>
<p>遍历原链表，深复制每个节点并附上索引，此处先不管random，再次遍历原链表，获取原链表random节点在原链表的索引，再确定目标链表的对应索引位置</p>
<p>该方法的时间复杂度为o(n^2)</p>
<h4 id="代码一">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(Node*root,Node*randomNode)</span></span>&#123;</span><br><span class="line">        Node*copy=root;</span><br><span class="line">        <span class="type">int</span> indexNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(copy)&#123;</span><br><span class="line">            <span class="keyword">if</span>(copy==randomNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> indexNum;</span><br><span class="line">            &#125;</span><br><span class="line">            indexNum++;</span><br><span class="line">            copy=copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        Node* head2=<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line">        Node* copy2=head2;</span><br><span class="line">        <span class="type">int</span> indecNum;</span><br><span class="line">        Node* copy=head;</span><br><span class="line">        vector&lt;Node*&gt;sourceNode;</span><br><span class="line">        <span class="keyword">while</span>(copy)&#123;</span><br><span class="line">            Node* newNode=<span class="keyword">new</span> <span class="built_in">Node</span>(copy-&gt;val);</span><br><span class="line">            head2-&gt;next=newNode;</span><br><span class="line">            head2=head2-&gt;next;</span><br><span class="line">            sourceNode.<span class="built_in">push_back</span>(newNode);</span><br><span class="line">            copy=copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head2-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        head2=copy2-&gt;next;</span><br><span class="line">        copy2=head2;</span><br><span class="line">        copy=head;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;random==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                head2-&gt;random=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                indecNum=<span class="built_in">index</span>(copy,head-&gt;random);</span><br><span class="line">                head2-&gt;random=sourceNode[indecNum];</span><br><span class="line">            &#125;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            head2=head2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二根绝random和next新建节点回溯递归">思路二：根绝random和next新建节点，回溯递归</h4>
<p>建立一个哈希表，哈希表存的是原节点和对应节点，如果原节点还没有建立好对应节点，就新建对应节点，然后再新建next和random</p>
<h4 id="代码二">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; cachedNode;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cachedNode.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">            Node* headNew = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">            cachedNode[head] = headNew;</span><br><span class="line">            headNew-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">            headNew-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cachedNode[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="编辑距离困难">编辑距离（困难）</h2>
<h3 id="题目描述-1">题目描述</h3>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将
<code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em>
。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<h3 id="思路">思路</h3>
<p>（好难/(ㄒoㄒ)/~~）</p>
<p>动态规划：</p>
<ul>
<li><code>dp[i][j]</code>表示word1的前i个要转换为word2的前j个需要的最短步长，比如<code>df[0][0]</code>表示word1的前0个字符转换为word2的前0个字符所需要的步长，就是0，<code>df[2][0]</code>表示word1的前两个字符转换为word2的前两个字符所需的最短步长，即2，就是删除两个字符才能变成长度为0的字符，所以可以对<code>df[0-length1][0]</code>和<code>df[0][0-length2]</code>进行初始化</li>
<li>然后就是动态方程的设置，<code>df[i][j]</code>在word1的第i个字符等于word2的第j个字符的时候肯定直接是<code>df[i-1][j-1]+1</code>,不用做什么操作，因为本来就相同了，如果不等就可以考虑题目所说的三种操作：
<ul>
<li>第一种是在让前i-1个字符变成前j-1个字符的前提下进行替换</li>
<li>第二种是在让前i-1个字符变成前j个字符的前提下进行删除第i个字符的操作</li>
<li>第三种就是在让前i个字符变成前j-1个字符的前提下进行增加第j个字符的操作（注意，这里的i和j针对两个不同的字符串）</li>
<li>最后取这三者的最小值</li>
</ul></li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length1=word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length2=word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">df</span>(length1+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(length2+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=length1;i++)&#123;</span><br><span class="line">            df[i][<span class="number">0</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=length2;i++)&#123;</span><br><span class="line">            df[<span class="number">0</span>][i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i]==word2[j])df[i+<span class="number">1</span>][j+<span class="number">1</span>]=df[i][j];</span><br><span class="line">                <span class="keyword">else</span> df[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="built_in">min</span>(df[i][j+<span class="number">1</span>],<span class="built_in">min</span>(df[i+<span class="number">1</span>][j],df[i][j]))+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> df[length1][length2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="路径总和中等">路径总和（中等）</h2>
<h3 id="题目描述-2">题目描述</h3>
<p>给定一个二叉树的根节点 <code>root</code> ，和一个整数
<code>targetSum</code> ，求该二叉树里节点值之和等于
<code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong>
不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<h3 id="思路-1">思路</h3>
<p>前缀和+哈希（好歹是我自己想出来的/(ㄒoㄒ)/~~）</p>
<p>保存每个节点的前缀和，连续节点的和可以用两个节点的前缀和相减得到结果，为了避免遍历，用哈希保存前缀和结果，用find方便查找答案</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfsPath</span><span class="params">(<span class="type">long</span> <span class="type">long</span> allSum,TreeNode*&amp;root,<span class="type">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        allSum+=root-&gt;val;</span><br><span class="line">        <span class="keyword">auto</span> it=path.<span class="built_in">find</span>(allSum-targetSum);</span><br><span class="line">        <span class="keyword">if</span>(it!=path.<span class="built_in">end</span>())&#123;</span><br><span class="line">            count+=it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        path[allSum]++;</span><br><span class="line">        <span class="built_in">dfsPath</span>(allSum,root-&gt;left,targetSum);</span><br><span class="line">        <span class="built_in">dfsPath</span>(allSum,root-&gt;right,targetSum);</span><br><span class="line">        path[allSum]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        path[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> allSum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfsPath</span>(allSum,root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="只出现一次的数字简单">只出现一次的数字（简单）</h2>
<h3 id="题目描述-3">题目描述</h3>
<p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code>
，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<h3 id="知识点">知识点</h3>
<ol type="1">
<li><p>异或：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a^a</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路两种思路-1">思路（两种思路）</h3>
<h4 id="思路一哈希">思路一：哈希</h4>
<p>时间空间复杂度均为o(n)，用哈希存下每个元素出现的次数，超过两次就删除这个元素，最后返回剩下的元素</p>
<h4 id="代码一-1">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hashMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> number : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(++hashMap[number]==<span class="number">2</span>)&#123;</span><br><span class="line">                hashMap.<span class="built_in">erase</span>(number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashMap.<span class="built_in">begin</span>()-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二异或">思路二：异或</h4>
<p>异或满足交换律，且相同元素异或为0，任意元素异或0为原值</p>
<h4 id="代码二-1">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            nums[<span class="number">0</span>]^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="零钱兑换中等">零钱兑换（中等）</h2>
<h3 id="题目描述-4">题目描述</h3>
<p>给你一个整数数组 <code>coins</code>
，表示不同面额的硬币；以及一个整数 <code>amount</code>
，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong>
。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<h3 id="思路两种思路-2">思路（两种思路）</h3>
<h4 id="思路一dfs">思路一：dfs</h4>
<p><strong>会超时</strong>（刷了快一个月题还是只会暴力求解/(ㄒoㄒ)/~~）</p>
<p>用递归得到能组成余额的最小值</p>
<h4 id="代码一-2">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> min_size=<span class="number">10000</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">coinMinSize</span><span class="params">(priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; remainedMoney,<span class="type">int</span> remainedamount,<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&gt;=min_size)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> money=remainedMoney.<span class="built_in">top</span>();</span><br><span class="line">        <span class="type">int</span> iter=remainedamount/money;</span><br><span class="line">        remainedMoney.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(remainedMoney.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(remainedamount%money==<span class="number">0</span>)&#123;</span><br><span class="line">                min_size=<span class="built_in">min</span>(min_size,number+iter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=iter;i++)&#123;</span><br><span class="line">            number+=i;</span><br><span class="line">            <span class="built_in">coinMinSize</span>(remainedMoney,remainedamount-i*money,number);</span><br><span class="line">            number-=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt;remainedMoney;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin:coins)&#123;</span><br><span class="line">            remainedMoney.<span class="built_in">push</span>(coin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">coinMinSize</span>(remainedMoney,amount,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(min_size==<span class="number">10000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> min_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二动态规划">思路二：动态规划</h4>
<p>dp[i]表示要组成金额为i的硬币需要的最小数量，我们知道硬币一定是从coins里面选一个，因为硬币最后一个肯定也是从coins里面选，那么去掉最后一个的金额需要硬币的数量一定是原本数量-1，因为我们只去掉了最后一个，所以问题就变成了怎么求去掉最后一个的金额的需要的硬币的数量，所以有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i]=<span class="built_in">min</span>(dp[i-coin1],dp[i-coin2],dp[i-coin3]……)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>coin代表所拥有的硬币种类，按照该公式对数组进行更新即可</p>
<h4 id="代码二-2">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(amount+<span class="number">1</span>,<span class="number">10001</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> coin:coins)</span><br><span class="line">                <span class="keyword">if</span>(i-coin&gt;=<span class="number">0</span>)dp[i]=<span class="built_in">min</span>(dp[i-coin]+<span class="number">1</span>,dp[i]);</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==<span class="number">10001</span>?<span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="柱状图中最大的矩形困难"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a>(困难)</h2>
<h3 id="题目描述-5">题目描述</h3>
<p>给定 <em>n</em>
个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1
。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>示例 1:</strong></p>
<figure>
<img src="/post/7561e93a/histogram.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure>
<h3 id="思路两种思路-3">思路（两种思路）</h3>
<h4 id="思路一模仿接雨水的按行求">思路一：模仿接雨水的按行求</h4>
<p><strong>会超时</strong></p>
<p>（srds这是lz自己的思路，竟然超时了/(ㄒoㄒ)/~~）</p>
<p>求每一行能达到的最大面积，从下往上遍历，获取高度在一定范围的下标</p>
<h4 id="代码一-3">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;index1;</span><br><span class="line">        <span class="type">int</span> i=*<span class="built_in">min_element</span>(heights.<span class="built_in">begin</span>(),heights.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> length=heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            index1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;index2;</span><br><span class="line">        <span class="type">int</span> use_length=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> used_length=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max_area=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index1.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*index1.<span class="built_in">size</span>()&lt;=max_area)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            use_length=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;index1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                used_length=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;index1.<span class="built_in">size</span>()&amp;&amp;heights[index1[j]]&gt;=i)&#123;</span><br><span class="line">                    used_length++;</span><br><span class="line">                    index2.<span class="built_in">push_back</span>(index1[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;(index1.<span class="built_in">size</span>()<span class="number">-1</span>)&amp;&amp;(index1[j+<span class="number">1</span>]==index1[j]+<span class="number">1</span>)&amp;&amp;(heights[index1[j+<span class="number">1</span>]]&gt;=i))&#123;</span><br><span class="line">                    used_length++;</span><br><span class="line">                    index2.<span class="built_in">push_back</span>(index1[j]+<span class="number">1</span>);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                use_length=<span class="built_in">max</span>(use_length,used_length);</span><br><span class="line">            &#125;</span><br><span class="line">            max_area=<span class="built_in">max</span>(max_area,use_length*i);</span><br><span class="line">            i++;</span><br><span class="line">            index1=<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(index2.<span class="built_in">begin</span>(),index2.<span class="built_in">end</span>());</span><br><span class="line">            index2.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二运用栈">思路二：运用栈</h4>
<p>借鉴了大佬根据栈做的代码</p>
<p>思路有点长直接附上大佬讲解链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/142012/bao-li-jie-fa-zhan-by-liweiwei1419/?envType=study-plan-v2&amp;envId=top-100-liked">84.
柱状图中最大的矩形 - 力扣（LeetCode）</a></p>
<h4 id="代码二-3">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;index;</span><br><span class="line">        <span class="type">int</span> max_area=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!index.<span class="built_in">empty</span>()&amp;&amp;heights[i]&lt;heights[index.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                top=index.<span class="built_in">top</span>();</span><br><span class="line">                index.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(index.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    max_area=<span class="built_in">max</span>(max_area,(i*heights[top]));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    max_area=<span class="built_in">max</span>(max_area,(i-index.<span class="built_in">top</span>()<span class="number">-1</span>)*heights[top]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pre_index;</span><br><span class="line">        <span class="type">int</span> now_index=index.<span class="built_in">top</span>();</span><br><span class="line">        <span class="type">int</span> later_index=now_index+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!index.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            index.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(index.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                max_area=<span class="built_in">max</span>(max_area,heights[now_index]*length);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre_index=index.<span class="built_in">top</span>();</span><br><span class="line">                max_area=<span class="built_in">max</span>(max_area,(later_index-pre_index<span class="number">-1</span>)*heights[now_index]);</span><br><span class="line">            &#125;</span><br><span class="line">            now_index=pre_index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="删除链表的倒数第-n-个结点中等"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第
N 个结点</a>（中等）</h2>
<h3 id="题目描述-6">题目描述</h3>
<p>给你一个链表，删除链表的倒数第 <code>n</code>
个结点，并且返回链表的头结点。</p>
<h3 id="思路双指针">思路：双指针</h3>
<p>（终于没有超时了啊啊啊！！！！）</p>
<p>设置双指针，题目提示一次遍历，那怎么一次遍历就可以得到倒数节点呢，那就是双指针！，我们知道倒数节点和最后一个节点之间的距离，那最开始就设好两个开始遍历的点，点之间的距离就是倒数的数目，直到靠后的那个节点到达了尾节点，就可以得到我们要删除的节点，一次遍历就可以成功解决</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode*pre=head;</span><br><span class="line">        ListNode*later=head;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            later=later-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(later==<span class="literal">NULL</span>)<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(later-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            later=later-&gt;next;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next=pre-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="搜索二维矩阵中等">搜索二维矩阵（中等）</h2>
<h3 id="题目描述-7">题目描述</h3>
<p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非递减顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code>
在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/7561e93a/mat.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="思路两种思路-4">思路（两种思路）</h3>
<h4 id="思路一暴力遍历">思路一：暴力遍历</h4>
<p>直接一个元素一个元素比较</p>
<h4 id="代码一-4">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> its:matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> it : its)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target==it)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二两次二分">思路二：两次二分</h4>
<p>进行行和列的二分查找</p>
<h4 id="代码二-4">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> row = <span class="built_in">upper_bound</span>(matrix.<span class="built_in">begin</span>(), matrix.<span class="built_in">end</span>(), target, [](<span class="type">const</span> <span class="type">int</span> b, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> b &lt; a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (row == matrix.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --row;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">binary_search</span>(row-&gt;<span class="built_in">begin</span>(), row-&gt;<span class="built_in">end</span>(), target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="回文链表简单">回文链表（简单）</h2>
<h3 id="题目描述-8">题目描述</h3>
<p>给你一个单链表的头节点 <code>head</code>
，请你判断该链表是否为回文链表。如果是，返回 <code>true</code>
；否则，返回 <code>false</code> 。</p>
<h3 id="思路两种思路-5">思路（两种思路）</h3>
<h4 id="思路一借助栈">思路一：借助栈</h4>
<p>首先在栈中存一半，另一半进栈是直接对比即可，相同就出栈，不同就说明不是回文链表</p>
<h4 id="代码一-5">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line">        ListNode*copy=head;</span><br><span class="line">        <span class="keyword">while</span>(copy)&#123;</span><br><span class="line">            copy=copy-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        copy=head;</span><br><span class="line">        <span class="type">int</span> half_length=length%<span class="number">2</span>;</span><br><span class="line">        length/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(length--)&#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(copy-&gt;val);</span><br><span class="line">            copy=copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(half_length!=<span class="number">0</span>)copy=copy-&gt;next;</span><br><span class="line">        <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(copy)&#123;</span><br><span class="line">            top=stk.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(top!=copy-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            copy=copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二反转一半">思路二：反转一半</h4>
<p>首先获取链表长度，然后反转后一半，我们可以确定的是对于回文链表另一半反转之后应该和前一半一样（有可能多一个元素，不过前面的值肯定是相同的）</p>
<h4 id="代码二-5">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">revearse</span><span class="params">(ListNode*copy)</span></span>&#123;</span><br><span class="line">        ListNode *s=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode *p=copy;</span><br><span class="line">        ListNode *q;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            q=p-&gt;next;</span><br><span class="line">            p-&gt;next=s;</span><br><span class="line">            s=p;</span><br><span class="line">            p=q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode*copy=head;</span><br><span class="line">        <span class="keyword">while</span>(copy)&#123;</span><br><span class="line">            copy=copy-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        copy=head;</span><br><span class="line">        length/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(length--)&#123;</span><br><span class="line">            copy=copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        copy=<span class="built_in">revearse</span>(copy);</span><br><span class="line">        <span class="keyword">while</span>(copy&amp;&amp;head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(copy-&gt;val!=head-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            copy=copy-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="寻找两个正序数组的中位数困难">寻找两个正序数组的中位数（困难）</h2>
<h3 id="题目描述-9">题目描述</h3>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code>
的正序（从小到大）数组 <code>nums1</code> 和
<code>nums2</code>。请你找出并返回这两个正序数组的
<strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<h3 id="思路-2">思路</h3>
<p>借鉴了大佬的思路，整体想法是找第k小的位置，比如数组一有n个数，数组二有m个数，如果要找第k小的数，那么这个比k小的数前面就会有k-1个比它小的数，这k-1个数肯定存在于两个数组中，由于两个数组都是增序，如果两个数组比k小的数相等，那么都是k-1/2，如果不相等，肯定有个数组比k小的数小于了k-1/2，这就会导致该数组k-1/2位置的数会比第k小的数字大，同时也可以确认，另一个数组比k小的数大于了k-1/2，那么就会导致k-1/2位置的数肯定会比第k小的数字更小，就可以将该数组的该数字及之前的数字都去掉，那么我们就从找第k个数变成了找第k-((k-1)/2)小的数，因为前面的更小的都被删掉了，最后的终止条件就是找第1小的数字，直接进行比较即可</p>
<p><strong>ps</strong>：该方法有很多需要特殊考虑的地方，比如一个数组为空，数组长度不够(k-1)/2等等，需要不断调试，不断运行才能写出正确的代码，lz光提交就提交了十五次/(ㄒoㄒ)/~~</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length1=nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length2=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> status=(length1+length2)%<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> k=(length1+length2)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(status)k+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((length1+length2)==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(length1)<span class="keyword">return</span> nums1[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> nums2[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> half_k;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            half_k=k/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums1.<span class="built_in">size</span>()&lt;half_k||(half_k==<span class="number">0</span>&amp;&amp;nums1.<span class="built_in">size</span>()==<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums1[nums1.<span class="built_in">size</span>()<span class="number">-1</span>]&gt;nums2[half_k<span class="number">-1</span>])&#123;</span><br><span class="line">                        nums2.<span class="built_in">assign</span>(nums2.<span class="built_in">begin</span>()+half_k,nums2.<span class="built_in">end</span>());</span><br><span class="line">                        k-=half_k;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        k-=nums1.<span class="built_in">size</span>();</span><br><span class="line">                        <span class="keyword">if</span>(status)<span class="keyword">return</span> nums2[k<span class="number">-1</span>];</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">double</span>(nums2[k<span class="number">-1</span>]+nums2[k])/<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    k-=nums1.<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">if</span>(status)<span class="keyword">return</span> nums2[k<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">double</span>(nums2[k<span class="number">-1</span>]+nums2[k])/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums2.<span class="built_in">size</span>()&lt;half_k||(half_k==<span class="number">0</span>&amp;&amp;nums2.<span class="built_in">size</span>()==<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums2.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums2[nums2.<span class="built_in">size</span>()<span class="number">-1</span>]&gt;nums1[half_k<span class="number">-1</span>])&#123;</span><br><span class="line">                        nums1.<span class="built_in">assign</span>(nums1.<span class="built_in">begin</span>()+half_k,nums1.<span class="built_in">end</span>());</span><br><span class="line">                        k-=half_k;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        k-=nums2.<span class="built_in">size</span>();</span><br><span class="line">                        <span class="keyword">if</span>(status)<span class="keyword">return</span> nums1[k<span class="number">-1</span>];</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">double</span>(nums1[k<span class="number">-1</span>]+nums1[k])/<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    k-=nums2.<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">if</span>(status)<span class="keyword">return</span> nums1[k<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">double</span>(nums1[k<span class="number">-1</span>]+nums1[k])/<span class="number">2</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(half_k!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[half_k<span class="number">-1</span>]&lt;nums2[half_k<span class="number">-1</span>])&#123;</span><br><span class="line">                    nums1.<span class="built_in">assign</span>(nums1.<span class="built_in">begin</span>()+half_k,nums1.<span class="built_in">end</span>());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    nums2.<span class="built_in">assign</span>(nums2.<span class="built_in">begin</span>()+half_k,nums2.<span class="built_in">end</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                k-=half_k; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(status)<span class="keyword">return</span> nums2[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">double</span>(nums2[<span class="number">0</span>]+nums2[<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums2.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(status)<span class="keyword">return</span> nums1[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">double</span>(nums1[<span class="number">0</span>]+nums1[<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(status)<span class="keyword">return</span> <span class="built_in">min</span>(nums1[<span class="number">0</span>],nums2[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span>(nums1[<span class="number">0</span>]==nums2[<span class="number">0</span>])<span class="keyword">return</span> <span class="built_in">double</span>(nums1[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span>(nums1[<span class="number">0</span>]&lt;nums2[<span class="number">0</span>]&amp;&amp;nums1.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)<span class="keyword">return</span> <span class="built_in">double</span>(nums1[<span class="number">0</span>]+<span class="built_in">min</span>(nums1[<span class="number">1</span>],nums2[<span class="number">0</span>]))/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums2[<span class="number">0</span>]&lt;nums1[<span class="number">0</span>]&amp;&amp;nums2.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)<span class="keyword">return</span> <span class="built_in">double</span>(nums2[<span class="number">0</span>]+<span class="built_in">min</span>(nums2[<span class="number">1</span>],nums1[<span class="number">0</span>]))/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">double</span>(nums1[<span class="number">0</span>]+nums2[<span class="number">0</span>])/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="寻找重复数中等待做">寻找重复数（中等）(待做)</h2>
<h3 id="题目描述-10">题目描述</h3>
<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code>
，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和
<code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回
<strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code>
且只用常量级 <code>O(1)</code> 的额外空间。</p>
<h3 id="思路-3">思路</h3>
<h2 id="颜色分类中等">颜色分类（中等）</h2>
<h3 id="题目描述-11">题目描述</h3>
<p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组
<code>nums</code> ，<strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/原地算法">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code>
分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<h3 id="思路-4">思路</h3>
<p>看起来代码比较复杂但是只遍历了一次数组，不知道能不能缩减，希望大佬能帮我看看，总体思路是：</p>
<p>由于题目确定了只有三个数字，所以我选择用双指针i和j，从头和尾往中间走，im表示im之前已经排好0的位置，jm表示jm之后已经排好2的位置，如果i和j遇到了0或者2，就放到im后一个位置或者jm前一个位置，知道遍历到i==j就说明遍历完了</p>
<p>就相当于把0往前扔，把2往后扔，1不变</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="type">int</span> im=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> jm=length;</span><br><span class="line">        <span class="keyword">while</span>(im&lt;length<span class="number">-1</span>&amp;&amp;nums[im+<span class="number">1</span>]==<span class="number">0</span>)im++;</span><br><span class="line">        i=im+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;length&amp;&amp;nums[i]==<span class="number">1</span>)i++;</span><br><span class="line">        <span class="keyword">while</span>(jm&gt;=<span class="number">1</span>&amp;&amp;nums[jm<span class="number">-1</span>]==<span class="number">2</span>)jm--;</span><br><span class="line">        j=jm<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;nums[j]==<span class="number">1</span>)j--;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;length&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">2</span>&amp;&amp;nums[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==jm<span class="number">-1</span>&amp;&amp;i!=im+<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[j--],nums[++im]);</span><br><span class="line">                    <span class="built_in">swap</span>(nums[i++],nums[--jm]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==jm<span class="number">-1</span>&amp;&amp;i==im+<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[j--],nums[i++]);</span><br><span class="line">                    ++im;</span><br><span class="line">                    --jm;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[i++],nums[--jm]);</span><br><span class="line">                    <span class="built_in">swap</span>(nums[j--],nums[++im]);</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">0</span>&amp;&amp;nums[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i++],nums[++im]);</span><br><span class="line">                <span class="built_in">swap</span>(nums[++im],nums[j--]);</span><br><span class="line">                <span class="keyword">if</span>(im==i)i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">0</span>&amp;&amp;nums[j]==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i++],nums[++im]);</span><br><span class="line">                <span class="built_in">swap</span>(nums[j--],nums[--jm]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==<span class="number">2</span>&amp;&amp;nums[j]==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i++],nums[--jm]);</span><br><span class="line">                <span class="built_in">swap</span>(nums[j--],nums[--jm]);</span><br><span class="line">                <span class="keyword">if</span>(j==jm)j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(im&lt;length<span class="number">-1</span>&amp;&amp;nums[im+<span class="number">1</span>]==<span class="number">0</span>)im++;</span><br><span class="line">            i=im+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;length&amp;&amp;nums[i]==<span class="number">1</span>)i++;</span><br><span class="line">            <span class="keyword">while</span>(jm&gt;=<span class="number">1</span>&amp;&amp;nums[jm<span class="number">-1</span>]==<span class="number">2</span>)jm--;</span><br><span class="line">            j=jm<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;nums[j]==<span class="number">1</span>)j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的中序遍历简单">二叉树的中序遍历（简单）</h2>
<h3 id="题目描述-12">题目描述</h3>
<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的
<strong>中序</strong> 遍历</em> 。</p>
<h3 id="思路-5">思路</h3>
<p>规规矩矩中序遍历即可，很简单</p>
<h3 id="代码-5">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mid</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">mid</span>(root-&gt;left);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">mid</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">mid</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="搜索旋转排序数组中等">搜索旋转排序数组（中等）</h2>
<h3 id="题目描述-13">题目描述</h3>
<p>整数数组 <code>nums</code> 按升序排列，数组中的值
<strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标
<code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了
<strong>旋转</strong>，使数组变为
<code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标
<strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code>
在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>
。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数
<code>target</code> ，如果 <code>nums</code> 中存在这个目标值
<code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code>
的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<h3 id="知识点-1">知识点</h3>
<ol type="1">
<li><p>c++合并数组（vector）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec1 = &#123;...&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec2 = &#123;...&#125;;<span class="comment">// vec1和vec2都存有内容</span></span><br><span class="line">    </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec3;<span class="comment">//vec3是空的</span></span><br><span class="line">vec3.<span class="built_in">insert</span>(vec3.<span class="built_in">end</span>(),vec1.<span class="built_in">begin</span>(),vec1.<span class="built_in">end</span>())<span class="comment">//将vec1压入</span></span><br><span class="line">vec3.<span class="built_in">insert</span>(vec3.<span class="built_in">end</span>(),vec2.<span class="built_in">begin</span>(),vec2.<span class="built_in">end</span>())<span class="comment">//继续将vec2压入</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-6">思路</h3>
<p>由题得，如果数组预先进行了旋转，那么数组可以分为升序的两部分，可以用二分法找到第二个升序的起始点，也就是找到第一个小于nums[0]的点，然后确定target属于哪个区间，在区间再进行二分查找即可</p>
<h3 id="代码-6">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]&lt;nums[left])&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right<span class="number">-1</span>)&#123;</span><br><span class="line">                mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&gt;=nums[left])left=mid;</span><br><span class="line">                <span class="keyword">else</span> right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]&gt;target)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;target)&#123;</span><br><span class="line">                left=right;</span><br><span class="line">                right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=<span class="number">0</span>;</span><br><span class="line">                right=right<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right<span class="number">-1</span>)&#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]!=target&amp;&amp;nums[right]!=target)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[left]==target?left:right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="合并区间中等">合并区间（中等）</h2>
<h3 id="题目描述-14">题目描述</h3>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为
<code>intervals[i] = [starti, endi]</code>
。请你合并所有重叠的区间，并返回
<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<h3 id="知识点-2">知识点</h3>
<ol type="1">
<li><p>优先队列+pair小根堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;pq;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-7">思路</h3>
<p>使用优先队列+pair自动排序，然后一个一个取出来比较就可以了（但是好像直接sort就行）</p>
<h3 id="代码-7">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : intervals)&#123;</span><br><span class="line">            nums.<span class="built_in">emplace</span>(it[<span class="number">0</span>],it[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">        <span class="type">int</span> first,second;</span><br><span class="line">        first=nums.<span class="built_in">top</span>().first;</span><br><span class="line">        second=nums.<span class="built_in">top</span>().second;</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(!nums.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">top</span>().first&gt;second)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;first,second&#125;);</span><br><span class="line">                first=nums.<span class="built_in">top</span>().first;</span><br><span class="line">                second=nums.<span class="built_in">top</span>().second;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                second=<span class="built_in">max</span>(second,nums.<span class="built_in">top</span>().second);</span><br><span class="line">            &#125;</span><br><span class="line">            nums.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;first,second&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿数量中等">岛屿数量（中等）</h2>
<h3 id="题目描述-15">题目描述</h3>
<p>给你一个由 <code>'1'</code>（陆地）和
<code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h3 id="思路-8">思路</h3>
<p><strong>二维数组的dfs遍历</strong></p>
<p>和二叉树相似，二叉树前序遍历思路是先遍历左节点，再遍历右节点，二维矩阵的遍历是先遍历左边，然后上面，右面，下面，这样遍历的结果肯定是属于一个岛的，遍历四个方向即可，同时由于不同点可能会遍历到同一个地方，将遍历过的地方进行标记，以免重复，此题的思路就是先遍历到第一个等于1的点，然后从四个方向进行遍历，将遍历的点都标记为2，这样下次遍历就不会再遍历到该点，有点像<strong>消消乐</strong>，从一个点往周围延申，全部遍历到并消除</p>
<h3 id="代码-8">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp;grid,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=grid.<span class="built_in">size</span>()||j&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>()||i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||grid[i][j]!=<span class="string">&#x27;1&#x27;</span>)<span class="keyword">return</span>;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid,i<span class="number">-1</span>,j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid,i,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> gridnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    gridnum++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gridnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的层序遍历中等">二叉树的层序遍历（中等）</h2>
<h3 id="题目描述-16">题目描述</h3>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的
<strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/7561e93a/tree1.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure>
<h3 id="知识点-3">知识点</h3>
<ol type="1">
<li><p>c++ vector基本用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同：</span><br><span class="line">front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</span><br><span class="line">back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</span><br><span class="line">push(const T&amp; obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</span><br><span class="line">push(T&amp;&amp; obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。</span><br><span class="line">pop()：删除 queue 中的第一个元素。</span><br><span class="line">size()：返回 queue 中元素的个数。</span><br><span class="line">empty()：如果 queue 中没有元素的话，返回 true。</span><br><span class="line">emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。</span><br><span class="line">swap(queue&lt;T&gt; &amp;other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-9">思路</h3>
<p>比较简单，用队列，先进后出原则，先将root存进队列，这个时候相当于第一层，所以只遍历root一个点即可，先获取当前队列长度为1，即当前遍历次数，然后存进left和right，再将root给pop掉，接着继续遍历第二层，也就是上一层存进的left和right，<strong>直接获取队列长度作为遍历次数即可</strong></p>
<h3 id="代码-9">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt;node;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;tempans;</span><br><span class="line">        node.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="keyword">while</span>(!node.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            length=node.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(length--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.<span class="built_in">front</span>())&#123;</span><br><span class="line">                    tempans.<span class="built_in">push_back</span>(node.<span class="built_in">front</span>()-&gt;val);</span><br><span class="line">                    node.<span class="built_in">push</span>(node.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                    node.<span class="built_in">push</span>(node.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                node.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!tempans.<span class="built_in">empty</span>())ans.<span class="built_in">push_back</span>(tempans);</span><br><span class="line">            tempans.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="对称二叉树简单">对称二叉树（简单）</h2>
<h3 id="题目描述-17">题目描述</h3>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/7561e93a/symtree1.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="思路-10">思路</h3>
<p>用递归遍历即可，很好发现对称二叉树的规律，首先分为两部分，root的左节点和右节点，比较两节点值是否相等，相等就在比较root左节点的右节点和root右节点的左节点值是否相等</p>
<h3 id="代码-10">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode*Node1,TreeNode*Node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Node1==<span class="literal">NULL</span>&amp;&amp;Node2==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(Node1==<span class="literal">NULL</span>||Node2==<span class="literal">NULL</span>||Node1-&gt;val!=Node2-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(Node1-&gt;left,Node2-&gt;right)&amp;&amp;<span class="built_in">compare</span>(Node1-&gt;right,Node2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最小路径和中等">最小路径和（中等）</h2>
<h3 id="题目描述-18">题目描述</h3>
<p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code>
，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/7561e93a/minpath.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>
<h3 id="思路-11">思路</h3>
<p>这个题感觉做过啊，但是leetcode没显示，那就再做一遍吧OvO</p>
<p><code>dp[i][j]</code>代表的是到达（i，j）位置的最短路径，等于到达(i-1,j)的最短路径和到达(i,j-1)的最短路径的较小值+<code>grid[i][j]</code></p>
<h3 id="代码-11">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(grid.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=grid.<span class="built_in">size</span>();i++)</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+grid[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            dp[<span class="number">1</span>][j]=dp[<span class="number">1</span>][j<span class="number">-1</span>]+grid[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=grid.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[grid.<span class="built_in">size</span>()][grid[<span class="number">0</span>].<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="合并k个升序链表困难">合并K个升序链表（困难）</h2>
<h3 id="题目描述-19">题目描述</h3>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<h3 id="思路-12">思路</h3>
<p>合并k个有序链表也许很陌生，但是合并两个有序链表就好做很多，比如第一个示例，可以看作先合并前两个，再和最后一个合并，和二分法的思维很类似，比如现在有长度为7的lists，第一轮合并lists[0]+lists[1],
lists[2]+lists[3],
lists[4]+lists[5],最后添上list[6]，得到长度为4的新链表组，继续两两合并直到最后新链表组长度为1即可</p>
<h3 id="代码-12">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge2Lists</span><span class="params">(ListNode* list1,ListNode* list2)</span></span>&#123;</span><br><span class="line">        ListNode*ans=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode*tempans=ans;</span><br><span class="line">        <span class="keyword">while</span>(list1&amp;&amp;list2)&#123;</span><br><span class="line">            <span class="keyword">while</span>(list2&amp;&amp;list1&amp;&amp;list1-&gt;val&lt;=list2-&gt;val)&#123;</span><br><span class="line">                tempans-&gt;next=list1;</span><br><span class="line">                tempans=tempans-&gt;next;</span><br><span class="line">                list1=list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(list1&amp;&amp;list2&amp;&amp;list2-&gt;val&lt;list1-&gt;val)&#123;</span><br><span class="line">                tempans-&gt;next=list2;</span><br><span class="line">                tempans=tempans-&gt;next;</span><br><span class="line">                list2=list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1)&#123;</span><br><span class="line">            tempans-&gt;next=list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2)&#123;</span><br><span class="line">            tempans-&gt;next=list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>()==<span class="number">0</span>||(lists.<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;lists[<span class="number">0</span>]==<span class="literal">NULL</span>))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        vector&lt;ListNode*&gt;templists;</span><br><span class="line">        <span class="keyword">while</span>(lists.<span class="built_in">size</span>()!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lists.<span class="built_in">size</span>()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                templists.<span class="built_in">push_back</span>(<span class="built_in">merge2Lists</span>(lists[i*<span class="number">2</span>],lists[i*<span class="number">2</span>+<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lists.<span class="built_in">size</span>()%<span class="number">2</span>)templists.<span class="built_in">push_back</span>(lists.<span class="built_in">back</span>());</span><br><span class="line">            lists.<span class="built_in">assign</span>(templists.<span class="built_in">begin</span>(),templists.<span class="built_in">end</span>());</span><br><span class="line">            templists.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>leetcode100题_3</p><p><a href="http://example.com/post/7561e93a.html">http://example.com/post/7561e93a.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>yyyyyyxnp</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2023-08-18</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-10-08</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/c/">c</a><a class="link-muted mr-2" rel="tag" href="/tags/c/">c++</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>Afdian.net</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/5ad7933.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">高阶网络学习</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/266d9ac.html"><span class="level-item">leetcode100题_2</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Yyyyyyxnp"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yyyyyyxnp</p><p class="is-size-6 is-block">Student Yang</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Sichuan University</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">46</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/deng12yx" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#复制带随机指针的链表中等"><span class="level-left"><span class="level-item">1</span><span class="level-item">复制带随机指针的链表（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">思路（两种思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一根据next新建节点"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">思路一：根据next新建节点</span></span></a></li><li><a class="level is-mobile" href="#代码一"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二根绝random和next新建节点回溯递归"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">思路二：根绝random和next新建节点，回溯递归</span></span></a></li><li><a class="level is-mobile" href="#代码二"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#编辑距离困难"><span class="level-left"><span class="level-item">2</span><span class="level-item">编辑距离（困难）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#路径总和中等"><span class="level-left"><span class="level-item">3</span><span class="level-item">路径总和（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-2"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-1"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-1"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#只出现一次的数字简单"><span class="level-left"><span class="level-item">4</span><span class="level-item">只出现一次的数字（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-3"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路-1"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">思路（两种思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一哈希"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">思路一：哈希</span></span></a></li><li><a class="level is-mobile" href="#代码一-1"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二异或"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">思路二：异或</span></span></a></li><li><a class="level is-mobile" href="#代码二-1"><span class="level-left"><span class="level-item">4.3.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#零钱兑换中等"><span class="level-left"><span class="level-item">5</span><span class="level-item">零钱兑换（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-4"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路-2"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">思路（两种思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一dfs"><span class="level-left"><span class="level-item">5.2.1</span><span class="level-item">思路一：dfs</span></span></a></li><li><a class="level is-mobile" href="#代码一-2"><span class="level-left"><span class="level-item">5.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二动态规划"><span class="level-left"><span class="level-item">5.2.3</span><span class="level-item">思路二：动态规划</span></span></a></li><li><a class="level is-mobile" href="#代码二-2"><span class="level-left"><span class="level-item">5.2.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#柱状图中最大的矩形困难"><span class="level-left"><span class="level-item">6</span><span class="level-item">柱状图中最大的矩形(困难)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-5"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路-3"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">思路（两种思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一模仿接雨水的按行求"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">思路一：模仿接雨水的按行求</span></span></a></li><li><a class="level is-mobile" href="#代码一-3"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二运用栈"><span class="level-left"><span class="level-item">6.2.3</span><span class="level-item">思路二：运用栈</span></span></a></li><li><a class="level is-mobile" href="#代码二-3"><span class="level-left"><span class="level-item">6.2.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#删除链表的倒数第-n-个结点中等"><span class="level-left"><span class="level-item">7</span><span class="level-item">删除链表的倒数第
N 个结点（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-6"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路双指针"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">思路：双指针</span></span></a></li><li><a class="level is-mobile" href="#代码-2"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#搜索二维矩阵中等"><span class="level-left"><span class="level-item">8</span><span class="level-item">搜索二维矩阵（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-7"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路-4"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">思路（两种思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一暴力遍历"><span class="level-left"><span class="level-item">8.2.1</span><span class="level-item">思路一：暴力遍历</span></span></a></li><li><a class="level is-mobile" href="#代码一-4"><span class="level-left"><span class="level-item">8.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二两次二分"><span class="level-left"><span class="level-item">8.2.3</span><span class="level-item">思路二：两次二分</span></span></a></li><li><a class="level is-mobile" href="#代码二-4"><span class="level-left"><span class="level-item">8.2.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#回文链表简单"><span class="level-left"><span class="level-item">9</span><span class="level-item">回文链表（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-8"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路-5"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">思路（两种思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一借助栈"><span class="level-left"><span class="level-item">9.2.1</span><span class="level-item">思路一：借助栈</span></span></a></li><li><a class="level is-mobile" href="#代码一-5"><span class="level-left"><span class="level-item">9.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二反转一半"><span class="level-left"><span class="level-item">9.2.3</span><span class="level-item">思路二：反转一半</span></span></a></li><li><a class="level is-mobile" href="#代码二-5"><span class="level-left"><span class="level-item">9.2.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#寻找两个正序数组的中位数困难"><span class="level-left"><span class="level-item">10</span><span class="level-item">寻找两个正序数组的中位数（困难）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-9"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-2"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-3"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#寻找重复数中等待做"><span class="level-left"><span class="level-item">11</span><span class="level-item">寻找重复数（中等）(待做)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-10"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-3"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">思路</span></span></a></li></ul></li><li><a class="level is-mobile" href="#颜色分类中等"><span class="level-left"><span class="level-item">12</span><span class="level-item">颜色分类（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-11"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-4"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-4"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二叉树的中序遍历简单"><span class="level-left"><span class="level-item">13</span><span class="level-item">二叉树的中序遍历（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-12"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-5"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-5"><span class="level-left"><span class="level-item">13.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#搜索旋转排序数组中等"><span class="level-left"><span class="level-item">14</span><span class="level-item">搜索旋转排序数组（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-13"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-1"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-6"><span class="level-left"><span class="level-item">14.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-6"><span class="level-left"><span class="level-item">14.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#合并区间中等"><span class="level-left"><span class="level-item">15</span><span class="level-item">合并区间（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-14"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-2"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-7"><span class="level-left"><span class="level-item">15.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-7"><span class="level-left"><span class="level-item">15.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#岛屿数量中等"><span class="level-left"><span class="level-item">16</span><span class="level-item">岛屿数量（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-15"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-8"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-8"><span class="level-left"><span class="level-item">16.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二叉树的层序遍历中等"><span class="level-left"><span class="level-item">17</span><span class="level-item">二叉树的层序遍历（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-16"><span class="level-left"><span class="level-item">17.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-3"><span class="level-left"><span class="level-item">17.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-9"><span class="level-left"><span class="level-item">17.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-9"><span class="level-left"><span class="level-item">17.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#对称二叉树简单"><span class="level-left"><span class="level-item">18</span><span class="level-item">对称二叉树（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-17"><span class="level-left"><span class="level-item">18.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-10"><span class="level-left"><span class="level-item">18.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-10"><span class="level-left"><span class="level-item">18.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#最小路径和中等"><span class="level-left"><span class="level-item">19</span><span class="level-item">最小路径和（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-18"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-11"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-11"><span class="level-left"><span class="level-item">19.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#合并k个升序链表困难"><span class="level-left"><span class="level-item">20</span><span class="level-item">合并K个升序链表（困难）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-19"><span class="level-left"><span class="level-item">20.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-12"><span class="level-left"><span class="level-item">20.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-12"><span class="level-left"><span class="level-item">20.3</span><span class="level-item">代码</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/deng12yx" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/JNDI/"><span class="level-start"><span class="level-item">JNDI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/RMI/"><span class="level-start"><span class="level-item">RMI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/ctf/"><span class="level-start"><span class="level-item">ctf</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">复杂网络</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/post/9c1a1a1.html"><img src="/img/article/17.png" alt="luogu_1"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-10-08T10:50:27.000Z">2024-10-08</time></p><p class="title"><a href="/post/9c1a1a1.html">luogu_1</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/7684f23b.html"><img src="/img/article/15.png" alt="T2I"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-23T06:17:27.000Z">2024-09-23</time></p><p class="title"><a href="/post/7684f23b.html">T2I</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/e4cc0182.html"><img src="/img/article/16.png" alt="Explainable_ML"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-23T06:15:08.000Z">2024-09-23</time></p><p class="title"><a href="/post/e4cc0182.html">Explainable_ML</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-18T02:04:22.000Z">2024-08-18</time></p><p class="title"><a href="/post/374aa791.html">leetcode-daily-practice</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/cda691ed.html"><img src="/img/article/13.png" alt="FGSM &amp; PDG"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-07-02T08:20:29.000Z">2024-07-02</time></p><p class="title"><a href="/post/cda691ed.html">FGSM &amp; PDG</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">September 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/08/"><span class="level-start"><span class="level-item">August 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">July 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">December 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">September 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">July 2023</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">20</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">BeautyFlower</a><p class="is-size-7"><span>&copy; 2024 yyyyyyxnp</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/deng12yx"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'folded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>