<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>leetcode100题_last - BeautyFlower</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Icaurs - Hexo Theme"><meta name="msapplication-TileImage" content="icons/touch-icon-iphone.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Icaurs - Hexo Theme"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="icons/touch-icon-iphone.png"><link rel="apple-touch-icon" sizes="152x152" href="icons/touch-icon-ipad.png"><link rel="apple-touch-icon" sizes="72x72" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="96x96" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="128x128" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="256x256" href="icon/logo.ico"><meta name="description" content="2023.09.20：leetcode100题在此完结撒花o(￣▽￣)ブ"><meta property="og:type" content="blog"><meta property="og:title" content="leetcode100题_last"><meta property="og:url" content="http://example.com/post/3a2a3e16.html"><meta property="og:site_name" content="BeautyFlower"><meta property="og:description" content="2023.09.20：leetcode100题在此完结撒花o(￣▽￣)ブ"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/article/21.png"><meta property="article:published_time" content="2023-08-29T01:17:59.000Z"><meta property="article:modified_time" content="2024-10-08T10:56:34.829Z"><meta property="article:author" content="yyyyyyxnp"><meta property="article:tag" content="c"><meta property="article:tag" content="c++"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/article/21.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/post/3a2a3e16.html"},"headline":"leetcode100题_last","image":["http://example.com/img/article/21.png"],"datePublished":"2023-08-29T01:17:59.000Z","dateModified":"2024-10-08T10:56:34.829Z","author":{"@type":"Person","name":"yyyyyyxnp"},"publisher":{"@type":"Organization","name":"BeautyFlower","logo":{"@type":"ImageObject","url":{"text":"BeautyFlower"}}},"description":"2023.09.20：leetcode100题在此完结撒花o(￣▽￣)ブ"}</script><link rel="canonical" href="http://example.com/post/3a2a3e16.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="BeautyFlower" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">BeautyFlower</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/deng12yx"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/article/21.png" alt="leetcode100题_last"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item copyright article-title type-2">原创</span><span class="level-item">Posted&nbsp;<time dateTime="2023-08-29T01:17:59.000Z" title="2023/8/29 09:17:59">2023-08-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-08T10:56:34.829Z" title="2024/10/8 18:56:34">2024-10-08</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="level-item">an hour read (About 11529 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile"> leetcode100题_last</h1><div class="copyright article-block type-2"><p>版权申明：本文为原创文章，转载请注明原文出处</p><p>原文链接：<a href="http://example.com/post/3a2a3e16.html" target="_blank">http://example.com/post/3a2a3e16.html</a></p></div><h1 class="title is-3 is-size-4-mobile">leetcode100题_last</h1><div class="content"><p>2023.09.20：leetcode100题在此完结撒花o(<em>￣▽￣</em>)ブ</p>
<span id="more"></span>
<h2 id="二叉树中的最大路径和困难">二叉树中的最大路径和（困难）</h2>
<h3 id="题目描述">题目描述</h3>
<p>二叉树中的 <strong>路径</strong>
被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中
<strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong>
节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其
<strong>最大路径和</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/exx1.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure>
<h3 id="知识点">知识点</h3>
<ol type="1">
<li><p>二叉树后序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    cout&lt;&lt;root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路">思路</h3>
<p>首先明确我们需要求的是什么，根据题目得到，我们要求最大路径和，该路径每个节点只能出现一次，而二叉树我们对于一个节点，只有算它的左节点和右节点最方便，根据题意这条路径就两种情况：</p>
<ul>
<li>第一种：以某个节点为根节点往两边延申；</li>
<li>第二种：以某个节点为根节点只往一边延伸；</li>
</ul>
<p>得到这两种情况就好写代码很多，我们可以通过<strong>存储节点单项向下延申的最大值</strong>，因为对于某个根节点，如果要往两边延申，则往下延申的每个节点都只能往一边延申，而如果该根节点只往一边延伸，则往下延伸的每个节点也只能往一边延申，所以我们不需要存储该根节点往两边延伸的结果，因为后面都用不到，只需要在计算该根节点往一边延伸的最大值时顺便计算往两边延伸的最大值。</p>
<p>单边延伸的最大值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;val=<span class="built_in">max</span>(<span class="built_in">max</span>(root-&gt;left-&gt;val,root-&gt;right-&gt;val),<span class="number">0</span>)+root-&gt;val;</span><br></pre></td></tr></table></figure>
<p>由于我们是从下往上计算的单边延伸的最大值，所以用了后序遍历</p>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxNum=<span class="number">-1001</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maxPathForANode</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>||root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>||root-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>)root-&gt;val=root-&gt;val+<span class="built_in">max</span>(<span class="number">0</span>,root-&gt;right-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right==<span class="literal">NULL</span>)root-&gt;val=root-&gt;val+<span class="built_in">max</span>(<span class="number">0</span>,root-&gt;left-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxNum=<span class="built_in">max</span>(root-&gt;left-&gt;val+root-&gt;right-&gt;val+root-&gt;val,maxNum);</span><br><span class="line">            root-&gt;val=<span class="built_in">max</span>(<span class="built_in">max</span>(root-&gt;left-&gt;val,root-&gt;right-&gt;val),<span class="number">0</span>)+root-&gt;val;      </span><br><span class="line">        &#125;</span><br><span class="line">        maxNum=<span class="built_in">max</span>(root-&gt;val,maxNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="built_in">maxPathForANode</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="验证二叉搜索树中等">验证二叉搜索树(中等)</h2>
<h3 id="题目描述-1">题目描述</h3>
<p>给你一个二叉树的根节点 <code>root</code>
，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/tree1.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="知识点-1">知识点</h3>
<ol type="1">
<li><p>long long最大值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> maxnum=LLONG_MAX;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-1">思路</h3>
<p>这个题我们要考虑两个要点，下面我对这两个要点分别进行说明</p>
<ol type="1">
<li><p>对于一个节点，需保证左节点小于该节点，右节点大于该节点；</p>
<p>这个很好实现，用前序遍历的方式，遍历每个节点，判断是否满足左节点小于该节点，右节点大于该节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>||(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val&gt;=root-&gt;right-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val&lt;=root-&gt;left-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val&gt;=root-&gt;right-&gt;val||root-&gt;val&lt;=root-&gt;left-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left)&amp;&amp;<span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于一个节点，需保证左子树的所有值要大于右子树的所有值；</p>
<p>这对于每个节点就需要另外的两个值，该节点需要大于的值，和该节点需要小于的值，例如，某根节点的左子节点A的右子节点B，就需要保证B的值小于根节点的值，大于A的值</p>
<p>遍历方式也很简单，增加传入的参数，一个是要大于的值，一个是要小于的值，如果当前遍历节点为A，如果下一个遍历的是左节点，更新的方式是将要小于的值改成A的值，要大于的值不变，如果下一个遍历的是右节点，将要大于的值改成A的值，要小于的值不变</p></li>
</ol>
<h3 id="代码-1">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBSTForANode</span><span class="params">(TreeNode*root,<span class="type">long</span> <span class="type">long</span> maxnum,<span class="type">long</span> <span class="type">long</span> minnum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;=maxnum||root-&gt;val&gt;=minnum)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ((root-&gt;left==<span class="literal">NULL</span>)?<span class="literal">true</span>:<span class="built_in">isValidBSTForANode</span>(root-&gt;left,maxnum,root-&gt;val))&amp;&amp;((root-&gt;right==<span class="literal">NULL</span>)?<span class="literal">true</span>:<span class="built_in">isValidBSTForANode</span>(root-&gt;right,root-&gt;val,minnum));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBSTForANode</span>(root,LLONG_MIN,LLONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三数之和中等">三数之和（中等）</h2>
<h3 id="题目描述-2">题目描述</h3>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组
<code>[nums[i], nums[j], nums[k]]</code> 满足
<code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>
，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>
<h3 id="思路-2">思路</h3>
<p>好难/(ㄒoㄒ)/~~</p>
<p>主要就是不可以包含重复的三元组比较难满足，如果直接三次遍历不仅有可能有重复的三元组而且复杂度很高，现在考虑的就是降低复杂度，同时不要有重复的三元组</p>
<p>可以对原数组进行排序，这样能保证相同的数出现的地方是连续的，方便进行跳过</p>
<p>先对第一个数进行遍历，然后第二个数初始化为第一个数后面那个数，第三个数初始化为最后一个数，也就是最大的数，如果三个加起来比0大，第三个数就往前走，有相同的就跳过，一个数只算一次，如果加起来比0小，第二个数就往后走</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">        <span class="type">int</span> second;</span><br><span class="line">        <span class="type">int</span> third;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i!=<span class="number">0</span>&amp;&amp;i&lt;length&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])i++;</span><br><span class="line">            second=i+<span class="number">1</span>;</span><br><span class="line">            third=length<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(second&lt;third)&#123;</span><br><span class="line">                <span class="keyword">while</span>(second&lt;third&amp;&amp;((second!=i+<span class="number">1</span>&amp;&amp;nums[second]==nums[second<span class="number">-1</span>])||nums[second]+nums[third]+nums[i]&lt;<span class="number">0</span>)) second++;</span><br><span class="line">                <span class="keyword">while</span>(second&lt;third&amp;&amp;((third!=length<span class="number">-1</span>&amp;&amp;nums[third]==nums[third+<span class="number">1</span>])||nums[second]+nums[third]+nums[i]&gt;<span class="number">0</span>)) third--;</span><br><span class="line">                <span class="keyword">if</span>(second&lt;third&amp;&amp;nums[second]+nums[third]+nums[i]==<span class="number">0</span>) ans.<span class="built_in">push_back</span>(&#123;nums[i],nums[second++],nums[third--]&#125;);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="lru缓存中等">LRU缓存（中等）</h2>
<h3 id="题目描述-3">题目描述</h3>
<p>请你设计并实现一个满足 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LRU">LRU
(最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong>
作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code>
存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字
<code>key</code> 已经存在，则变更其数据值 <code>value</code>
；如果不存在，则向缓存中插入该组 <code>key-value</code>
。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该
<strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code>
的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure>
<h3 id="思路-3">思路</h3>
<p>最近最少使用，lz仔细回忆了下os讲的内容，大概记得当时讲的是每个值会记录最近使用的时间，每次取的时候取最近使用时间最远的一次，所以我在此处也用了该思路，用了两个排序哈希（好像复杂度不满足要求？）</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;useTime;</span><br><span class="line">    map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;word;</span><br><span class="line">    <span class="type">int</span> capacityUse;</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        capacityUse=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.<span class="built_in">find</span>(key)==word.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        useTime.<span class="built_in">erase</span>(word[key][<span class="number">1</span>]);</span><br><span class="line">        word[key][<span class="number">1</span>]=++i;</span><br><span class="line">        useTime[i]=key;</span><br><span class="line">        <span class="keyword">return</span> word[key][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(word.<span class="built_in">find</span>(key)!=word.<span class="built_in">end</span>())&#123;</span><br><span class="line">            useTime.<span class="built_in">erase</span>(word[key][<span class="number">1</span>]);</span><br><span class="line">            word[key][<span class="number">0</span>]=value;</span><br><span class="line">            word[key][<span class="number">1</span>]=i;   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(word.<span class="built_in">size</span>()==capacityUse)&#123;</span><br><span class="line">                word.<span class="built_in">erase</span>(useTime.<span class="built_in">begin</span>()-&gt;second);</span><br><span class="line">                useTime.<span class="built_in">erase</span>(useTime.<span class="built_in">begin</span>()-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">            word[key].<span class="built_in">push_back</span>(value);</span><br><span class="line">            word[key].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;   </span><br><span class="line">        useTime[i]=key; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="从前序和中序遍历序列构造二叉树中等">从前序和中序遍历序列构造二叉树（中等）</h2>
<h3 id="题目描述-4">题目描述</h3>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中
<code>preorder</code> 是二叉树的<strong>先序遍历</strong>，
<code>inorder</code>
是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p><strong>示例 1:</strong></p>
<figure>
<img src="/post/3a2a3e16/tree.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>
<h3 id="思路-4">思路</h3>
<p>首先明确前序序列第一个肯定是该数组表示的树的根节点，然后再inorder里面找对应的位置，该位置之前的肯定是树的左子树的中序遍历结果，之后的肯定是树的右子树中序遍历结果，同时提取出前序序列中表示左子树前序遍历结果，和右子树前序遍历结果，进行递归处理避免重复操作</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder, vector&lt;<span class="type">int</span>&gt; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">empty</span>() || inorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == root-&gt;val) &#123;</span><br><span class="line">                root-&gt;left = <span class="built_in">buildTree</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(preorder.<span class="built_in">begin</span>() + <span class="number">1</span>, preorder.<span class="built_in">begin</span>() + i + <span class="number">1</span>), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">begin</span>() + i));</span><br><span class="line">                root-&gt;right = <span class="built_in">buildTree</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(preorder.<span class="built_in">begin</span>() + i + <span class="number">1</span>, preorder.<span class="built_in">end</span>()),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(inorder.<span class="built_in">begin</span>() + i + <span class="number">1</span>, inorder.<span class="built_in">end</span>()));</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="搜索二维矩阵中等">搜索二维矩阵（中等）</h2>
<h3 id="题目描述-5">题目描述</h3>
<p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵
<code>matrix</code> 中的一个目标值 <code>target</code>
。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/searchgrid2.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="思路两种思路">思路(两种思路)</h3>
<h4 id="思路一二分查找">思路一：二分查找</h4>
<p>先纵向遍历，只遍历比target小的，然后对那一排进行二分查找</p>
<h4 id="代码一">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left;</span><br><span class="line">        <span class="type">int</span> right;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]&lt;=target&amp;&amp;matrix[i].<span class="built_in">back</span>()&gt;=target)&#123;   </span><br><span class="line">                left=<span class="number">0</span>;</span><br><span class="line">                right=n;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right<span class="number">-1</span>)&#123;</span><br><span class="line">                    mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">                    (matrix[i][mid]&gt;=target)?right=mid:left=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][left]==target||matrix[i][right]==target)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]&gt;target)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二z字形查找">思路二：Z字形查找</h4>
<p>从左下角开始，如果值比target大就往上，因为只有往上才能找到比该值小的数，如果比target小就往下</p>
<h4 id="代码二">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> x=matrix.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=<span class="number">0</span>&amp;&amp;y&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y]==target)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            (matrix[x][y]&gt;target)?x--:y++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="n皇后困难">N皇后（困难）</h2>
<h3 id="题目描述-6">题目描述</h3>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>
个皇后放置在 <code>n×n</code>
的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n
皇后问题</strong> 的解决方案。</p>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong>
的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code>
分别代表了皇后和空位。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/queens.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>
<h3 id="思路-5">思路</h3>
<p>用回溯的方法做，一排一排的放置皇后，一排只能放一个，同时为了方便确认哪些位置不能放，用了三个哈希来存不能放的位置:</p>
<ul>
<li>第一个哈希用来存放过的列，这个只需要在要放新元素的时候添加值即可</li>
<li>第二个哈希用来放向右对角线延展的位置，因为题目要求了放了皇后的对角线位置不能放，由于可以向两边扩展对角线，所以这里用了两个哈希，同时每一排都需要更新，因为根据对角线不能放的列每一排是不一样的，往右扩展的要减一，往左扩展的要加一</li>
<li>第三个哈希用来放向左对角线延展的位置</li>
</ul>
<h3 id="代码-5">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt;ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">putQueens</span><span class="params">(vector&lt;string&gt;ansItem,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hashForleft,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hashForRight,<span class="type">int</span> remainN,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remainN==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(ansItem);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hashForleftUse;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hashForRightUse;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=hashForleft.<span class="built_in">begin</span>();it!=hashForleft.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            hashForleftUse[it-&gt;first<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=hashForRight.<span class="built_in">begin</span>();it!=hashForRight.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            hashForRightUse[it-&gt;first+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string ansStr;</span><br><span class="line">        string ansStrCopy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">find</span>(i)==hash.<span class="built_in">end</span>()&amp;&amp;hashForleft.<span class="built_in">find</span>(i)==hashForleft.<span class="built_in">end</span>()&amp;&amp;hashForRight.<span class="built_in">find</span>(i)==hashForRight.<span class="built_in">end</span>())&#123;</span><br><span class="line">                ansStrCopy=ansStr;</span><br><span class="line">                ansStrCopy.<span class="built_in">push_back</span>(<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">                hash[i]=<span class="number">1</span>;</span><br><span class="line">                hashForleftUse[i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">                hashForRightUse[i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    ansStrCopy.<span class="built_in">push_back</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ansItem.<span class="built_in">push_back</span>(ansStrCopy);</span><br><span class="line">                <span class="built_in">putQueens</span>(ansItem,hash,hashForleftUse,hashForRightUse,--remainN,n);</span><br><span class="line">                hash.<span class="built_in">erase</span>(i);</span><br><span class="line">                hashForleftUse.<span class="built_in">erase</span>(i<span class="number">-1</span>);</span><br><span class="line">                hashForRightUse.<span class="built_in">erase</span>(i+<span class="number">1</span>);</span><br><span class="line">                remainN++;</span><br><span class="line">                ansItem.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ansStr.<span class="built_in">push_back</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hashForleft;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hashForRight;</span><br><span class="line">        <span class="type">int</span> remainN=n;</span><br><span class="line">        vector&lt;string&gt;ansItem;</span><br><span class="line">        <span class="built_in">putQueens</span>(ansItem,hash,hashForleft,hashForRight,remainN,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="在排序数组中查找元素的第一个和最后一个位置中等"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a>(中等)</h2>
<h3 id="题目描述-7">题目描述</h3>
<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值
<code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回
<code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code>
的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>
<h3 id="思路-6">思路</h3>
<p>两遍二分查找即可，第一次找左边界，第二次找右边界</p>
<h3 id="代码-6">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;<span class="number">0</span>)<span class="keyword">return</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right<span class="number">-1</span>)&#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftnum=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rightnum=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]==target)leftnum=right;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target)leftnum=left;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right<span class="number">-1</span>)&#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target)rightnum=left;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]==target)rightnum=right;</span><br><span class="line">        <span class="keyword">return</span> &#123;leftnum,rightnum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="爬楼梯简单">爬楼梯（简单）</h2>
<h3 id="题目描述-8">题目描述</h3>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code>
个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure>
<h3 id="思路-7">思路</h3>
<p>一次只能爬两级或者一级，那爬到第i级的总方法次数为爬到i-2级然后再爬一级加上爬到i-1级然后再爬一级</p>
<h3 id="代码-7">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            ans[i]=ans[i<span class="number">-2</span>]+ans[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="完全平方数中等">完全平方数（中等）</h2>
<h3 id="题目描述-9">题目描述</h3>
<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code>
的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong>
是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code>
和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code>
不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure>
<h3 id="知识点-2">知识点</h3>
<ol type="1">
<li><p>c++对数开方并往下取整</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sqrtNum=<span class="built_in">sqrt</span>(num)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-8">思路</h3>
<p>很简单的动态规划,dp[i]表示第i个数的需要的最小的完全平方数,计算dp[i+1]时比较哪两个数加起来结果为i+1并且dp[j]+dp[i+1-j]值最小即需要的最小的完全平方数</p>
<h3 id="代码-8">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;dp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">10000</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">sqrt</span>(i);j++)&#123;</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(<span class="number">1</span>+dp[i-j*j],dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的直径简单">二叉树的直径（简单）</h2>
<h3 id="题目描述-10">题目描述</h3>
<p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p>
<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的
<strong>长度</strong> 。这条路径可能经过也可能不经过根节点
<code>root</code> 。</p>
<p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/diamtree.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。</span><br></pre></td></tr></table></figure>
<h3 id="思路-9">思路</h3>
<p>之前应该做过一个很类似的题，还是用遍历加改变节点值的方法。</p>
<p>首先明确怎么确定这个最大路径，很简单可以思考到，这个最大路径肯定有一个'根节点'，这个根节点不一定是原二叉树的根节点，意思是从该根节点往左右节点延申到叶子节点得到的路径肯定是最长的路径，因为如果没有这个根节点，只算一边肯定不能是最大路径，因为还可以往另一边延申，如果不到叶子节点肯定也不对，因为还可以向下走，就不能算最大路径。</p>
<p>lz最开始的思路是用前序遍历，从根节点遍历每一个节点，算每个节点左右子树的最大高度之和就是从该根节点能达到的最大路径，但是这种方式我们每次都要重新遍历节点，每次都要重新算从某个节点往下延伸的最大高度，这样上一次算出来的最大路径在后面也不能用，所以考虑使用后序遍历的方式，先遍历最下面的，然后将算出来的高度作为节点的值，这样上面一个节点的最大路径就是左节点的高度加上右节点的高度，由于我们是从下往上算的，就不需要重复算，直接读我们存的值就可以了。</p>
<h3 id="代码-9">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxNum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root-&gt;val=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root-&gt;val=root-&gt;right-&gt;val+<span class="number">1</span>;</span><br><span class="line">            maxNum=<span class="built_in">max</span>(maxNum,root-&gt;val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root-&gt;val=root-&gt;left-&gt;val+<span class="number">1</span>;</span><br><span class="line">            maxNum=<span class="built_in">max</span>(maxNum,root-&gt;val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;val=<span class="built_in">max</span>(root-&gt;left-&gt;val,root-&gt;right-&gt;val)+<span class="number">1</span>;</span><br><span class="line">            maxNum=<span class="built_in">max</span>(maxNum,root-&gt;left-&gt;val+root-&gt;right-&gt;val+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="将有序数组转换为二叉搜索树简单">将有序数组转换为二叉搜索树（简单）</h2>
<h3 id="题目描述-11">题目描述</h3>
<p>给你一个整数数组 <code>nums</code> ，其中元素已经按
<strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong>
二叉搜索树。</p>
<p><strong>高度平衡</strong>
二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1
」的二叉树。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/btree1.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure>
<h3 id="知识点-3">知识点</h3>
<ol type="1">
<li><p>vecotor重定义大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;nums;</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">nums.<span class="built_in">push_bacn</span>(<span class="number">-2</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a1</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+<span class="number">2</span>);<span class="comment">//&#123;10,2&#125;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a2</span>(nums.<span class="built_in">begin</span>()+<span class="number">2</span>,nums.<span class="built_in">end</span>());<span class="comment">//&#123;0,-1,-2&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-10">思路</h3>
<p>要使两边高度差小于等于1，并保证每层如此，直接将中间值作为根节点即可，每层都如此，这样能保证两边差只有1或者0</p>
<h3 id="代码-10">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode*newNode=<span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        newNode-&gt;val=nums[(nums.<span class="built_in">size</span>()<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">        newNode-&gt;left=<span class="built_in">sortedArrayToBST</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+(nums.<span class="built_in">size</span>()<span class="number">-1</span>)/<span class="number">2</span>));</span><br><span class="line">        newNode-&gt;right=<span class="built_in">sortedArrayToBST</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>()+(nums.<span class="built_in">size</span>()<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1</span>,nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="环形链表中等">环形链表（中等）</h2>
<h3 id="题目描述-12">题目描述</h3>
<p>给定一个链表的头节点 <code>head</code>
，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回
<code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code>
指针再次到达，则链表中存在环。
为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code>
来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果
<code>pos</code> 是
<code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code>
不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/circularlinkedlist.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<h3 id="思路-11">思路</h3>
<p>好吧，做完了才发现不能修改链表，还在想怎么这么简单，不修改链表的方法lz有空再做吧/(ㄒoㄒ)/~~</p>
<h3 id="代码-11">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;val&lt;INT_MAX)&#123;</span><br><span class="line">            head-&gt;val=INT_MAX;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="翻转二叉树简单">翻转二叉树（简单）</h2>
<h3 id="题目描述-13">题目描述</h3>
<p>给你一棵二叉树的根节点 <code>root</code>
，翻转这棵二叉树，并返回其根节点。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/invert1-tree.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>
<h3 id="思路-12">思路</h3>
<p>很简单的遍历，如下代码</p>
<h3 id="代码-12">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数组中第k个最大的元素中等待做">数组中第k个最大的元素(中等)（待做）</h2>
<h3 id="题目描述-14">题目描述</h3>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第
<code>**k**</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code>
个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h3 id="思路大根堆">思路：大根堆</h3>
<h2 id="课程表中等">课程表（中等）</h2>
<h3 id="题目描述-15">题目描述</h3>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为
<code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组
<code>prerequisites</code> 给出，其中
<code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程
<code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code>
。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程
<code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code>
；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>
<h3 id="知识点-4">知识点</h3>
<ol type="1">
<li><p>unordered_map合并</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map1 = &#123;&#123;<span class="number">1</span>, <span class="number">10</span>&#125;, &#123;<span class="number">2</span>, <span class="number">20</span>&#125;, &#123;<span class="number">3</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map2 = &#123;&#123;<span class="number">1</span>, <span class="number">40</span>&#125;, &#123;<span class="number">5</span>, <span class="number">50</span>&#125;, &#123;<span class="number">6</span>, <span class="number">60</span>&#125;&#125;;</span><br><span class="line">map1.<span class="built_in">insert</span>(map2.<span class="built_in">begin</span>(), map2.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-13">思路</h3>
<p>拓扑排序，思路就是，想象一张有向图，a-&gt;b代表完成a之后才能完成b，我们的目的就是不能在这张图中找到环</p>
<p>一种方法是深度优先遍历，该方法的含义首先确定一个起始节点，对其指向的节点进行深度遍历，直到遍历到没有指向的点，就说明该点课程完成之后并不能对其他课程起作用，就将该课程标记为优先级最低的那一批，也可以理解为进栈，这里的优先级最低代表该课程不会对后面进栈的所有课程起作用，但是后面进栈的课程完成之后该课程才能完成，同时遍历还有一个重要判断条件就是一个节点在一条路上不能遍历两次，否这里也比较好理解，就是我们由于是深度遍历，所以每次相当于是遍历一条路径，如果这条路径有节点遍历了两次则就说明有环，所以每遍历一条路径就需要对这条路径进行标记，这里是标记为1，同时对已经判定第优先级的节点标记为2，就相当于这条路径不会再继续往下走了，该节点也不会用了，但是该节点之前的节点还需要用，因为是深度遍历</p>
<p>广度优先遍历看了题解就懒得写代码了直接讲一下思路吧：还是一样的图，同时为每个节点记录入度，代表有几门课程修完之后该课程才能修，首先找到0度的节点，说明该节点可以直接修，然后从该节点进行广度优先遍历第一层，将连接的节点度数减一，相当于就是当作上一个节点直接修过了，然后在找度数为0的点继续广度优先遍历</p>
<h3 id="代码-13">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!valid)<span class="keyword">return</span>;</span><br><span class="line">        visited[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> item:edges[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[item]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[item]==<span class="number">1</span>)&#123;</span><br><span class="line">                valid=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i]=<span class="number">2</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> its : prerequisites)edges[its[<span class="number">1</span>]].<span class="built_in">push_back</span>(its[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)<span class="keyword">if</span>(!visited[i])<span class="built_in">dfs</span>(i);</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="分割等和子集中等待做">分割等和子集（中等）（待做）</h2>
<h3 id="题目描述-16">题目描述</h3>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组
<code>nums</code>
。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure>
<h3 id="知识点-5">知识点</h3>
<ol type="1">
<li>数组求和</li>
</ol>
<h2 id="每日温度中等">每日温度（中等）</h2>
<h3 id="题目描述-17">题目描述</h3>
<p>给定一个整数数组 <code>temperatures</code>
，表示每天的温度，返回一个数组 <code>answer</code> ，其中
<code>answer[i]</code> 是指对于第 <code>i</code>
天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用
<code>0</code> 来代替。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure>
<h3 id="思路-14">思路</h3>
<p>不知道为什么最近做题一点思路都没有，这么经典的栈题都没做出来/(ㄒoㄒ)/~~</p>
<p>很经典的用栈，因为要获取往后最近的比该点大的位置，开始想到了当遇到比自己小的数，就从那个数往后进行判断直到遇到比自己的大的数，但是没想起用栈/(ㄒoㄒ)/~~</p>
<h3 id="代码-14">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt; temperatures)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(temperatures.<span class="built_in">size</span>());</span><br><span class="line">        stack&lt;vector&lt;<span class="type">int</span>&gt;&gt;temper;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temperatures.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!temper.<span class="built_in">empty</span>()&amp;&amp;temper.<span class="built_in">top</span>()[<span class="number">0</span>]&lt;temperatures[i])&#123;</span><br><span class="line">                ans[temper.<span class="built_in">top</span>()[<span class="number">1</span>]]=i-temper.<span class="built_in">top</span>()[<span class="number">1</span>];</span><br><span class="line">                temper.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            temper.<span class="built_in">push</span>(&#123;temperatures[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!temper.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ans[temper.<span class="built_in">top</span>()[<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line">            temper.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="划分字母区间中等">划分字母区间（中等）</h2>
<h3 id="题目描述-18">题目描述</h3>
<p>给你一个字符串 <code>s</code>
。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是
<code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </span><br></pre></td></tr></table></figure>
<h3 id="思路-15">思路</h3>
<p>想法不难，用哈希存储每个字母最后出现的次数，再通过遍历一次字符串，用双指针，如果前九个字符满足条件，只出现在这个片段中，那么可以满足哈希表中前九个字符串的所有值的最大值就是第九个字符，所以就用j来存储最大值，i来遍历，直到i等于了j就说明前j个字符的最大出现的位置就是j，那么就可以进行划分</p>
<h3 id="代码-15">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;charToIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            charToIndex[s[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=charToIndex[s[i]];</span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">                num=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;s.<span class="built_in">size</span>())j=charToIndex[s[++i]];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num++;</span><br><span class="line">                j=<span class="built_in">max</span>(j,charToIndex[s[i++]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最长递增子序列中等">最长递增子序列（中等）</h2>
<h3 id="题目描述-19">题目描述</h3>
<p>给你一个整数数组 <code>nums</code>
，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong>
是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>
是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h3 id="思路-16">思路</h3>
<p>用哈希存储每个数字往前能成为严格递增序列的最大长度，对数组进行遍历，遍历的每个数字都要用哈希计算能往前构成严格递增序列的最大长度，最后记录最大的那个数也就是代码中的maxNumber，有点动态规划的感觉</p>
<h3 id="代码-16">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;numAndLength;</span><br><span class="line">        <span class="type">int</span> maxNumber;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            maxNumber=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it=numAndLength.<span class="built_in">begin</span>();it!=numAndLength.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;it-&gt;first)maxNumber=<span class="built_in">max</span>(it-&gt;second+<span class="number">1</span>,maxNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            numAndLength[num]=maxNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=numAndLength.<span class="built_in">begin</span>();it!=numAndLength.<span class="built_in">end</span>();it++)maxNumber=<span class="built_in">max</span>(it-&gt;second,maxNumber);</span><br><span class="line">        <span class="keyword">return</span> maxNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="寻找旋转排序的最小值中等">寻找旋转排序的最小值（中等）</h2>
<h3 id="题目描述-20">题目描述</h3>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由
<code>1</code> 到 <code>n</code> 次 <strong>旋转</strong>
后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code>
在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到
<code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到
<code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code>
<strong>旋转一次</strong> 的结果为数组
<code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code>
，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的
<strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code>
的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure>
<h3 id="思路-17">思路</h3>
<p>二分法找第一个比nums[0]小的数</p>
<h3 id="代码-17">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right<span class="number">-1</span>)&#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">min</span>(nums[right],nums[left]),nums[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="跳跃游戏中等">跳跃游戏（中等）</h2>
<h3 id="题目描述-21">题目描述</h3>
<p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的
<strong>第一个下标</strong>
。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code>
；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure>
<h3 id="思路两种思路-1">思路（两种思路）</h3>
<h4 id="思路一用数组存储状态">思路一：用数组存储状态</h4>
<p>从第一个下标开始，用一个额外的数组记录下能到达的位置，遍历数组，条件为该值被跳跃过就可以继续处理该值，如果遇到没有达到的值就直接返回false，说明到不了该值，那后面的值也到不了</p>
<h4 id="代码一-1">代码一</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">numsTemp</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        numsTemp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numsTemp[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j+i&lt;nums.<span class="built_in">size</span>()&amp;&amp;j&lt;=nums[i];j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j+i==nums.<span class="built_in">size</span>()<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    numsTemp[j+i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="思路二只记录能到达的最远值">思路二：只记录能到达的最远值</h4>
<p>index记录i+nums[i]的最大值，只要index可以到达，可以确保index之前的都能到达，如果index不能到达，说明之后的都无法到达</p>
<p>如果当前遍历的点小于index，说明前面就无法到达该点直接返回false，如果index比数组长度都长了说明能到达最后一个位置</p>
<h4 id="代码二-1">代码二</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;<span class="built_in">max</span>(i,index)&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;=i)index=<span class="built_in">max</span>(index,i+nums[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最长有效括号困难">最长有效括号（困难）</h2>
<h3 id="题目描述-22">题目描述</h3>
<p>给你一个只包含 <code>'('</code> 和 <code>')'</code>
的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure>
<h3 id="思路-18">思路</h3>
<ol type="1">
<li>初始化栈（用来存字符和下标），哈希（用来存储从该点开始往前能组成的最长有效括号长度）</li>
<li>如果栈的最后一位是<code>(</code>,新进来的是<code>)</code>就说明这里是连续括号，但是我们不能只算这个长度，因为可能前面也有挨着的连续有效括号，这时候就需要找栈最后一位<code>(</code>的下标，该下标的前一位如果在哈希表中有值就说明该下标往前能组成有效括号，新进来的能组成的最长有效括号应该是前面挨着的连续的有效括号长度加上该处栈最后一位和新进来的下标差，将这个存储到哈希中以便后面还有有效括号</li>
<li>此外不符合条件的直接往栈里进即可</li>
</ol>
<h3 id="代码-18">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;pair&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&gt;stk;</span><br><span class="line">        <span class="type">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()||stk.<span class="built_in">top</span>().first!=<span class="string">&#x27;(&#x27;</span>||s[i]!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(&#123;s[i],i&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hash[i]=i-stk.<span class="built_in">top</span>().second+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">auto</span> it=hash.<span class="built_in">find</span>(stk.<span class="built_in">top</span>().second<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(it!=hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    hash[i]+=it-&gt;second;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLength=<span class="built_in">max</span>(maxLength,hash[i]);</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="腐烂的橘子中等">腐烂的橘子（中等）</h2>
<h3 id="题目描述-23">题目描述</h3>
<p>在给定的 <code>m x n</code> 网格 <code>grid</code>
中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong>
的新鲜橘子都会腐烂。</p>
<p>返回
<em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回
<code>-1</code></em> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="/post/3a2a3e16/oranges.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<h3 id="思路-19">思路</h3>
<p>我的思路应该就是广度优先吧（/(ㄒoㄒ)/~~）</p>
<p>先用数组记录下本来就是腐烂的橘子的位置，然后遍历数组并用新数组来记录上个数组记录的位置往周围扩展一层的位置，再将这个新数组赋给上一个遍历的数组，遍历完一次count+1，直到新数组的长度为零说明全都遍历完了，最后遍历一次网格如果还有新鲜水果就返回-1</p>
<h3 id="代码-19">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count=<span class="number">-1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;buf;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;buff;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">visited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                    buf.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">                    visited[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> its : buf)&#123;</span><br><span class="line">                <span class="keyword">if</span>(its[<span class="number">0</span>]<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[its[<span class="number">0</span>]<span class="number">-1</span>][its[<span class="number">1</span>]]!=<span class="number">0</span>&amp;&amp;visited[its[<span class="number">0</span>]<span class="number">-1</span>][its[<span class="number">1</span>]]==<span class="number">0</span>)&#123;</span><br><span class="line">                    buff.<span class="built_in">push_back</span>(&#123;its[<span class="number">0</span>]<span class="number">-1</span>,its[<span class="number">1</span>]&#125;);</span><br><span class="line">                    visited[its[<span class="number">0</span>]<span class="number">-1</span>][its[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">                    grid[its[<span class="number">0</span>]<span class="number">-1</span>][its[<span class="number">1</span>]]=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(its[<span class="number">0</span>]+<span class="number">1</span>&lt;m&amp;&amp;grid[its[<span class="number">0</span>]+<span class="number">1</span>][its[<span class="number">1</span>]]!=<span class="number">0</span>&amp;&amp;visited[its[<span class="number">0</span>]+<span class="number">1</span>][its[<span class="number">1</span>]]==<span class="number">0</span>)&#123;</span><br><span class="line">                    buff.<span class="built_in">push_back</span>(&#123;its[<span class="number">0</span>]+<span class="number">1</span>,its[<span class="number">1</span>]&#125;);</span><br><span class="line">                    visited[its[<span class="number">0</span>]+<span class="number">1</span>][its[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">                    grid[its[<span class="number">0</span>]+<span class="number">1</span>][its[<span class="number">1</span>]]=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(its[<span class="number">1</span>]+<span class="number">1</span>&lt;n&amp;&amp;grid[its[<span class="number">0</span>]][its[<span class="number">1</span>]+<span class="number">1</span>]!=<span class="number">0</span>&amp;&amp;visited[its[<span class="number">0</span>]][its[<span class="number">1</span>]+<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                    buff.<span class="built_in">push_back</span>(&#123;its[<span class="number">0</span>],its[<span class="number">1</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">                    visited[its[<span class="number">0</span>]][its[<span class="number">1</span>]+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    grid[its[<span class="number">0</span>]][its[<span class="number">1</span>]+<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(its[<span class="number">1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;(grid[its[<span class="number">0</span>]][its[<span class="number">1</span>]<span class="number">-1</span>]!=<span class="number">0</span>)&amp;&amp;(visited[its[<span class="number">0</span>]][its[<span class="number">1</span>]<span class="number">-1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">                    buff.<span class="built_in">push_back</span>(&#123;its[<span class="number">0</span>],its[<span class="number">1</span>]<span class="number">-1</span>&#125;);</span><br><span class="line">                    visited[its[<span class="number">0</span>]][its[<span class="number">1</span>]<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">                    grid[its[<span class="number">0</span>]][its[<span class="number">1</span>]<span class="number">-1</span>]=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count+=<span class="number">1</span>;</span><br><span class="line">            buf.<span class="built_in">assign</span>(buff.<span class="built_in">begin</span>(),buff.<span class="built_in">end</span>());</span><br><span class="line">            buff.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> its : grid)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> it : its)&#123;</span><br><span class="line">                <span class="keyword">if</span>(it==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">-1</span>?<span class="number">0</span>:count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="两两交换链表中的节点中等">两两交换链表中的节点（中等）</h2>
<h3 id="题目描述-24">题目描述</h3>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/swap_ex1.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>
<h3 id="思路-20">思路</h3>
<p>pre now
nex代表三个相邻的节点，先确定pre，然后如果pre有next并且不为空，就让now=pre-&gt;next.nex=now-&gt;next，否则就返回原链表</p>
<p>然后就让now-&gt;next=pre,pre的next不能直接等于nex，因为可能nex也需要和nex的next进行交换，这里需要判断nex有没有next，有就指向nex的next，没有就指向nex，然后把pre放在nex，重复上面的步骤</p>
<h3 id="代码-20">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)&#123;<span class="keyword">return</span> head;&#125;</span><br><span class="line">        ListNode*res=head-&gt;next;</span><br><span class="line">        ListNode*now;</span><br><span class="line">        ListNode*nex;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;next)&#123;</span><br><span class="line">            now=head-&gt;next;</span><br><span class="line">            nex=now-&gt;next;</span><br><span class="line">            now-&gt;next=head;</span><br><span class="line">            <span class="keyword">if</span>(nex&amp;&amp;nex-&gt;next)head-&gt;next=nex-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> head-&gt;next=nex;</span><br><span class="line">            head=nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="分割回文串中等">分割回文串（中等）</h2>
<h3 id="题目描述-25">题目描述</h3>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code>
分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回
<code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>
<h3 id="知识点-6">知识点</h3>
<ol type="1">
<li><p>截取子串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>(pos, n)   截取s中从pos开始（包括<span class="number">0</span>）的n个字符的子串，并返回</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">substr</span>(pos)     截取s中从从pos开始（包括<span class="number">0</span>）到末尾的所有字符的子串，并返回</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-21">思路</h3>
<p>用回溯的方式去想，大概过程如图所示</p>
<p><img src="/post/3a2a3e16/5bad3ff3851a241373cd83543e10c83.jpg" alt="5bad3ff3851a241373cd83543e10c83" style="zoom:50%;"></p>
<p>从该字符串第一个字符开始，首先选一个字符，如果是回文字符串就将该字符放进返回数组列表，然后以去掉该字符的子字符串作为新字符串，以同样的方法</p>
<h3 id="代码-21">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judgeIfHuiWen</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;stk;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;i++)stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;stk.<span class="built_in">top</span>()==s[++i])stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;stk.<span class="built_in">top</span>()==s[i++])stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>()?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt;ans;</span><br><span class="line">        string ss;</span><br><span class="line">        string ss2;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt;temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ss=s.<span class="built_in">substr</span>(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">judgeIfHuiWen</span>(ss))&#123;</span><br><span class="line">                ss2=s.<span class="built_in">substr</span>(i+<span class="number">1</span>);</span><br><span class="line">                temp=<span class="built_in">partition</span>(ss2);</span><br><span class="line">                <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">					temp.<span class="built_in">push_back</span>(&#123;ss&#125;);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;temp.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        temp[j].<span class="built_in">insert</span>(temp[j].<span class="built_in">begin</span>(),ss);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">insert</span>(ans.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵置零中等">矩阵置零（中等）</h2>
<h3 id="题目描述-26">题目描述</h3>
<p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为
<strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong>
。请使用 <strong><a target="_blank" rel="noopener" href="http://baike.baidu.com/item/原地算法">原地</a></strong>
算法<strong>。</strong></p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/mat1.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure>
<h3 id="思路-22">思路</h3>
<p>遍历数组，如果<code>matric[i][j]</code>为0，就将<code>matric[i][0]</code>和<code>matric[0][j]</code>设为0，这样最后直接对第一行和第一列为0的点再对那一整行或者一整列进行归零即可，在这之前还需要记录第一行第一列是否需要置零</p>
<h3 id="代码-22">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> flag_col0 = <span class="literal">false</span>, flag_row0 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!matrix[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                flag_col0 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                flag_row0 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!matrix[i][j]) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!matrix[i][<span class="number">0</span>] || !matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag_col0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag_row0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最近公共祖先中等">二叉树的最近公共祖先（中等）</h2>
<h3 id="题目描述-27">题目描述</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树
T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且
x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/binarytree.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>
<h3 id="思路-23">思路</h3>
<p>从根节点开始遍历，写一个函数实现判断从该根节点往下是否存在指定节点，如果以左子节点为根节点的树存在两个节点就从该根节点继续往下遍历，如果左右都没有两个节点就说明该根节点是最深的祖先</p>
<h3 id="代码-23">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ifHaveTwo</span><span class="params">(TreeNode*root,TreeNode*p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==p)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> ifHaveTwo(root-&gt;left,p)||ifHaveTwo(root-&gt;right,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>((ifHaveTwo(root-&gt;left,p)&amp;&amp;ifHaveTwo(root-&gt;left,q))||(ifHaveTwo(root-&gt;right,p)&amp;&amp;ifHaveTwo(root-&gt;right,q)))&#123;</span><br><span class="line">            root=ifHaveTwo(root-&gt;left,p)&amp;&amp;ifHaveTwo(root-&gt;left,q)?root-&gt;left:root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的右视图中等">二叉树的右视图（中等）</h2>
<h3 id="题目描述-28">题目描述</h3>
<p>给定一个二叉树的 <strong>根节点</strong>
<code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例 1:</strong></p>
<figure>
<img src="/post/3a2a3e16/tree-16948271877791.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></table></figure>
<h3 id="思路-24">思路</h3>
<p>用层次遍历的思路做，记录每一层，同时记录每一层结束的标记，遍历到一层结束的位置即存在输出数组里即可</p>
<h3 id="代码-24">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode*help=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1000</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode*&gt;treeQueue;</span><br><span class="line">        treeQueue.<span class="built_in">push</span>(root);</span><br><span class="line">        treeQueue.<span class="built_in">push</span>(help);</span><br><span class="line">        <span class="keyword">while</span>(treeQueue.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(treeQueue.<span class="built_in">front</span>()-&gt;left)treeQueue.<span class="built_in">push</span>(treeQueue.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(treeQueue.<span class="built_in">front</span>()-&gt;right)treeQueue.<span class="built_in">push</span>(treeQueue.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">            root=treeQueue.<span class="built_in">front</span>();</span><br><span class="line">            treeQueue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(treeQueue.<span class="built_in">front</span>()-&gt;val==<span class="number">1000</span>)&#123;</span><br><span class="line">                treeQueue.<span class="built_in">push</span>(help);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                treeQueue.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="无重复字符的最长字串中等">无重复字符的最长字串（中等）</h2>
<h3 id="题目描述-29">题目描述</h3>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的
<strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<h3 id="知识点-7">知识点</h3>
<ol type="1">
<li><p>怎么快速查找一个列表里是否有我要找的值：</p>
<p><code>unordered_set</code>：无序集合，它基于哈希表实现，提供了常量时间的平均复杂度进行查找、插入和删除操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unordered_set用于存储字符</span></span><br><span class="line">    std::unordered_set&lt;<span class="type">char</span>&gt; charSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向unordered_set中插入字符</span></span><br><span class="line">    charSet.<span class="built_in">insert</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    charSet.<span class="built_in">insert</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    charSet.<span class="built_in">insert</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查字符是否存在于unordered_set中</span></span><br><span class="line">    <span class="type">char</span> target = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (charSet.<span class="built_in">find</span>(target) != charSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; exists in the set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; does not exist in the set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="思路-25">思路</h3>
<p>用两个指针来标记无重复字符子串的头和尾，用set组合存储子串的所有元素，j每往后移一位就判断一次set组合中是否有该值，有的话i就往后移直到i遇到和j一样的元素，再往后移一位，set也将前面的元素剔除掉，取最长的set长度为五重复字符的最长字串</p>
<h3 id="代码-25">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt;seted;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxCount=<span class="number">0</span>;</span><br><span class="line">        seted.<span class="built_in">insert</span>(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>()&amp;&amp;seted.<span class="built_in">find</span>(s[j])==seted.<span class="built_in">end</span>())&#123;</span><br><span class="line">                seted.<span class="built_in">insert</span>(s[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">            maxCount=<span class="built_in">max</span>(maxCount,j-i);</span><br><span class="line">            <span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>()&amp;&amp;i!=j&amp;&amp;seted.<span class="built_in">find</span>(s[j])!=seted.<span class="built_in">end</span>())&#123;</span><br><span class="line">                seted.<span class="built_in">erase</span>(s[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                seted.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="找到字符串中所有字母异位词中等">找到字符串中所有字母异位词（中等）</h2>
<h3 id="题目描述-30">题目描述</h3>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code>
中所有 <code>p</code> 的 <strong>异位词</strong>
的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>异位词</strong>
指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure>
<h3 id="思路-26">思路</h3>
<ol type="1">
<li>用哈希存储p中每个字符的状态，初始都为0</li>
<li>用i代表子串的头部，用j代表子串的尾部</li>
<li>如果s[j]在哈希表中，并且状态为0，就说明该字符在当前字串还未出现过，j就往后移动，该字符的哈希加一</li>
<li>如果j-i为p的长度说明已经构造除了异位词，将i存在数组中并加一，（加一之后s[i]肯定还在p中）以找下一个子串</li>
<li>如果s[j]不在哈希表中，i和j都要移动到j+1的位置，同时哈希初始化为0</li>
<li>如果s[j]在哈希表中但是已经出现过了，i就需要移动到s[j]在前面出现的位置的下一个，以确保没有出现过</li>
<li>同时由于p中字符会有重复，所有哈希初始化不直接为0，如果重复了再减一，后面直接判断该值是否为1</li>
</ol>
<h3 id="代码-26">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;hashMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> pp : p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.<span class="built_in">find</span>(pp)!=hashMap.<span class="built_in">end</span>())hashMap[pp]--;</span><br><span class="line">            <span class="keyword">else</span> hashMap[pp]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>()&amp;&amp;hashMap.<span class="built_in">find</span>(s[j])==hashMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=i;l&lt;=j<span class="number">-1</span>;l++)hashMap[s[l]]--;</span><br><span class="line">                i=++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>()&amp;&amp;hashMap[s[j]]==<span class="number">1</span>)hashMap[s[i++]]--;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>()&amp;&amp;hashMap.<span class="built_in">find</span>(s[j])!=hashMap.<span class="built_in">end</span>()&amp;&amp;hashMap[s[j]]!=<span class="number">1</span>)hashMap[s[j++]]++;</span><br><span class="line">            <span class="keyword">if</span>(j-i==p.<span class="built_in">size</span>())&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                hashMap[s[i++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="螺旋矩阵中等">螺旋矩阵（中等）</h2>
<h3 id="题目描述-31">题目描述</h3>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵
<code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong>
，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/spiral1.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<h3 id="思路-27">思路</h3>
<p>用up,down,left,right代表边界，比如示例从1-&gt;3遍历完之后，up要加一，代表上边界往下移了，3-&gt;9遍历完之后right要减一代表左边界往右移了，移到上下边界或者左右边界不符合不再满足小于等于关系则说明移完了</p>
<h3 id="代码-27">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> up = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> down = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (up &lt;= down &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt;= right; ++j)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[up][j]);</span><br><span class="line">            up++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = up; i &lt;= down; ++i)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span> (up &lt;= down) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = right; j &gt;= left; --j)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(matrix[down][j]);</span><br><span class="line">                down--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = down; i &gt;= up; --i)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="两数相加中等">两数相加（中等）</h2>
<h3 id="题目描述-32">题目描述</h3>
<p>给你两个 <strong>非空</strong>
的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong>
的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/addtwonumber1.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<h3 id="思路-28">思路</h3>
<p>用两个数相加的思路，比如示例有2+5=7,进位为0，4+6+0=10，进位为1，然后3+4+1=8</p>
<h3 id="代码-28">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* l1Copy=l1;</span><br><span class="line">        ListNode* l2Copy=l2;</span><br><span class="line">        ListNode* ans=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* res=ans;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1Copy&amp;&amp;l2Copy)&#123;</span><br><span class="line">            ListNode*newNode=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            newNode-&gt;val=l1Copy-&gt;val+l2Copy-&gt;val+c;</span><br><span class="line">            <span class="keyword">if</span>(newNode-&gt;val/<span class="number">10</span>)&#123;</span><br><span class="line">                newNode-&gt;val%=<span class="number">10</span>;</span><br><span class="line">                c=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans-&gt;next=newNode;</span><br><span class="line">            ans=newNode;</span><br><span class="line">            l1Copy=l1Copy-&gt;next;</span><br><span class="line">            l2Copy=l2Copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1Copy)&#123;</span><br><span class="line">            ListNode*newNode=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            newNode-&gt;val=l1Copy-&gt;val+c;</span><br><span class="line">            <span class="keyword">if</span>(newNode-&gt;val/<span class="number">10</span>)&#123;</span><br><span class="line">                newNode-&gt;val%=<span class="number">10</span>;</span><br><span class="line">                c=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans-&gt;next=newNode;</span><br><span class="line">            ans=newNode;</span><br><span class="line">            l1Copy=l1Copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2Copy)&#123;</span><br><span class="line">            ListNode*newNode=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            newNode-&gt;val=l2Copy-&gt;val+c;</span><br><span class="line">            <span class="keyword">if</span>(newNode-&gt;val/<span class="number">10</span>)&#123;</span><br><span class="line">                newNode-&gt;val%=<span class="number">10</span>;</span><br><span class="line">                c=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans-&gt;next=newNode;</span><br><span class="line">            ans=newNode;</span><br><span class="line">            l2Copy=l2Copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">1</span>)&#123;</span><br><span class="line">             ListNode*newNode=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">             ans-&gt;next=newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="排序链表中等">排序链表（中等）</h2>
<p>ps:实在是不想调试了，看了题解发现方法没问题就直接copy了/(ㄒoㄒ)/~~</p>
<h3 id="题目描述-33">题目描述</h3>
<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong>
排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="/post/3a2a3e16/sort_list_1.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>
<h3 id="思路-29">思路</h3>
<p>归并排序，比如示例1：</p>
<p>[4] [2] [1] [3]</p>
<p>先每两个排序：</p>
<p>[2,4] [1,3]</p>
<p>再合并两个有序链表</p>
<p>[1,2,3,4]</p>
<h3 id="代码-29">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> subLength = <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode* prev = dummyHead, *curr = dummyHead-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ListNode* head1 = curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curr-&gt;next != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* head2 = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="literal">nullptr</span> &amp;&amp; curr-&gt;next != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    next = curr-&gt;next;</span><br><span class="line">                    curr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* merged = <span class="built_in">merge</span>(head1, head2);</span><br><span class="line">                prev-&gt;next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">nullptr</span> &amp;&amp; temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="电话号码的字母组合中等">电话号码的字母组合（中等）</h2>
<h3 id="题目描述-34">题目描述</h3>
<p>给定一个仅包含数字 <code>2-9</code>
的字符串，返回所有它能表示的字母组合。答案可以按
<strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1
不对应任何字母。</p>
<figure>
<img src="/post/3a2a3e16/200px-telephone-keypad2svg.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="思路-30">思路</h3>
<p>很简单的回溯思路</p>
<h3 id="代码-30">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt;ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;numToChar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string digits,string singleAns)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(singleAns.<span class="built_in">size</span>()!=<span class="number">0</span>)ans.<span class="built_in">push_back</span>(singleAns);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : numToChar[digits[<span class="number">0</span>]<span class="number">-48</span>])&#123;</span><br><span class="line">            singleAns.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            <span class="built_in">dfs</span>(digits.<span class="built_in">substr</span>(<span class="number">1</span>),singleAns);</span><br><span class="line">            singleAns.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        numToChar.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">        numToChar[<span class="number">2</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        numToChar[<span class="number">3</span>]=&#123;<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">        numToChar[<span class="number">4</span>]=&#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;;</span><br><span class="line">        numToChar[<span class="number">5</span>]=&#123;<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">        numToChar[<span class="number">6</span>]=&#123;<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">        numToChar[<span class="number">7</span>]=&#123;<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;;</span><br><span class="line">        numToChar[<span class="number">8</span>]=&#123;<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;;</span><br><span class="line">        numToChar[<span class="number">9</span>]=&#123;<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(digits,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="前k个高频元素中等">前k个高频元素（中等）</h2>
<h3 id="题目描述-35">题目描述</h3>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>
，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按
<strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>
<h3 id="思路-31">思路</h3>
<p>用set集合，set放置一个元素是logn的时间复杂度，首先获取每个元素出现的次数，接着记录出现次数对应的元素，并将次数存入set，接着取set前k个数，取出次数对应元素</p>
<h3 id="代码-31">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;numTimes;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;timeNums;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt;times;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            numTimes[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it= numTimes.<span class="built_in">begin</span>();it!=numTimes.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            timeNums[it-&gt;second].<span class="built_in">push_back</span>(it-&gt;first);</span><br><span class="line">            times.<span class="built_in">insert</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = times.<span class="built_in">rbegin</span>();k; ++it) &#123;</span><br><span class="line">            k-=timeNums[*it].<span class="built_in">size</span>();</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">end</span>(),timeNums[*it].<span class="built_in">begin</span>(),timeNums[*it].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机中等">买卖股票的最佳时机（中等）</h2>
<h3 id="题目描述-36">题目描述</h3>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素
<code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在
<strong>未来的某一个不同的日子</strong>
卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回
<code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
<h3 id="思路-32">思路</h3>
<p>min存储遇到的最低价格，max存储往后的最高价格，最佳时机应为前面的最低价格和遇到的最高价格之差</p>
<h3 id="代码-32">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>];  <span class="comment">// 初始化为第一个价格</span></span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            maxProfit = <span class="built_in">max</span>(maxProfit, prices[i] - minPrice);</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="单词拆分中等">单词拆分（中等）</h2>
<h3 id="题目描述-37">题目描述</h3>
<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code>
作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code>
。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<h3 id="思路-33">思路</h3>
<p>首先将worddict存在set中方便查找，然后用dp[i]存储从0下标到i下标的字符串是否能够被word里的单词组成，dp[i]的更新方式是，遍历前20个字符下标，如果dp[j]为1，也就是该下标之前的都能被表示，就从该下标到i确定组成的新字符串是否在单词列表中</p>
<h3 id="代码-33">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt;word;</span><br><span class="line">        <span class="keyword">for</span>(string ss : wordDict)&#123;</span><br><span class="line">            word.<span class="built_in">insert</span>(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i&gt;=<span class="number">20</span>?i<span class="number">-20</span>:<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j==<span class="number">0</span>||dp[j<span class="number">-1</span>]==<span class="number">1</span>)&amp;&amp;word.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j,i-j+<span class="number">1</span>)))&#123;</span><br><span class="line">                    dp[i]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="number">1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="寻找重复数中等">寻找重复数（中等）</h2>
<h3 id="题目描述-38">题目描述</h3>
<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code>
，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和
<code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回
<strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code>
且只用常量级 <code>O(1)</code> 的额外空间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,3,4,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h3 id="思路-34">思路</h3>
<p>快慢指针</p>
<p>我们对 numsnums 数组建图，每个位置 iii 连一条 i→nums[i]i[i]i→nums[i]
的边。由于存在的重复的数字 targettarget，因此 targettarget
这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的
targettarget 就是这个环的入口，那么整个问题就等价于 142. 环形链表
II。</p>
<p>我们先设置慢指针 slowslow 和快指针 fastfast
，慢指针每次走一步，快指针每次走两步，根据「Floyd
判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 slowslow
放置起点 000，两个指针每次同时移动一步，相遇的点就是答案。</p>
<p>这里简单解释为什么后面将 slowslow
放置起点后移动相遇的点就一定是答案了。假设环长为
LLL，从起点到环的入口的步数是 aaa，从环的入口继续走 bbb
步到达相遇位置，从相遇位置继续走 ccc 步回到环的入口，则有
b+c=Lb+c=Lb+c=L，其中 LLL、aaa、bbb、ccc
都是正整数。根据上述定义，慢指针走了 a+ba+ba+b 步，快指针走了
2(a+b)2(a+b)2(a+b)
步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成
a+b+kLa+b+kLa+b+kL，其中 kkk
表示快指针在环上走的圈数。联立等式，可以得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2(a+b)=a+b+kL2(a+b)=a+b+kL</span><br><span class="line">2(a+b)=a+b+kL</span><br></pre></td></tr></table></figure>
<p>解得 <code>a=kL−ba=kL-ba=kL−b</code>，整理可得</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=(k−1)L+(L−b)=(k−1)L+ca=(k-1)L+(L-b)=(k-1)L+c</span><br><span class="line">a=(k−1)L+(L−b)=(k−1)L+c</span><br></pre></td></tr></table></figure>
<p>从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了
aaa 步之后到达环的入口，快指针在环里走了 k−1k-1k−1 圈之后又走了 ccc
步，由于从相遇位置继续走 ccc
步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。</p>
<h3 id="代码-34">代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            i=nums[i];</span><br><span class="line">            j=nums[nums[j]];</span><br><span class="line">        &#125;<span class="keyword">while</span>(i!=j);</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">            i=nums[i];</span><br><span class="line">            j=nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>leetcode100题_last</p><p><a href="http://example.com/post/3a2a3e16.html">http://example.com/post/3a2a3e16.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>yyyyyyxnp</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2023-08-29</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-10-08</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/c/">c</a><a class="link-muted mr-2" rel="tag" href="/tags/c/">c++</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>Afdian.net</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/8db3fa22.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">networks画图学习</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/5ad7933.html"><span class="level-item">高阶网络学习</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Yyyyyyxnp"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yyyyyyxnp</p><p class="is-size-6 is-block">Student Yang</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Sichuan University</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">48</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/deng12yx" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/deng12yx"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#二叉树中的最大路径和困难"><span class="level-left"><span class="level-item">1</span><span class="level-item">二叉树中的最大路径和（困难）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#验证二叉搜索树中等"><span class="level-left"><span class="level-item">2</span><span class="level-item">验证二叉搜索树(中等)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-1"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-1"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-1"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三数之和中等"><span class="level-left"><span class="level-item">3</span><span class="level-item">三数之和（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-2"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-2"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-2"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#lru缓存中等"><span class="level-left"><span class="level-item">4</span><span class="level-item">LRU缓存（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-3"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-3"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-3"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#从前序和中序遍历序列构造二叉树中等"><span class="level-left"><span class="level-item">5</span><span class="level-item">从前序和中序遍历序列构造二叉树（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-4"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-4"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-4"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#搜索二维矩阵中等"><span class="level-left"><span class="level-item">6</span><span class="level-item">搜索二维矩阵（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-5"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">思路(两种思路)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一二分查找"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">思路一：二分查找</span></span></a></li><li><a class="level is-mobile" href="#代码一"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二z字形查找"><span class="level-left"><span class="level-item">6.2.3</span><span class="level-item">思路二：Z字形查找</span></span></a></li><li><a class="level is-mobile" href="#代码二"><span class="level-left"><span class="level-item">6.2.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#n皇后困难"><span class="level-left"><span class="level-item">7</span><span class="level-item">N皇后（困难）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-6"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-5"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-5"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#在排序数组中查找元素的第一个和最后一个位置中等"><span class="level-left"><span class="level-item">8</span><span class="level-item">在排序数组中查找元素的第一个和最后一个位置(中等)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-7"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-6"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-6"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#爬楼梯简单"><span class="level-left"><span class="level-item">9</span><span class="level-item">爬楼梯（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-8"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-7"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-7"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#完全平方数中等"><span class="level-left"><span class="level-item">10</span><span class="level-item">完全平方数（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-9"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-2"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-8"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-8"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二叉树的直径简单"><span class="level-left"><span class="level-item">11</span><span class="level-item">二叉树的直径（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-10"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-9"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-9"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#将有序数组转换为二叉搜索树简单"><span class="level-left"><span class="level-item">12</span><span class="level-item">将有序数组转换为二叉搜索树（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-11"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-3"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-10"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-10"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#环形链表中等"><span class="level-left"><span class="level-item">13</span><span class="level-item">环形链表（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-12"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-11"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-11"><span class="level-left"><span class="level-item">13.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#翻转二叉树简单"><span class="level-left"><span class="level-item">14</span><span class="level-item">翻转二叉树（简单）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-13"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-12"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-12"><span class="level-left"><span class="level-item">14.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数组中第k个最大的元素中等待做"><span class="level-left"><span class="level-item">15</span><span class="level-item">数组中第k个最大的元素(中等)（待做）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-14"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路大根堆"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">思路：大根堆</span></span></a></li></ul></li><li><a class="level is-mobile" href="#课程表中等"><span class="level-left"><span class="level-item">16</span><span class="level-item">课程表（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-15"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-4"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-13"><span class="level-left"><span class="level-item">16.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-13"><span class="level-left"><span class="level-item">16.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#分割等和子集中等待做"><span class="level-left"><span class="level-item">17</span><span class="level-item">分割等和子集（中等）（待做）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-16"><span class="level-left"><span class="level-item">17.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-5"><span class="level-left"><span class="level-item">17.2</span><span class="level-item">知识点</span></span></a></li></ul></li><li><a class="level is-mobile" href="#每日温度中等"><span class="level-left"><span class="level-item">18</span><span class="level-item">每日温度（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-17"><span class="level-left"><span class="level-item">18.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-14"><span class="level-left"><span class="level-item">18.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-14"><span class="level-left"><span class="level-item">18.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#划分字母区间中等"><span class="level-left"><span class="level-item">19</span><span class="level-item">划分字母区间（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-18"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-15"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-15"><span class="level-left"><span class="level-item">19.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#最长递增子序列中等"><span class="level-left"><span class="level-item">20</span><span class="level-item">最长递增子序列（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-19"><span class="level-left"><span class="level-item">20.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-16"><span class="level-left"><span class="level-item">20.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-16"><span class="level-left"><span class="level-item">20.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#寻找旋转排序的最小值中等"><span class="level-left"><span class="level-item">21</span><span class="level-item">寻找旋转排序的最小值（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-20"><span class="level-left"><span class="level-item">21.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-17"><span class="level-left"><span class="level-item">21.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-17"><span class="level-left"><span class="level-item">21.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#跳跃游戏中等"><span class="level-left"><span class="level-item">22</span><span class="level-item">跳跃游戏（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-21"><span class="level-left"><span class="level-item">22.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路两种思路-1"><span class="level-left"><span class="level-item">22.2</span><span class="level-item">思路（两种思路）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#思路一用数组存储状态"><span class="level-left"><span class="level-item">22.2.1</span><span class="level-item">思路一：用数组存储状态</span></span></a></li><li><a class="level is-mobile" href="#代码一-1"><span class="level-left"><span class="level-item">22.2.2</span><span class="level-item">代码一</span></span></a></li><li><a class="level is-mobile" href="#思路二只记录能到达的最远值"><span class="level-left"><span class="level-item">22.2.3</span><span class="level-item">思路二：只记录能到达的最远值</span></span></a></li><li><a class="level is-mobile" href="#代码二-1"><span class="level-left"><span class="level-item">22.2.4</span><span class="level-item">代码二</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#最长有效括号困难"><span class="level-left"><span class="level-item">23</span><span class="level-item">最长有效括号（困难）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-22"><span class="level-left"><span class="level-item">23.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-18"><span class="level-left"><span class="level-item">23.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-18"><span class="level-left"><span class="level-item">23.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#腐烂的橘子中等"><span class="level-left"><span class="level-item">24</span><span class="level-item">腐烂的橘子（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-23"><span class="level-left"><span class="level-item">24.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-19"><span class="level-left"><span class="level-item">24.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-19"><span class="level-left"><span class="level-item">24.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#两两交换链表中的节点中等"><span class="level-left"><span class="level-item">25</span><span class="level-item">两两交换链表中的节点（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-24"><span class="level-left"><span class="level-item">25.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-20"><span class="level-left"><span class="level-item">25.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-20"><span class="level-left"><span class="level-item">25.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#分割回文串中等"><span class="level-left"><span class="level-item">26</span><span class="level-item">分割回文串（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-25"><span class="level-left"><span class="level-item">26.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-6"><span class="level-left"><span class="level-item">26.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-21"><span class="level-left"><span class="level-item">26.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-21"><span class="level-left"><span class="level-item">26.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#矩阵置零中等"><span class="level-left"><span class="level-item">27</span><span class="level-item">矩阵置零（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-26"><span class="level-left"><span class="level-item">27.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-22"><span class="level-left"><span class="level-item">27.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-22"><span class="level-left"><span class="level-item">27.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二叉树的最近公共祖先中等"><span class="level-left"><span class="level-item">28</span><span class="level-item">二叉树的最近公共祖先（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-27"><span class="level-left"><span class="level-item">28.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-23"><span class="level-left"><span class="level-item">28.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-23"><span class="level-left"><span class="level-item">28.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二叉树的右视图中等"><span class="level-left"><span class="level-item">29</span><span class="level-item">二叉树的右视图（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-28"><span class="level-left"><span class="level-item">29.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-24"><span class="level-left"><span class="level-item">29.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-24"><span class="level-left"><span class="level-item">29.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#无重复字符的最长字串中等"><span class="level-left"><span class="level-item">30</span><span class="level-item">无重复字符的最长字串（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-29"><span class="level-left"><span class="level-item">30.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#知识点-7"><span class="level-left"><span class="level-item">30.2</span><span class="level-item">知识点</span></span></a></li><li><a class="level is-mobile" href="#思路-25"><span class="level-left"><span class="level-item">30.3</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-25"><span class="level-left"><span class="level-item">30.4</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#找到字符串中所有字母异位词中等"><span class="level-left"><span class="level-item">31</span><span class="level-item">找到字符串中所有字母异位词（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-30"><span class="level-left"><span class="level-item">31.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-26"><span class="level-left"><span class="level-item">31.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-26"><span class="level-left"><span class="level-item">31.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#螺旋矩阵中等"><span class="level-left"><span class="level-item">32</span><span class="level-item">螺旋矩阵（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-31"><span class="level-left"><span class="level-item">32.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-27"><span class="level-left"><span class="level-item">32.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-27"><span class="level-left"><span class="level-item">32.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#两数相加中等"><span class="level-left"><span class="level-item">33</span><span class="level-item">两数相加（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-32"><span class="level-left"><span class="level-item">33.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-28"><span class="level-left"><span class="level-item">33.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-28"><span class="level-left"><span class="level-item">33.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#排序链表中等"><span class="level-left"><span class="level-item">34</span><span class="level-item">排序链表（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-33"><span class="level-left"><span class="level-item">34.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-29"><span class="level-left"><span class="level-item">34.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-29"><span class="level-left"><span class="level-item">34.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#电话号码的字母组合中等"><span class="level-left"><span class="level-item">35</span><span class="level-item">电话号码的字母组合（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-34"><span class="level-left"><span class="level-item">35.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-30"><span class="level-left"><span class="level-item">35.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-30"><span class="level-left"><span class="level-item">35.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#前k个高频元素中等"><span class="level-left"><span class="level-item">36</span><span class="level-item">前k个高频元素（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-35"><span class="level-left"><span class="level-item">36.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-31"><span class="level-left"><span class="level-item">36.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-31"><span class="level-left"><span class="level-item">36.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#买卖股票的最佳时机中等"><span class="level-left"><span class="level-item">37</span><span class="level-item">买卖股票的最佳时机（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-36"><span class="level-left"><span class="level-item">37.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-32"><span class="level-left"><span class="level-item">37.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-32"><span class="level-left"><span class="level-item">37.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#单词拆分中等"><span class="level-left"><span class="level-item">38</span><span class="level-item">单词拆分（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-37"><span class="level-left"><span class="level-item">38.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-33"><span class="level-left"><span class="level-item">38.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-33"><span class="level-left"><span class="level-item">38.3</span><span class="level-item">代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#寻找重复数中等"><span class="level-left"><span class="level-item">39</span><span class="level-item">寻找重复数（中等）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-38"><span class="level-left"><span class="level-item">39.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#思路-34"><span class="level-left"><span class="level-item">39.2</span><span class="level-item">思路</span></span></a></li><li><a class="level is-mobile" href="#代码-34"><span class="level-left"><span class="level-item">39.3</span><span class="level-item">代码</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-01T13:27:46.000Z">2025-09-01</time></p><p class="title"><a href="/post/faa1c95e.html">ctfshow初学</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/b64de532.html"><img src="/img/article/23.png" alt="ai_tools"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-25T05:34:16.000Z">2024-12-25</time></p><p class="title"><a href="/post/b64de532.html">ai_tools</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/d75064c8.html"><img src="/img/article/18.png" alt="基础知识学习"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-10-09T11:54:53.000Z">2024-10-09</time></p><p class="title"><a href="/post/d75064c8.html">基础知识学习</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/9c1a1a1.html"><img src="/img/article/17.png" alt="luogu_1"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-10-08T10:50:27.000Z">2024-10-08</time></p><p class="title"><a href="/post/9c1a1a1.html">luogu_1</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/7684f23b.html"><img src="/img/article/15.png" alt="T2I"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-23T06:17:27.000Z">2024-09-23</time></p><p class="title"><a href="/post/7684f23b.html">T2I</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">BeautyFlower</a><p class="is-size-7"><span>&copy; 2025 yyyyyyxnp</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/deng12yx"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'folded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>